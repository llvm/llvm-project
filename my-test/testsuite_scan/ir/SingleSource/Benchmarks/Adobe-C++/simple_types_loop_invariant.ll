; ModuleID = '/home/youzhewei.linux/work/llvm-project/llvm-test-suite/SingleSource/Benchmarks/Adobe-C++/simple_types_loop_invariant.cpp'
source_filename = "/home/youzhewei.linux/work/llvm-project/llvm-test-suite/SingleSource/Benchmarks/Adobe-C++/simple_types_loop_invariant.cpp"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32"
target triple = "aarch64-unknown-linux-gnu"

%struct.one_result = type { double, ptr }

$_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

@results = dso_local local_unnamed_addr global ptr null, align 8
@current_test = dso_local local_unnamed_addr global i32 0, align 4
@allocated_results = dso_local local_unnamed_addr global i32 0, align 4
@.str = private unnamed_addr constant [31 x i8] c"Could not allocate %d results\0A\00", align 1
@.str.1 = private unnamed_addr constant [60 x i8] c"\0Atest %*s description   absolute   operations   ratio with\0A\00", align 1
@.str.2 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.3 = private unnamed_addr constant [43 x i8] c"number %*s time       per second   test0\0A\0A\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"%2i %*s\22%s\22  %5.2f sec   %5.2f M     %.2f\0A\00", align 1
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [39 x i8] c"\0ATotal absolute time for %s: %.2f sec\0A\00", align 1
@.str.7 = private unnamed_addr constant [20 x i8] c"\0A%s Penalty: %.2f\0A\0A\00", align 1
@.str.8 = private unnamed_addr constant [34 x i8] c"\0Atest %*s description   absolute\0A\00", align 1
@.str.9 = private unnamed_addr constant [18 x i8] c"number %*s time\0A\0A\00", align 1
@.str.10 = private unnamed_addr constant [24 x i8] c"%2i %*s\22%s\22  %5.2f sec\0A\00", align 1
@start_time = dso_local local_unnamed_addr global i64 0, align 8
@end_time = dso_local local_unnamed_addr global i64 0, align 8
@iterations = dso_local local_unnamed_addr global i32 1000, align 4
@init_value = dso_local local_unnamed_addr global double 1.000000e+00, align 8
@dataDouble = dso_local global [8000 x double] zeroinitializer, align 8
@dataFloat = dso_local global [8000 x float] zeroinitializer, align 4
@data64unsigned = dso_local global [8000 x i64] zeroinitializer, align 8
@data64 = dso_local global [8000 x i64] zeroinitializer, align 8
@data32unsigned = dso_local global [8000 x i32] zeroinitializer, align 4
@data32 = dso_local global [8000 x i32] zeroinitializer, align 4
@data16unsigned = dso_local global [8000 x i16] zeroinitializer, align 2
@data16 = dso_local global [8000 x i16] zeroinitializer, align 2
@data8unsigned = dso_local global [8000 x i8] zeroinitializer, align 1
@data8 = dso_local global [8000 x i8] zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [20 x i8] c"int8_t variable add\00", align 1
@.str.12 = private unnamed_addr constant [28 x i8] c"int8_t variable add hoisted\00", align 1
@.str.13 = private unnamed_addr constant [30 x i8] c"int8_t multiple variable adds\00", align 1
@.str.14 = private unnamed_addr constant [25 x i8] c"int8_t variable subtract\00", align 1
@.str.15 = private unnamed_addr constant [35 x i8] c"int8_t multiple variable subtracts\00", align 1
@.str.16 = private unnamed_addr constant [25 x i8] c"int8_t variable multiply\00", align 1
@.str.17 = private unnamed_addr constant [36 x i8] c"int8_t multiple variable multiplies\00", align 1
@.str.18 = private unnamed_addr constant [37 x i8] c"int8_t multiple variable multiplies2\00", align 1
@.str.19 = private unnamed_addr constant [23 x i8] c"int8_t variable divide\00", align 1
@.str.20 = private unnamed_addr constant [33 x i8] c"int8_t multiple variable divides\00", align 1
@.str.21 = private unnamed_addr constant [34 x i8] c"int8_t multiple variable divides2\00", align 1
@.str.22 = private unnamed_addr constant [31 x i8] c"int8_t multiple variable mixed\00", align 1
@.str.23 = private unnamed_addr constant [20 x i8] c"int8_t variable and\00", align 1
@.str.24 = private unnamed_addr constant [29 x i8] c"int8_t multiple variable and\00", align 1
@.str.25 = private unnamed_addr constant [19 x i8] c"int8_t variable or\00", align 1
@.str.26 = private unnamed_addr constant [28 x i8] c"int8_t multiple variable or\00", align 1
@.str.27 = private unnamed_addr constant [20 x i8] c"int8_t variable xor\00", align 1
@.str.28 = private unnamed_addr constant [29 x i8] c"int8_t multiple variable xor\00", align 1
@.str.29 = private unnamed_addr constant [21 x i8] c"uint8_t variable add\00", align 1
@.str.30 = private unnamed_addr constant [29 x i8] c"uint8_t variable add hoisted\00", align 1
@.str.31 = private unnamed_addr constant [31 x i8] c"uint8_t multiple variable adds\00", align 1
@.str.32 = private unnamed_addr constant [26 x i8] c"uint8_t variable subtract\00", align 1
@.str.33 = private unnamed_addr constant [36 x i8] c"uint8_t multiple variable subtracts\00", align 1
@.str.34 = private unnamed_addr constant [26 x i8] c"uint8_t variable multiply\00", align 1
@.str.35 = private unnamed_addr constant [37 x i8] c"uint8_t multiple variable multiplies\00", align 1
@.str.36 = private unnamed_addr constant [38 x i8] c"uint8_t multiple variable multiplies2\00", align 1
@.str.37 = private unnamed_addr constant [24 x i8] c"uint8_t variable divide\00", align 1
@.str.38 = private unnamed_addr constant [34 x i8] c"uint8_t multiple variable divides\00", align 1
@.str.39 = private unnamed_addr constant [35 x i8] c"uint8_t multiple variable divides2\00", align 1
@.str.40 = private unnamed_addr constant [32 x i8] c"uint8_t multiple variable mixed\00", align 1
@.str.41 = private unnamed_addr constant [21 x i8] c"uint8_t variable and\00", align 1
@.str.42 = private unnamed_addr constant [30 x i8] c"uint8_t multiple variable and\00", align 1
@.str.43 = private unnamed_addr constant [20 x i8] c"uint8_t variable or\00", align 1
@.str.44 = private unnamed_addr constant [29 x i8] c"uint8_t multiple variable or\00", align 1
@.str.45 = private unnamed_addr constant [21 x i8] c"uint8_t variable xor\00", align 1
@.str.46 = private unnamed_addr constant [30 x i8] c"uint8_t multiple variable xor\00", align 1
@.str.47 = private unnamed_addr constant [21 x i8] c"int16_t variable add\00", align 1
@.str.48 = private unnamed_addr constant [29 x i8] c"int16_t variable add hoisted\00", align 1
@.str.49 = private unnamed_addr constant [31 x i8] c"int16_t multiple variable adds\00", align 1
@.str.50 = private unnamed_addr constant [26 x i8] c"int16_t variable subtract\00", align 1
@.str.51 = private unnamed_addr constant [36 x i8] c"int16_t multiple variable subtracts\00", align 1
@.str.52 = private unnamed_addr constant [26 x i8] c"int16_t variable multiply\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"int16_t multiple variable multiplies\00", align 1
@.str.54 = private unnamed_addr constant [38 x i8] c"int16_t multiple variable multiplies2\00", align 1
@.str.55 = private unnamed_addr constant [24 x i8] c"int16_t variable divide\00", align 1
@.str.56 = private unnamed_addr constant [34 x i8] c"int16_t multiple variable divides\00", align 1
@.str.57 = private unnamed_addr constant [35 x i8] c"int16_t multiple variable divides2\00", align 1
@.str.58 = private unnamed_addr constant [32 x i8] c"int16_t multiple variable mixed\00", align 1
@.str.59 = private unnamed_addr constant [21 x i8] c"int16_t variable and\00", align 1
@.str.60 = private unnamed_addr constant [30 x i8] c"int16_t multiple variable and\00", align 1
@.str.61 = private unnamed_addr constant [20 x i8] c"int16_t variable or\00", align 1
@.str.62 = private unnamed_addr constant [29 x i8] c"int16_t multiple variable or\00", align 1
@.str.63 = private unnamed_addr constant [21 x i8] c"int16_t variable xor\00", align 1
@.str.64 = private unnamed_addr constant [30 x i8] c"int16_t multiple variable xor\00", align 1
@.str.65 = private unnamed_addr constant [22 x i8] c"uint16_t variable add\00", align 1
@.str.66 = private unnamed_addr constant [30 x i8] c"uint16_t variable add hoisted\00", align 1
@.str.67 = private unnamed_addr constant [32 x i8] c"uint16_t multiple variable adds\00", align 1
@.str.68 = private unnamed_addr constant [27 x i8] c"uint16_t variable subtract\00", align 1
@.str.69 = private unnamed_addr constant [37 x i8] c"uint16_t multiple variable subtracts\00", align 1
@.str.70 = private unnamed_addr constant [27 x i8] c"uint16_t variable multiply\00", align 1
@.str.71 = private unnamed_addr constant [38 x i8] c"uint16_t multiple variable multiplies\00", align 1
@.str.72 = private unnamed_addr constant [39 x i8] c"uint16_t multiple variable multiplies2\00", align 1
@.str.73 = private unnamed_addr constant [25 x i8] c"uint16_t variable divide\00", align 1
@.str.74 = private unnamed_addr constant [35 x i8] c"uint16_t multiple variable divides\00", align 1
@.str.75 = private unnamed_addr constant [36 x i8] c"uint16_t multiple variable divides2\00", align 1
@.str.76 = private unnamed_addr constant [33 x i8] c"uint16_t multiple variable mixed\00", align 1
@.str.77 = private unnamed_addr constant [22 x i8] c"uint16_t variable and\00", align 1
@.str.78 = private unnamed_addr constant [31 x i8] c"uint16_t multiple variable and\00", align 1
@.str.79 = private unnamed_addr constant [21 x i8] c"uint16_t variable or\00", align 1
@.str.80 = private unnamed_addr constant [30 x i8] c"uint16_t multiple variable or\00", align 1
@.str.81 = private unnamed_addr constant [22 x i8] c"uint16_t variable xor\00", align 1
@.str.82 = private unnamed_addr constant [31 x i8] c"uint16_t multiple variable xor\00", align 1
@.str.83 = private unnamed_addr constant [21 x i8] c"int32_t variable add\00", align 1
@.str.84 = private unnamed_addr constant [29 x i8] c"int32_t variable add hoisted\00", align 1
@.str.85 = private unnamed_addr constant [31 x i8] c"int32_t multiple variable adds\00", align 1
@.str.86 = private unnamed_addr constant [26 x i8] c"int32_t variable subtract\00", align 1
@.str.87 = private unnamed_addr constant [36 x i8] c"int32_t multiple variable subtracts\00", align 1
@.str.88 = private unnamed_addr constant [26 x i8] c"int32_t variable multiply\00", align 1
@.str.89 = private unnamed_addr constant [37 x i8] c"int32_t multiple variable multiplies\00", align 1
@.str.90 = private unnamed_addr constant [38 x i8] c"int32_t multiple variable multiplies2\00", align 1
@.str.91 = private unnamed_addr constant [24 x i8] c"int32_t variable divide\00", align 1
@.str.92 = private unnamed_addr constant [34 x i8] c"int32_t multiple variable divides\00", align 1
@.str.93 = private unnamed_addr constant [35 x i8] c"int32_t multiple variable divides2\00", align 1
@.str.94 = private unnamed_addr constant [32 x i8] c"int32_t multiple variable mixed\00", align 1
@.str.95 = private unnamed_addr constant [21 x i8] c"int32_t variable and\00", align 1
@.str.96 = private unnamed_addr constant [30 x i8] c"int32_t multiple variable and\00", align 1
@.str.97 = private unnamed_addr constant [20 x i8] c"int32_t variable or\00", align 1
@.str.98 = private unnamed_addr constant [29 x i8] c"int32_t multiple variable or\00", align 1
@.str.99 = private unnamed_addr constant [21 x i8] c"int32_t variable xor\00", align 1
@.str.100 = private unnamed_addr constant [30 x i8] c"int32_t multiple variable xor\00", align 1
@.str.101 = private unnamed_addr constant [22 x i8] c"uint32_t variable add\00", align 1
@.str.102 = private unnamed_addr constant [30 x i8] c"uint32_t variable add hoisted\00", align 1
@.str.103 = private unnamed_addr constant [32 x i8] c"uint32_t multiple variable adds\00", align 1
@.str.104 = private unnamed_addr constant [27 x i8] c"uint32_t variable subtract\00", align 1
@.str.105 = private unnamed_addr constant [37 x i8] c"uint32_t multiple variable subtracts\00", align 1
@.str.106 = private unnamed_addr constant [27 x i8] c"uint32_t variable multiply\00", align 1
@.str.107 = private unnamed_addr constant [38 x i8] c"uint32_t multiple variable multiplies\00", align 1
@.str.108 = private unnamed_addr constant [39 x i8] c"uint32_t multiple variable multiplies2\00", align 1
@.str.109 = private unnamed_addr constant [25 x i8] c"uint32_t variable divide\00", align 1
@.str.110 = private unnamed_addr constant [35 x i8] c"uint32_t multiple variable divides\00", align 1
@.str.111 = private unnamed_addr constant [36 x i8] c"uint32_t multiple variable divides2\00", align 1
@.str.112 = private unnamed_addr constant [33 x i8] c"uint32_t multiple variable mixed\00", align 1
@.str.113 = private unnamed_addr constant [22 x i8] c"uint32_t variable and\00", align 1
@.str.114 = private unnamed_addr constant [31 x i8] c"uint32_t multiple variable and\00", align 1
@.str.115 = private unnamed_addr constant [21 x i8] c"uint32_t variable or\00", align 1
@.str.116 = private unnamed_addr constant [30 x i8] c"uint32_t multiple variable or\00", align 1
@.str.117 = private unnamed_addr constant [22 x i8] c"uint32_t variable xor\00", align 1
@.str.118 = private unnamed_addr constant [31 x i8] c"uint32_t multiple variable xor\00", align 1
@.str.119 = private unnamed_addr constant [21 x i8] c"int64_t variable add\00", align 1
@.str.120 = private unnamed_addr constant [29 x i8] c"int64_t variable add hoisted\00", align 1
@.str.121 = private unnamed_addr constant [31 x i8] c"int64_t multiple variable adds\00", align 1
@.str.122 = private unnamed_addr constant [26 x i8] c"int64_t variable subtract\00", align 1
@.str.123 = private unnamed_addr constant [36 x i8] c"int64_t multiple variable subtracts\00", align 1
@.str.124 = private unnamed_addr constant [26 x i8] c"int64_t variable multiply\00", align 1
@.str.125 = private unnamed_addr constant [37 x i8] c"int64_t multiple variable multiplies\00", align 1
@.str.126 = private unnamed_addr constant [38 x i8] c"int64_t multiple variable multiplies2\00", align 1
@.str.127 = private unnamed_addr constant [24 x i8] c"int64_t variable divide\00", align 1
@.str.128 = private unnamed_addr constant [34 x i8] c"int64_t multiple variable divides\00", align 1
@.str.129 = private unnamed_addr constant [35 x i8] c"int64_t multiple variable divides2\00", align 1
@.str.130 = private unnamed_addr constant [32 x i8] c"int64_t multiple variable mixed\00", align 1
@.str.131 = private unnamed_addr constant [21 x i8] c"int64_t variable and\00", align 1
@.str.132 = private unnamed_addr constant [30 x i8] c"int64_t multiple variable and\00", align 1
@.str.133 = private unnamed_addr constant [20 x i8] c"int64_t variable or\00", align 1
@.str.134 = private unnamed_addr constant [29 x i8] c"int64_t multiple variable or\00", align 1
@.str.135 = private unnamed_addr constant [21 x i8] c"int64_t variable xor\00", align 1
@.str.136 = private unnamed_addr constant [30 x i8] c"int64_t multiple variable xor\00", align 1
@.str.137 = private unnamed_addr constant [22 x i8] c"uint64_t variable add\00", align 1
@.str.138 = private unnamed_addr constant [30 x i8] c"uint64_t variable add hoisted\00", align 1
@.str.139 = private unnamed_addr constant [32 x i8] c"uint64_t multiple variable adds\00", align 1
@.str.140 = private unnamed_addr constant [27 x i8] c"uint64_t variable subtract\00", align 1
@.str.141 = private unnamed_addr constant [37 x i8] c"uint64_t multiple variable subtracts\00", align 1
@.str.142 = private unnamed_addr constant [27 x i8] c"uint64_t variable multiply\00", align 1
@.str.143 = private unnamed_addr constant [38 x i8] c"uint64_t multiple variable multiplies\00", align 1
@.str.144 = private unnamed_addr constant [39 x i8] c"uint64_t multiple variable multiplies2\00", align 1
@.str.145 = private unnamed_addr constant [25 x i8] c"uint64_t variable divide\00", align 1
@.str.146 = private unnamed_addr constant [35 x i8] c"uint64_t multiple variable divides\00", align 1
@.str.147 = private unnamed_addr constant [36 x i8] c"uint64_t multiple variable divides2\00", align 1
@.str.148 = private unnamed_addr constant [33 x i8] c"uint64_t multiple variable mixed\00", align 1
@.str.149 = private unnamed_addr constant [22 x i8] c"uint64_t variable and\00", align 1
@.str.150 = private unnamed_addr constant [31 x i8] c"uint64_t multiple variable and\00", align 1
@.str.151 = private unnamed_addr constant [21 x i8] c"uint64_t variable or\00", align 1
@.str.152 = private unnamed_addr constant [30 x i8] c"uint64_t multiple variable or\00", align 1
@.str.153 = private unnamed_addr constant [22 x i8] c"uint64_t variable xor\00", align 1
@.str.154 = private unnamed_addr constant [31 x i8] c"uint64_t multiple variable xor\00", align 1
@.str.155 = private unnamed_addr constant [19 x i8] c"float variable add\00", align 1
@.str.156 = private unnamed_addr constant [27 x i8] c"float variable add hoisted\00", align 1
@.str.157 = private unnamed_addr constant [29 x i8] c"float multiple variable adds\00", align 1
@.str.158 = private unnamed_addr constant [24 x i8] c"float variable subtract\00", align 1
@.str.159 = private unnamed_addr constant [34 x i8] c"float multiple variable subtracts\00", align 1
@.str.160 = private unnamed_addr constant [24 x i8] c"float variable multiply\00", align 1
@.str.161 = private unnamed_addr constant [35 x i8] c"float multiple variable multiplies\00", align 1
@.str.162 = private unnamed_addr constant [36 x i8] c"float multiple variable multiplies2\00", align 1
@.str.163 = private unnamed_addr constant [22 x i8] c"float variable divide\00", align 1
@.str.164 = private unnamed_addr constant [32 x i8] c"float multiple variable divides\00", align 1
@.str.165 = private unnamed_addr constant [33 x i8] c"float multiple variable divides2\00", align 1
@.str.166 = private unnamed_addr constant [30 x i8] c"float multiple variable mixed\00", align 1
@.str.167 = private unnamed_addr constant [20 x i8] c"double variable add\00", align 1
@.str.168 = private unnamed_addr constant [28 x i8] c"double variable add hoisted\00", align 1
@.str.169 = private unnamed_addr constant [30 x i8] c"double multiple variable adds\00", align 1
@.str.170 = private unnamed_addr constant [25 x i8] c"double variable subtract\00", align 1
@.str.171 = private unnamed_addr constant [35 x i8] c"double multiple variable subtracts\00", align 1
@.str.172 = private unnamed_addr constant [25 x i8] c"double variable multiply\00", align 1
@.str.173 = private unnamed_addr constant [36 x i8] c"double multiple variable multiplies\00", align 1
@.str.174 = private unnamed_addr constant [37 x i8] c"double multiple variable multiplies2\00", align 1
@.str.175 = private unnamed_addr constant [23 x i8] c"double variable divide\00", align 1
@.str.176 = private unnamed_addr constant [33 x i8] c"double multiple variable divides\00", align 1
@.str.177 = private unnamed_addr constant [34 x i8] c"double multiple variable divides2\00", align 1
@.str.178 = private unnamed_addr constant [31 x i8] c"double multiple variable mixed\00", align 1
@.str.179 = private unnamed_addr constant [16 x i8] c"test %i failed\0A\00", align 1

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_Z13record_resultdPKc(double noundef %0, ptr noundef %1) local_unnamed_addr #0 {
  %3 = load ptr, ptr @results, align 8, !tbaa !6
  %4 = icmp ne ptr %3, null
  %5 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %6 = load i32, ptr @current_test, align 4
  %7 = icmp slt i32 %6, %5
  %8 = select i1 %4, i1 %7, i1 false
  br i1 %8, label %20, label %9

9:                                                ; preds = %2
  %10 = add nsw i32 %5, 10
  store i32 %10, ptr @allocated_results, align 4, !tbaa !11
  %11 = sext i32 %10 to i64
  %12 = shl nsw i64 %11, 4
  %13 = tail call ptr @realloc(ptr noundef %3, i64 noundef %12) #14
  store ptr %13, ptr @results, align 8, !tbaa !6
  %14 = icmp eq ptr %13, null
  br i1 %14, label %17, label %15

15:                                               ; preds = %9
  %16 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %20

17:                                               ; preds = %9
  %18 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %19 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %18)
  tail call void @exit(i32 noundef -1) #15
  unreachable

20:                                               ; preds = %2, %15
  %21 = phi i32 [ %16, %15 ], [ %6, %2 ]
  %22 = phi ptr [ %13, %15 ], [ %3, %2 ]
  %23 = sext i32 %21 to i64
  %24 = getelementptr inbounds %struct.one_result, ptr %22, i64 %23
  store double %0, ptr %24, align 8, !tbaa !13
  %25 = getelementptr inbounds %struct.one_result, ptr %22, i64 %23, i32 1
  store ptr %1, ptr %25, align 8, !tbaa !17
  %26 = add nsw i32 %21, 1
  store i32 %26, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite)
declare noalias noundef ptr @realloc(ptr allocptr noundef captures(none), i64 noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr noundef readonly captures(none), ...) local_unnamed_addr #2

; Function Attrs: nofree noreturn nounwind
declare void @exit(i32 noundef) local_unnamed_addr #3

; Function Attrs: mustprogress nofree nounwind uwtable
define dso_local void @_Z9summarizePKciiii(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) local_unnamed_addr #4 {
  %6 = sitofp i32 %1 to double
  %7 = sitofp i32 %2 to double
  %8 = fmul double %6, %7
  %9 = fdiv double %8, 1.000000e+06
  %10 = load i32, ptr @current_test, align 4, !tbaa !11
  %11 = icmp sgt i32 %10, 0
  br i1 %11, label %12, label %25

12:                                               ; preds = %5
  %13 = load ptr, ptr @results, align 8, !tbaa !6
  %14 = zext nneg i32 %10 to i64
  br label %15

15:                                               ; preds = %12, %15
  %16 = phi i64 [ 0, %12 ], [ %23, %15 ]
  %17 = phi i32 [ 12, %12 ], [ %22, %15 ]
  %18 = getelementptr inbounds nuw %struct.one_result, ptr %13, i64 %16, i32 1
  %19 = load ptr, ptr %18, align 8, !tbaa !17
  %20 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %19) #16
  %21 = trunc i64 %20 to i32
  %22 = tail call i32 @llvm.smax.i32(i32 %17, i32 %21)
  %23 = add nuw nsw i64 %16, 1
  %24 = icmp eq i64 %23, %14
  br i1 %24, label %25, label %15, !llvm.loop !18

25:                                               ; preds = %15, %5
  %26 = phi i32 [ 12, %5 ], [ %22, %15 ]
  %27 = add nsw i32 %26, -12
  %28 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i32 noundef %27, ptr noundef nonnull @.str.2)
  %29 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.3, i32 noundef %26, ptr noundef nonnull @.str.2)
  %30 = load i32, ptr @current_test, align 4, !tbaa !11
  %31 = icmp sgt i32 %30, 0
  br i1 %31, label %57, label %84

32:                                               ; preds = %57
  %33 = icmp sgt i32 %73, 0
  br i1 %33, label %34, label %84

34:                                               ; preds = %32
  %35 = load ptr, ptr @results, align 8, !tbaa !6
  %36 = zext nneg i32 %73 to i64
  %37 = icmp eq i32 %73, 1
  br i1 %37, label %54, label %38

38:                                               ; preds = %34
  %39 = and i64 %36, 2147483646
  br label %40

40:                                               ; preds = %40, %38
  %41 = phi i64 [ 0, %38 ], [ %50, %40 ]
  %42 = phi double [ 0.000000e+00, %38 ], [ %49, %40 ]
  %43 = getelementptr inbounds nuw %struct.one_result, ptr %35, i64 %41
  %44 = getelementptr inbounds nuw %struct.one_result, ptr %35, i64 %41
  %45 = getelementptr inbounds nuw i8, ptr %44, i64 16
  %46 = load double, ptr %43, align 8, !tbaa !13
  %47 = load double, ptr %45, align 8, !tbaa !13
  %48 = fadd double %42, %46
  %49 = fadd double %48, %47
  %50 = add nuw i64 %41, 2
  %51 = icmp eq i64 %50, %39
  br i1 %51, label %52, label %40, !llvm.loop !20

52:                                               ; preds = %40
  %53 = icmp eq i64 %39, %36
  br i1 %53, label %84, label %54

54:                                               ; preds = %34, %52
  %55 = phi i64 [ 0, %34 ], [ %39, %52 ]
  %56 = phi double [ 0.000000e+00, %34 ], [ %49, %52 ]
  br label %76

57:                                               ; preds = %25, %57
  %58 = phi i64 [ %72, %57 ], [ 0, %25 ]
  %59 = load ptr, ptr @results, align 8, !tbaa !6
  %60 = getelementptr inbounds nuw %struct.one_result, ptr %59, i64 %58
  %61 = getelementptr inbounds nuw i8, ptr %60, i64 8
  %62 = load ptr, ptr %61, align 8, !tbaa !17
  %63 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %62) #16
  %64 = trunc i64 %63 to i32
  %65 = sub i32 %26, %64
  %66 = load double, ptr %60, align 8, !tbaa !13
  %67 = fdiv double %9, %66
  %68 = load double, ptr %59, align 8, !tbaa !13
  %69 = fdiv double %66, %68
  %70 = trunc nuw nsw i64 %58 to i32
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.4, i32 noundef %70, i32 noundef %65, ptr noundef nonnull @.str.5, ptr noundef nonnull %62, double noundef %66, double noundef %67, double noundef %69)
  %72 = add nuw nsw i64 %58, 1
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = sext i32 %73 to i64
  %75 = icmp slt i64 %72, %74
  br i1 %75, label %57, label %32, !llvm.loop !23

76:                                               ; preds = %54, %76
  %77 = phi i64 [ %82, %76 ], [ %55, %54 ]
  %78 = phi double [ %81, %76 ], [ %56, %54 ]
  %79 = getelementptr inbounds nuw %struct.one_result, ptr %35, i64 %77
  %80 = load double, ptr %79, align 8, !tbaa !13
  %81 = fadd double %78, %80
  %82 = add nuw nsw i64 %77, 1
  %83 = icmp eq i64 %82, %36
  br i1 %83, label %84, label %76, !llvm.loop !24

84:                                               ; preds = %76, %52, %25, %32
  %85 = phi double [ 0.000000e+00, %32 ], [ 0.000000e+00, %25 ], [ %49, %52 ], [ %81, %76 ]
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.6, ptr noundef %0, double noundef %85)
  %87 = load i32, ptr @current_test, align 4, !tbaa !11
  %88 = icmp sgt i32 %87, 1
  %89 = icmp ne i32 %4, 0
  %90 = and i1 %89, %88
  br i1 %90, label %91, label %112

91:                                               ; preds = %84
  %92 = load ptr, ptr @results, align 8, !tbaa !6
  %93 = load double, ptr %92, align 8, !tbaa !13
  br label %94

94:                                               ; preds = %91, %94
  %95 = phi i64 [ 1, %91 ], [ %102, %94 ]
  %96 = phi double [ 0.000000e+00, %91 ], [ %101, %94 ]
  %97 = getelementptr inbounds nuw %struct.one_result, ptr %92, i64 %95
  %98 = load double, ptr %97, align 8, !tbaa !13
  %99 = fdiv double %98, %93
  %100 = tail call double @log(double noundef %99) #17, !tbaa !11
  %101 = fadd double %96, %100
  %102 = add nuw nsw i64 %95, 1
  %103 = load i32, ptr @current_test, align 4, !tbaa !11
  %104 = sext i32 %103 to i64
  %105 = icmp slt i64 %102, %104
  br i1 %105, label %94, label %106, !llvm.loop !25

106:                                              ; preds = %94
  %107 = add nsw i32 %103, -1
  %108 = sitofp i32 %107 to double
  %109 = fdiv double %101, %108
  %110 = tail call double @exp(double noundef %109) #17, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.7, ptr noundef %0, double noundef %110)
  br label %112

112:                                              ; preds = %106, %84
  store i32 0, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr noundef captures(none)) local_unnamed_addr #5

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(errnomem: write)
declare double @log(double noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(errnomem: write)
declare double @exp(double noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nofree nounwind uwtable
define dso_local void @_Z17summarize_simplefP8_IO_FILEPKc(ptr noundef captures(none) %0, ptr noundef %1) local_unnamed_addr #4 {
  %3 = load i32, ptr @current_test, align 4, !tbaa !11
  %4 = icmp sgt i32 %3, 0
  br i1 %4, label %5, label %18

5:                                                ; preds = %2
  %6 = load ptr, ptr @results, align 8, !tbaa !6
  %7 = zext nneg i32 %3 to i64
  br label %8

8:                                                ; preds = %5, %8
  %9 = phi i64 [ 0, %5 ], [ %16, %8 ]
  %10 = phi i32 [ 12, %5 ], [ %15, %8 ]
  %11 = getelementptr inbounds nuw %struct.one_result, ptr %6, i64 %9, i32 1
  %12 = load ptr, ptr %11, align 8, !tbaa !17
  %13 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %12) #16
  %14 = trunc i64 %13 to i32
  %15 = tail call i32 @llvm.smax.i32(i32 %10, i32 %14)
  %16 = add nuw nsw i64 %9, 1
  %17 = icmp eq i64 %16, %7
  br i1 %17, label %18, label %8, !llvm.loop !26

18:                                               ; preds = %8, %2
  %19 = phi i32 [ 12, %2 ], [ %15, %8 ]
  %20 = add nsw i32 %19, -12
  %21 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.8, i32 noundef %20, ptr noundef nonnull @.str.2) #17
  %22 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.9, i32 noundef %19, ptr noundef nonnull @.str.2) #17
  %23 = load i32, ptr @current_test, align 4, !tbaa !11
  %24 = icmp sgt i32 %23, 0
  br i1 %24, label %50, label %74

25:                                               ; preds = %50
  %26 = icmp sgt i32 %63, 0
  br i1 %26, label %27, label %74

27:                                               ; preds = %25
  %28 = load ptr, ptr @results, align 8, !tbaa !6
  %29 = zext nneg i32 %63 to i64
  %30 = icmp eq i32 %63, 1
  br i1 %30, label %47, label %31

31:                                               ; preds = %27
  %32 = and i64 %29, 2147483646
  br label %33

33:                                               ; preds = %33, %31
  %34 = phi i64 [ 0, %31 ], [ %43, %33 ]
  %35 = phi double [ 0.000000e+00, %31 ], [ %42, %33 ]
  %36 = getelementptr inbounds nuw %struct.one_result, ptr %28, i64 %34
  %37 = getelementptr inbounds nuw %struct.one_result, ptr %28, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load double, ptr %36, align 8, !tbaa !13
  %40 = load double, ptr %38, align 8, !tbaa !13
  %41 = fadd double %35, %39
  %42 = fadd double %41, %40
  %43 = add nuw i64 %34, 2
  %44 = icmp eq i64 %43, %32
  br i1 %44, label %45, label %33, !llvm.loop !27

45:                                               ; preds = %33
  %46 = icmp eq i64 %32, %29
  br i1 %46, label %74, label %47

47:                                               ; preds = %27, %45
  %48 = phi i64 [ 0, %27 ], [ %32, %45 ]
  %49 = phi double [ 0.000000e+00, %27 ], [ %42, %45 ]
  br label %66

50:                                               ; preds = %18, %50
  %51 = phi i64 [ %62, %50 ], [ 0, %18 ]
  %52 = load ptr, ptr @results, align 8, !tbaa !6
  %53 = getelementptr inbounds nuw %struct.one_result, ptr %52, i64 %51
  %54 = getelementptr inbounds nuw i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8, !tbaa !17
  %56 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %55) #16
  %57 = trunc i64 %56 to i32
  %58 = sub i32 %19, %57
  %59 = load double, ptr %53, align 8, !tbaa !13
  %60 = trunc nuw nsw i64 %51 to i32
  %61 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.10, i32 noundef %60, i32 noundef %58, ptr noundef nonnull @.str.5, ptr noundef nonnull %55, double noundef %59) #17
  %62 = add nuw nsw i64 %51, 1
  %63 = load i32, ptr @current_test, align 4, !tbaa !11
  %64 = sext i32 %63 to i64
  %65 = icmp slt i64 %62, %64
  br i1 %65, label %50, label %25, !llvm.loop !28

66:                                               ; preds = %47, %66
  %67 = phi i64 [ %72, %66 ], [ %48, %47 ]
  %68 = phi double [ %71, %66 ], [ %49, %47 ]
  %69 = getelementptr inbounds nuw %struct.one_result, ptr %28, i64 %67
  %70 = load double, ptr %69, align 8, !tbaa !13
  %71 = fadd double %68, %70
  %72 = add nuw nsw i64 %67, 1
  %73 = icmp eq i64 %72, %29
  br i1 %73, label %74, label %66, !llvm.loop !29

74:                                               ; preds = %66, %45, %18, %25
  %75 = phi double [ 0.000000e+00, %25 ], [ 0.000000e+00, %18 ], [ %42, %45 ], [ %71, %66 ]
  %76 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.6, ptr noundef %1, double noundef %75) #17
  store i32 0, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @fprintf(ptr noundef captures(none), ptr noundef readonly captures(none), ...) local_unnamed_addr #2

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_Z11start_timerv() local_unnamed_addr #0 {
  %1 = tail call i64 @clock() #17
  store i64 %1, ptr @start_time, align 8, !tbaa !30
  ret void
}

; Function Attrs: nounwind
declare i64 @clock() local_unnamed_addr #7

; Function Attrs: mustprogress nounwind uwtable
define dso_local noundef double @_Z5timerv() local_unnamed_addr #0 {
  %1 = tail call i64 @clock() #17
  store i64 %1, ptr @end_time, align 8, !tbaa !30
  %2 = load i64, ptr @start_time, align 8, !tbaa !30
  %3 = sub nsw i64 %1, %2
  %4 = sitofp i64 %3 to double
  %5 = fdiv double %4, 1.000000e+06
  ret double %5
}

; Function Attrs: mustprogress norecurse uwtable
define dso_local noundef i32 @main(i32 noundef %0, ptr noundef readonly captures(none) %1) local_unnamed_addr #8 {
  %3 = icmp sgt i32 %0, 1
  br i1 %3, label %4, label %19

4:                                                ; preds = %2
  %5 = getelementptr inbounds nuw i8, ptr %1, i64 8
  %6 = load ptr, ptr %5, align 8, !tbaa !32
  %7 = tail call i64 @__isoc23_strtol(ptr noundef nonnull %6, ptr noundef null, i32 noundef 10) #17
  %8 = trunc i64 %7 to i32
  store i32 %8, ptr @iterations, align 4, !tbaa !11
  %9 = icmp eq i32 %0, 2
  br i1 %9, label %19, label %10

10:                                               ; preds = %4
  %11 = getelementptr inbounds nuw i8, ptr %1, i64 16
  %12 = load ptr, ptr %11, align 8, !tbaa !32
  %13 = tail call double @strtod(ptr noundef nonnull captures(none) %12, ptr noundef null) #17
  store double %13, ptr @init_value, align 8, !tbaa !33
  %14 = icmp samesign ugt i32 %0, 3
  br i1 %14, label %15, label %19

15:                                               ; preds = %10
  %16 = getelementptr inbounds nuw i8, ptr %1, i64 24
  %17 = load ptr, ptr %16, align 8, !tbaa !32
  %18 = tail call double @strtod(ptr noundef nonnull captures(none) %17, ptr noundef null) #17
  br label %19

19:                                               ; preds = %2, %4, %15, %10
  %20 = phi double [ %18, %15 ], [ 1.000000e+00, %10 ], [ 1.000000e+00, %4 ], [ 1.000000e+00, %2 ]
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  %22 = fptosi double %21 to i8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(8000) @data8, i8 %22, i64 8000, i1 false), !tbaa !34
  %23 = fptosi double %20 to i8
  %24 = shl i8 %23, 1
  %25 = add i8 %23, 2
  %26 = sext i8 %24 to i16
  %27 = sext i8 %25 to i16
  %28 = sdiv i16 %26, %27
  %29 = trunc i16 %28 to i8
  %30 = add i8 %29, %23
  tail call void @_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.11)
  tail call void @_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.12)
  tail call void @_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.13)
  tail call void @_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.14)
  tail call void @_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.15)
  tail call void @_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.16)
  tail call void @_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.17)
  tail call void @_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.18)
  tail call void @_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.19)
  tail call void @_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.20)
  tail call void @_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.21)
  tail call void @_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.22)
  tail call void @_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.23)
  tail call void @_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.24)
  tail call void @_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.25)
  tail call void @_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.26)
  tail call void @_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, ptr noundef nonnull @.str.27)
  tail call void @_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef %23, i8 noundef %24, i8 noundef %25, i8 noundef %30, ptr noundef nonnull @.str.28)
  %31 = load double, ptr @init_value, align 8, !tbaa !33
  %32 = fptoui double %31 to i8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(8000) @data8unsigned, i8 %32, i64 8000, i1 false), !tbaa !34
  %33 = fptoui double %20 to i8
  %34 = shl i8 %33, 1
  %35 = add i8 %33, 2
  %36 = udiv i8 %34, %35
  %37 = add i8 %36, %33
  tail call void @_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.29)
  tail call void @_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.30)
  tail call void @_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.31)
  tail call void @_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.32)
  tail call void @_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.33)
  tail call void @_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.34)
  tail call void @_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.35)
  tail call void @_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.36)
  tail call void @_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.37)
  tail call void @_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.38)
  tail call void @_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.39)
  tail call void @_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.40)
  tail call void @_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.41)
  tail call void @_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.42)
  tail call void @_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.43)
  tail call void @_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.44)
  tail call void @_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, ptr noundef nonnull @.str.45)
  tail call void @_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef %33, i8 noundef %34, i8 noundef %35, i8 noundef %37, ptr noundef nonnull @.str.46)
  %38 = load double, ptr @init_value, align 8, !tbaa !33
  %39 = fptosi double %38 to i16
  %40 = insertelement <8 x i16> poison, i16 %39, i64 0
  %41 = shufflevector <8 x i16> %40, <8 x i16> poison, <8 x i32> zeroinitializer
  br label %42

42:                                               ; preds = %42, %19
  %43 = phi i64 [ 0, %19 ], [ %47, %42 ]
  %44 = shl i64 %43, 1
  %45 = getelementptr inbounds nuw i8, ptr @data16, i64 %44
  %46 = getelementptr inbounds nuw i8, ptr %45, i64 16
  store <8 x i16> %41, ptr %45, align 2, !tbaa !35
  store <8 x i16> %41, ptr %46, align 2, !tbaa !35
  %47 = add nuw i64 %43, 16
  %48 = icmp eq i64 %47, 8000
  br i1 %48, label %49, label %42, !llvm.loop !37

49:                                               ; preds = %42
  %50 = fptosi double %20 to i16
  %51 = shl i16 %50, 1
  %52 = add i16 %50, 2
  %53 = sext i16 %51 to i32
  %54 = sext i16 %52 to i32
  %55 = sdiv i32 %53, %54
  %56 = trunc i32 %55 to i16
  %57 = add i16 %56, %50
  tail call void @_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.47)
  tail call void @_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.48)
  tail call void @_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.49)
  tail call void @_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.50)
  tail call void @_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.51)
  tail call void @_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.52)
  tail call void @_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.53)
  tail call void @_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.54)
  tail call void @_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.55)
  tail call void @_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.56)
  tail call void @_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.57)
  tail call void @_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.58)
  tail call void @_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.59)
  tail call void @_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.60)
  tail call void @_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.61)
  tail call void @_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.62)
  tail call void @_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, ptr noundef nonnull @.str.63)
  tail call void @_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef %50, i16 noundef %51, i16 noundef %52, i16 noundef %57, ptr noundef nonnull @.str.64)
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptoui double %58 to i16
  %60 = insertelement <8 x i16> poison, i16 %59, i64 0
  %61 = shufflevector <8 x i16> %60, <8 x i16> poison, <8 x i32> zeroinitializer
  br label %62

62:                                               ; preds = %62, %49
  %63 = phi i64 [ 0, %49 ], [ %67, %62 ]
  %64 = shl i64 %63, 1
  %65 = getelementptr inbounds nuw i8, ptr @data16unsigned, i64 %64
  %66 = getelementptr inbounds nuw i8, ptr %65, i64 16
  store <8 x i16> %61, ptr %65, align 2, !tbaa !35
  store <8 x i16> %61, ptr %66, align 2, !tbaa !35
  %67 = add nuw i64 %63, 16
  %68 = icmp eq i64 %67, 8000
  br i1 %68, label %69, label %62, !llvm.loop !38

69:                                               ; preds = %62
  %70 = fptoui double %20 to i16
  %71 = shl i16 %70, 1
  %72 = add i16 %70, 2
  %73 = udiv i16 %71, %72
  %74 = add i16 %73, %70
  tail call void @_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.65)
  tail call void @_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.66)
  tail call void @_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.67)
  tail call void @_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.68)
  tail call void @_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.69)
  tail call void @_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.70)
  tail call void @_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.71)
  tail call void @_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.72)
  tail call void @_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.73)
  tail call void @_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.74)
  tail call void @_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.75)
  tail call void @_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.76)
  tail call void @_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.77)
  tail call void @_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.78)
  tail call void @_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.79)
  tail call void @_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.80)
  tail call void @_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, ptr noundef nonnull @.str.81)
  tail call void @_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef %70, i16 noundef %71, i16 noundef %72, i16 noundef %74, ptr noundef nonnull @.str.82)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = fptosi double %75 to i32
  %77 = insertelement <4 x i32> poison, i32 %76, i64 0
  %78 = shufflevector <4 x i32> %77, <4 x i32> poison, <4 x i32> zeroinitializer
  br label %79

79:                                               ; preds = %79, %69
  %80 = phi i64 [ 0, %69 ], [ %84, %79 ]
  %81 = shl i64 %80, 2
  %82 = getelementptr inbounds nuw i8, ptr @data32, i64 %81
  %83 = getelementptr inbounds nuw i8, ptr %82, i64 16
  store <4 x i32> %78, ptr %82, align 4, !tbaa !11
  store <4 x i32> %78, ptr %83, align 4, !tbaa !11
  %84 = add nuw i64 %80, 8
  %85 = icmp eq i64 %84, 8000
  br i1 %85, label %86, label %79, !llvm.loop !39

86:                                               ; preds = %79
  %87 = fptosi double %20 to i32
  %88 = shl nsw i32 %87, 1
  %89 = add nsw i32 %87, 2
  %90 = sdiv i32 %88, %89
  %91 = add nsw i32 %90, %87
  tail call void @_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.83)
  tail call void @_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.84)
  tail call void @_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.85)
  tail call void @_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.86)
  tail call void @_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.87)
  tail call void @_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.88)
  tail call void @_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.89)
  tail call void @_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.90)
  tail call void @_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.91)
  tail call void @_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.92)
  tail call void @_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.93)
  tail call void @_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.94)
  tail call void @_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.95)
  tail call void @_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.96)
  tail call void @_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.97)
  tail call void @_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.98)
  tail call void @_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, ptr noundef nonnull @.str.99)
  tail call void @_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %87, i32 noundef %88, i32 noundef %89, i32 noundef %91, ptr noundef nonnull @.str.100)
  %92 = load double, ptr @init_value, align 8, !tbaa !33
  %93 = fptoui double %92 to i32
  %94 = insertelement <4 x i32> poison, i32 %93, i64 0
  %95 = shufflevector <4 x i32> %94, <4 x i32> poison, <4 x i32> zeroinitializer
  br label %96

96:                                               ; preds = %96, %86
  %97 = phi i64 [ 0, %86 ], [ %101, %96 ]
  %98 = shl i64 %97, 2
  %99 = getelementptr inbounds nuw i8, ptr @data32unsigned, i64 %98
  %100 = getelementptr inbounds nuw i8, ptr %99, i64 16
  store <4 x i32> %95, ptr %99, align 4, !tbaa !11
  store <4 x i32> %95, ptr %100, align 4, !tbaa !11
  %101 = add nuw i64 %97, 8
  %102 = icmp eq i64 %101, 8000
  br i1 %102, label %103, label %96, !llvm.loop !40

103:                                              ; preds = %96
  %104 = fptoui double %20 to i32
  %105 = shl i32 %104, 1
  %106 = add i32 %104, 2
  %107 = udiv i32 %105, %106
  %108 = add i32 %107, %104
  tail call void @_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.101)
  tail call void @_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.102)
  tail call void @_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.103)
  tail call void @_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.104)
  tail call void @_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.105)
  tail call void @_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.106)
  tail call void @_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.107)
  tail call void @_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.108)
  tail call void @_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.109)
  tail call void @_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.110)
  tail call void @_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.111)
  tail call void @_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.112)
  tail call void @_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.113)
  tail call void @_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.114)
  tail call void @_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.115)
  tail call void @_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.116)
  tail call void @_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, ptr noundef nonnull @.str.117)
  tail call void @_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef %108, ptr noundef nonnull @.str.118)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptosi double %109 to i64
  %111 = insertelement <2 x i64> poison, i64 %110, i64 0
  %112 = shufflevector <2 x i64> %111, <2 x i64> poison, <2 x i32> zeroinitializer
  br label %113

113:                                              ; preds = %113, %103
  %114 = phi i64 [ 0, %103 ], [ %118, %113 ]
  %115 = shl i64 %114, 3
  %116 = getelementptr inbounds nuw i8, ptr @data64, i64 %115
  %117 = getelementptr inbounds nuw i8, ptr %116, i64 16
  store <2 x i64> %112, ptr %116, align 8, !tbaa !30
  store <2 x i64> %112, ptr %117, align 8, !tbaa !30
  %118 = add nuw i64 %114, 4
  %119 = icmp eq i64 %118, 8000
  br i1 %119, label %120, label %113, !llvm.loop !41

120:                                              ; preds = %113
  %121 = fptosi double %20 to i64
  %122 = shl nsw i64 %121, 1
  %123 = add nsw i64 %121, 2
  %124 = sdiv i64 %122, %123
  %125 = add nsw i64 %124, %121
  tail call void @_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.119)
  tail call void @_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.120)
  tail call void @_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.121)
  tail call void @_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.122)
  tail call void @_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.123)
  tail call void @_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.124)
  tail call void @_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.125)
  tail call void @_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.126)
  tail call void @_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.127)
  tail call void @_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.128)
  tail call void @_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.129)
  tail call void @_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.130)
  tail call void @_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.131)
  tail call void @_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.132)
  tail call void @_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.133)
  tail call void @_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.134)
  tail call void @_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, ptr noundef nonnull @.str.135)
  tail call void @_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %121, i64 noundef %122, i64 noundef %123, i64 noundef %125, ptr noundef nonnull @.str.136)
  %126 = load double, ptr @init_value, align 8, !tbaa !33
  %127 = fptoui double %126 to i64
  %128 = insertelement <2 x i64> poison, i64 %127, i64 0
  %129 = shufflevector <2 x i64> %128, <2 x i64> poison, <2 x i32> zeroinitializer
  br label %130

130:                                              ; preds = %130, %120
  %131 = phi i64 [ 0, %120 ], [ %135, %130 ]
  %132 = shl i64 %131, 3
  %133 = getelementptr inbounds nuw i8, ptr @data64unsigned, i64 %132
  %134 = getelementptr inbounds nuw i8, ptr %133, i64 16
  store <2 x i64> %129, ptr %133, align 8, !tbaa !30
  store <2 x i64> %129, ptr %134, align 8, !tbaa !30
  %135 = add nuw i64 %131, 4
  %136 = icmp eq i64 %135, 8000
  br i1 %136, label %137, label %130, !llvm.loop !42

137:                                              ; preds = %130
  %138 = fptoui double %20 to i64
  %139 = shl i64 %138, 1
  %140 = add i64 %138, 2
  %141 = udiv i64 %139, %140
  %142 = add i64 %141, %138
  tail call void @_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.137)
  tail call void @_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.138)
  tail call void @_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.139)
  tail call void @_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.140)
  tail call void @_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.141)
  tail call void @_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.142)
  tail call void @_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.143)
  tail call void @_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.144)
  tail call void @_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.145)
  tail call void @_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.146)
  tail call void @_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.147)
  tail call void @_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.148)
  tail call void @_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.149)
  tail call void @_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.150)
  tail call void @_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.151)
  tail call void @_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.152)
  tail call void @_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, ptr noundef nonnull @.str.153)
  tail call void @_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %138, i64 noundef %139, i64 noundef %140, i64 noundef %142, ptr noundef nonnull @.str.154)
  %143 = load double, ptr @init_value, align 8, !tbaa !33
  %144 = fptrunc double %143 to float
  %145 = insertelement <4 x float> poison, float %144, i64 0
  %146 = shufflevector <4 x float> %145, <4 x float> poison, <4 x i32> zeroinitializer
  br label %147

147:                                              ; preds = %147, %137
  %148 = phi i64 [ 0, %137 ], [ %152, %147 ]
  %149 = shl i64 %148, 2
  %150 = getelementptr inbounds nuw i8, ptr @dataFloat, i64 %149
  %151 = getelementptr inbounds nuw i8, ptr %150, i64 16
  store <4 x float> %146, ptr %150, align 4, !tbaa !43
  store <4 x float> %146, ptr %151, align 4, !tbaa !43
  %152 = add nuw i64 %148, 8
  %153 = icmp eq i64 %152, 8000
  br i1 %153, label %154, label %147, !llvm.loop !45

154:                                              ; preds = %147
  %155 = fptrunc double %20 to float
  %156 = fmul float %155, 2.000000e+00
  %157 = fadd float %155, 2.000000e+00
  %158 = fdiv float %156, %157
  %159 = fadd float %158, %155
  tail call void @_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, ptr noundef nonnull @.str.155)
  tail call void @_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, ptr noundef nonnull @.str.156)
  tail call void @_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.157)
  tail call void @_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, ptr noundef nonnull @.str.158)
  tail call void @_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.159)
  tail call void @_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, ptr noundef nonnull @.str.160)
  tail call void @_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.161)
  tail call void @_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.162)
  tail call void @_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, ptr noundef nonnull @.str.163)
  tail call void @_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.164)
  tail call void @_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.165)
  tail call void @_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %155, float noundef %156, float noundef %157, float noundef %159, ptr noundef nonnull @.str.166)
  %160 = load <1 x double>, ptr @init_value, align 8
  %161 = shufflevector <1 x double> %160, <1 x double> poison, <2 x i32> zeroinitializer
  br label %162

162:                                              ; preds = %162, %154
  %163 = phi i64 [ 0, %154 ], [ %167, %162 ]
  %164 = shl i64 %163, 3
  %165 = getelementptr inbounds nuw i8, ptr @dataDouble, i64 %164
  %166 = getelementptr inbounds nuw i8, ptr %165, i64 16
  store <2 x double> %161, ptr %165, align 8, !tbaa !33
  store <2 x double> %161, ptr %166, align 8, !tbaa !33
  %167 = add nuw i64 %163, 4
  %168 = icmp eq i64 %167, 8000
  br i1 %168, label %169, label %162, !llvm.loop !46

169:                                              ; preds = %162
  %170 = fmul double %20, 2.000000e+00
  %171 = fadd double %20, 2.000000e+00
  %172 = fdiv double %170, %171
  %173 = fadd double %20, %172
  tail call void @_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.167)
  tail call void @_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.168)
  tail call void @_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.169)
  tail call void @_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.170)
  tail call void @_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.171)
  tail call void @_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.172)
  tail call void @_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.173)
  tail call void @_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.174)
  tail call void @_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.175)
  tail call void @_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.176)
  tail call void @_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.177)
  tail call void @_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %170, double noundef %171, double noundef %173, ptr noundef nonnull @.str.178)
  ret i32 0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = add <16 x i8> %35, %18
  %42 = add <16 x i8> %36, %18
  %43 = add <16 x i8> %41, %39
  %44 = add <16 x i8> %42, %40
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !47

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = add <8 x i8> %57, %24
  %61 = add <8 x i8> %60, %59
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !48

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !49

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = add i8 %76, %2
  %80 = add i8 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !50

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i8
  %87 = add i8 %2, %86
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i8
  %95 = add i8 %2, %94
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !49

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %103

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i8
  %11 = mul i8 %2, %10
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !33
  br label %85

14:                                               ; preds = %8
  %15 = zext nneg i32 %1 to i64
  %16 = icmp ult i32 %1, 8
  %17 = icmp ult i32 %1, 32
  %18 = and i64 %15, 2147483616
  %19 = icmp eq i64 %18, %15
  %20 = and i64 %15, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %15, 2147483640
  %23 = icmp eq i64 %22, %15
  br label %24

24:                                               ; preds = %14, %65
  %25 = phi i32 [ %66, %65 ], [ %6, %14 ]
  %26 = phi i32 [ %67, %65 ], [ 0, %14 ]
  br i1 %16, label %27, label %30

27:                                               ; preds = %46, %59, %24
  %28 = phi i64 [ 0, %24 ], [ %18, %46 ], [ %22, %59 ]
  %29 = phi i8 [ 0, %24 ], [ %45, %46 ], [ %60, %59 ]
  br label %69

30:                                               ; preds = %24
  br i1 %17, label %47, label %31

31:                                               ; preds = %30, %31
  %32 = phi i64 [ %41, %31 ], [ 0, %30 ]
  %33 = phi <16 x i8> [ %39, %31 ], [ zeroinitializer, %30 ]
  %34 = phi <16 x i8> [ %40, %31 ], [ zeroinitializer, %30 ]
  %35 = getelementptr inbounds nuw i8, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <16 x i8>, ptr %35, align 1, !tbaa !34
  %38 = load <16 x i8>, ptr %36, align 1, !tbaa !34
  %39 = add <16 x i8> %37, %33
  %40 = add <16 x i8> %38, %34
  %41 = add nuw i64 %32, 32
  %42 = icmp eq i64 %41, %18
  br i1 %42, label %43, label %31, !llvm.loop !51

43:                                               ; preds = %31
  %44 = add <16 x i8> %40, %39
  %45 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %44)
  br i1 %19, label %77, label %46

46:                                               ; preds = %43
  br i1 %21, label %27, label %47

47:                                               ; preds = %46, %30
  %48 = phi i64 [ %18, %46 ], [ 0, %30 ]
  %49 = phi i8 [ %45, %46 ], [ 0, %30 ]
  %50 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %49, i64 0
  br label %51

51:                                               ; preds = %51, %47
  %52 = phi i64 [ %48, %47 ], [ %57, %51 ]
  %53 = phi <8 x i8> [ %50, %47 ], [ %56, %51 ]
  %54 = getelementptr inbounds nuw i8, ptr %0, i64 %52
  %55 = load <8 x i8>, ptr %54, align 1, !tbaa !34
  %56 = add <8 x i8> %55, %53
  %57 = add nuw i64 %52, 8
  %58 = icmp eq i64 %57, %22
  br i1 %58, label %59, label %51, !llvm.loop !52

59:                                               ; preds = %51
  %60 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %56)
  br i1 %23, label %77, label %27

61:                                               ; preds = %77
  %62 = load i32, ptr @current_test, align 4, !tbaa !11
  %63 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %62)
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %65

65:                                               ; preds = %61, %77
  %66 = phi i32 [ %64, %61 ], [ %25, %77 ]
  %67 = add nuw nsw i32 %26, 1
  %68 = icmp slt i32 %67, %66
  br i1 %68, label %24, label %103, !llvm.loop !53

69:                                               ; preds = %27, %69
  %70 = phi i64 [ %75, %69 ], [ %28, %27 ]
  %71 = phi i8 [ %74, %69 ], [ %29, %27 ]
  %72 = getelementptr inbounds nuw i8, ptr %0, i64 %70
  %73 = load i8, ptr %72, align 1, !tbaa !34
  %74 = add i8 %73, %71
  %75 = add nuw nsw i64 %70, 1
  %76 = icmp eq i64 %75, %15
  br i1 %76, label %77, label %69, !llvm.loop !54

77:                                               ; preds = %69, %59, %43
  %78 = phi i8 [ %45, %43 ], [ %60, %59 ], [ %74, %69 ]
  %79 = add i8 %78, %11
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = fptosi double %80 to i8
  %82 = add i8 %2, %81
  %83 = shl i8 %82, 6
  %84 = icmp eq i8 %79, %83
  br i1 %84, label %65, label %61

85:                                               ; preds = %12, %98
  %86 = phi i32 [ %99, %98 ], [ %6, %12 ]
  %87 = phi double [ %100, %98 ], [ %13, %12 ]
  %88 = phi i32 [ %101, %98 ], [ 0, %12 ]
  %89 = fptosi double %87 to i8
  %90 = add i8 %2, %89
  %91 = shl i8 %90, 6
  %92 = icmp eq i8 %11, %91
  br i1 %92, label %98, label %93

93:                                               ; preds = %85
  %94 = load i32, ptr @current_test, align 4, !tbaa !11
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %98

98:                                               ; preds = %85, %93
  %99 = phi i32 [ %86, %85 ], [ %97, %93 ]
  %100 = phi double [ %87, %85 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %88, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %85, label %103, !llvm.loop !53

103:                                              ; preds = %98, %65, %4
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !30
  %105 = load i64, ptr @start_time, align 8, !tbaa !30
  %106 = load ptr, ptr @results, align 8, !tbaa !6
  %107 = icmp ne ptr %106, null
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = load i32, ptr @current_test, align 4
  %110 = icmp slt i32 %109, %108
  %111 = select i1 %107, i1 %110, i1 false
  br i1 %111, label %123, label %112

112:                                              ; preds = %103
  %113 = add nsw i32 %108, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !11
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %106, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !6
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %112
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %123

120:                                              ; preds = %112
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %103, %118
  %124 = phi i32 [ %119, %118 ], [ %109, %103 ]
  %125 = phi ptr [ %116, %118 ], [ %106, %103 ]
  %126 = sub nsw i64 %104, %105
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !13
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %3, ptr %131, align 8, !tbaa !17
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i8 %3, %2
  %15 = add i8 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 24
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483640
  %29 = insertelement <8 x i8> poison, i8 %15, i64 0
  %30 = shufflevector <8 x i8> %29, <8 x i8> poison, <8 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i8 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <16 x i8> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <16 x i8> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i8, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <16 x i8>, ptr %43, align 1, !tbaa !34
  %46 = load <16 x i8>, ptr %44, align 1, !tbaa !34
  %47 = add <16 x i8> %24, %41
  %48 = add <16 x i8> %24, %42
  %49 = add <16 x i8> %47, %45
  %50 = add <16 x i8> %48, %46
  %51 = add nuw i64 %40, 32
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !55

53:                                               ; preds = %39
  %54 = add <16 x i8> %50, %49
  %55 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i8 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <8 x i8> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i8, ptr %0, i64 %62
  %65 = load <8 x i8>, ptr %64, align 1, !tbaa !34
  %66 = add <8 x i8> %30, %63
  %67 = add <8 x i8> %66, %65
  %68 = add nuw i64 %62, 8
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !56

70:                                               ; preds = %61
  %71 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !57

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i8 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load i8, ptr %83, align 1, !tbaa !34
  %85 = add i8 %15, %82
  %86 = add i8 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !58

89:                                               ; preds = %80, %70, %53
  %90 = phi i8 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptosi double %91 to i8
  %93 = add i8 %15, %92
  %94 = shl i8 %93, 6
  %95 = icmp eq i8 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptosi double %98 to i8
  %101 = add i8 %15, %100
  %102 = and i8 %101, 3
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !57

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = sub <16 x i8> %35, %18
  %42 = sub <16 x i8> %36, %18
  %43 = add <16 x i8> %41, %39
  %44 = add <16 x i8> %42, %40
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !59

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = sub <8 x i8> %57, %24
  %61 = add <8 x i8> %60, %59
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !60

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !61

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = sub i8 %76, %2
  %80 = add i8 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !62

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i8
  %87 = sub i8 %86, %2
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i8
  %95 = sub i8 %94, %2
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !61

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i8 %3, %2
  %15 = add i8 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 24
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483640
  %29 = insertelement <8 x i8> poison, i8 %15, i64 0
  %30 = shufflevector <8 x i8> %29, <8 x i8> poison, <8 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i8 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <16 x i8> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <16 x i8> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i8, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <16 x i8>, ptr %43, align 1, !tbaa !34
  %46 = load <16 x i8>, ptr %44, align 1, !tbaa !34
  %47 = sub <16 x i8> %41, %24
  %48 = sub <16 x i8> %42, %24
  %49 = add <16 x i8> %47, %45
  %50 = add <16 x i8> %48, %46
  %51 = add nuw i64 %40, 32
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !63

53:                                               ; preds = %39
  %54 = add <16 x i8> %50, %49
  %55 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i8 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <8 x i8> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i8, ptr %0, i64 %62
  %65 = load <8 x i8>, ptr %64, align 1, !tbaa !34
  %66 = sub <8 x i8> %63, %30
  %67 = add <8 x i8> %66, %65
  %68 = add nuw i64 %62, 8
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !64

70:                                               ; preds = %61
  %71 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !65

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i8 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load i8, ptr %83, align 1, !tbaa !34
  %85 = sub i8 %82, %15
  %86 = add i8 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !66

89:                                               ; preds = %80, %70, %53
  %90 = phi i8 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptosi double %91 to i8
  %93 = sub i8 %92, %15
  %94 = shl i8 %93, 6
  %95 = icmp eq i8 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptosi double %98 to i8
  %101 = sub i8 %100, %15
  %102 = and i8 %101, 3
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !65

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %107

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = shl i8 %2, 6
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = icmp ult i32 %1, 32
  %17 = and i64 %14, 2147483616
  %18 = insertelement <16 x i8> poison, i8 %2, i64 0
  %19 = shufflevector <16 x i8> %18, <16 x i8> poison, <16 x i32> zeroinitializer
  %20 = icmp eq i64 %17, %14
  %21 = and i64 %14, 24
  %22 = icmp eq i64 %21, 0
  %23 = and i64 %14, 2147483640
  %24 = insertelement <8 x i8> poison, i8 %2, i64 0
  %25 = shufflevector <8 x i8> %24, <8 x i8> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %23, %14
  br label %27

27:                                               ; preds = %13, %71
  %28 = phi i32 [ %72, %71 ], [ %6, %13 ]
  %29 = phi i32 [ %73, %71 ], [ 0, %13 ]
  br i1 %15, label %30, label %33

30:                                               ; preds = %51, %65, %27
  %31 = phi i64 [ 0, %27 ], [ %17, %51 ], [ %23, %65 ]
  %32 = phi i8 [ 0, %27 ], [ %50, %51 ], [ %66, %65 ]
  br label %75

33:                                               ; preds = %27
  br i1 %16, label %52, label %34

34:                                               ; preds = %33, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %33 ]
  %36 = phi <16 x i8> [ %44, %34 ], [ zeroinitializer, %33 ]
  %37 = phi <16 x i8> [ %45, %34 ], [ zeroinitializer, %33 ]
  %38 = getelementptr inbounds nuw i8, ptr %0, i64 %35
  %39 = getelementptr inbounds nuw i8, ptr %38, i64 16
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = load <16 x i8>, ptr %39, align 1, !tbaa !34
  %42 = mul <16 x i8> %40, %19
  %43 = mul <16 x i8> %41, %19
  %44 = add <16 x i8> %42, %36
  %45 = add <16 x i8> %43, %37
  %46 = add nuw i64 %35, 32
  %47 = icmp eq i64 %46, %17
  br i1 %47, label %48, label %34, !llvm.loop !67

48:                                               ; preds = %34
  %49 = add <16 x i8> %45, %44
  %50 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %49)
  br i1 %20, label %84, label %51

51:                                               ; preds = %48
  br i1 %22, label %30, label %52

52:                                               ; preds = %51, %33
  %53 = phi i64 [ %17, %51 ], [ 0, %33 ]
  %54 = phi i8 [ %50, %51 ], [ 0, %33 ]
  %55 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %54, i64 0
  br label %56

56:                                               ; preds = %56, %52
  %57 = phi i64 [ %53, %52 ], [ %63, %56 ]
  %58 = phi <8 x i8> [ %55, %52 ], [ %62, %56 ]
  %59 = getelementptr inbounds nuw i8, ptr %0, i64 %57
  %60 = load <8 x i8>, ptr %59, align 1, !tbaa !34
  %61 = mul <8 x i8> %60, %25
  %62 = add <8 x i8> %61, %58
  %63 = add nuw i64 %57, 8
  %64 = icmp eq i64 %63, %23
  br i1 %64, label %65, label %56, !llvm.loop !68

65:                                               ; preds = %56
  %66 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %62)
  br i1 %26, label %84, label %30

67:                                               ; preds = %84
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %68)
  %70 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %71

71:                                               ; preds = %67, %84
  %72 = phi i32 [ %70, %67 ], [ %28, %84 ]
  %73 = add nuw nsw i32 %29, 1
  %74 = icmp slt i32 %73, %72
  br i1 %74, label %27, label %107, !llvm.loop !69

75:                                               ; preds = %30, %75
  %76 = phi i64 [ %82, %75 ], [ %31, %30 ]
  %77 = phi i8 [ %81, %75 ], [ %32, %30 ]
  %78 = getelementptr inbounds nuw i8, ptr %0, i64 %76
  %79 = load i8, ptr %78, align 1, !tbaa !34
  %80 = mul i8 %79, %2
  %81 = add i8 %80, %77
  %82 = add nuw nsw i64 %76, 1
  %83 = icmp eq i64 %82, %14
  br i1 %83, label %84, label %75, !llvm.loop !70

84:                                               ; preds = %75, %65, %48
  %85 = phi i8 [ %50, %48 ], [ %66, %65 ], [ %81, %75 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = fptosi double %86 to i8
  %88 = mul i8 %10, %87
  %89 = icmp eq i8 %85, %88
  br i1 %89, label %71, label %67

90:                                               ; preds = %11, %102
  %91 = phi i32 [ %103, %102 ], [ %6, %11 ]
  %92 = phi double [ %104, %102 ], [ %12, %11 ]
  %93 = phi i32 [ %105, %102 ], [ 0, %11 ]
  %94 = fptosi double %92 to i8
  %95 = mul i8 %10, %94
  %96 = icmp eq i8 %95, 0
  br i1 %96, label %102, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %98)
  %100 = load double, ptr @init_value, align 8, !tbaa !33
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %90, %97
  %103 = phi i32 [ %91, %90 ], [ %101, %97 ]
  %104 = phi double [ %92, %90 ], [ %100, %97 ]
  %105 = add nuw nsw i32 %93, 1
  %106 = icmp slt i32 %105, %103
  br i1 %106, label %90, label %107, !llvm.loop !69

107:                                              ; preds = %102, %71, %4
  %108 = tail call i64 @clock() #17
  store i64 %108, ptr @end_time, align 8, !tbaa !30
  %109 = load i64, ptr @start_time, align 8, !tbaa !30
  %110 = load ptr, ptr @results, align 8, !tbaa !6
  %111 = icmp ne ptr %110, null
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = load i32, ptr @current_test, align 4
  %114 = icmp slt i32 %113, %112
  %115 = select i1 %111, i1 %114, i1 false
  br i1 %115, label %127, label %116

116:                                              ; preds = %107
  %117 = add nsw i32 %112, 10
  store i32 %117, ptr @allocated_results, align 4, !tbaa !11
  %118 = sext i32 %117 to i64
  %119 = shl nsw i64 %118, 4
  %120 = tail call ptr @realloc(ptr noundef %110, i64 noundef %119) #14
  store ptr %120, ptr @results, align 8, !tbaa !6
  %121 = icmp eq ptr %120, null
  br i1 %121, label %124, label %122

122:                                              ; preds = %116
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %127

124:                                              ; preds = %116
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %126 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %125)
  tail call void @exit(i32 noundef -1) #15
  unreachable

127:                                              ; preds = %107, %122
  %128 = phi i32 [ %123, %122 ], [ %113, %107 ]
  %129 = phi ptr [ %120, %122 ], [ %110, %107 ]
  %130 = sub nsw i64 %108, %109
  %131 = sitofp i64 %130 to double
  %132 = fdiv double %131, 1.000000e+06
  %133 = sext i32 %128 to i64
  %134 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133
  store double %132, ptr %134, align 8, !tbaa !13
  %135 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133, i32 1
  store ptr %3, ptr %135, align 8, !tbaa !17
  %136 = add nsw i32 %128, 1
  store i32 %136, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = shl i8 %4, 6
  %13 = mul i8 %12, %2
  %14 = mul i8 %13, %5
  %15 = mul i8 %4, %5
  %16 = mul i8 %15, %3
  %17 = mul i8 %16, %2
  %18 = icmp sgt i32 %1, 0
  %19 = mul i8 %14, %3
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = icmp ult i32 %1, 32
  %26 = and i64 %23, 2147483616
  %27 = insertelement <16 x i8> poison, i8 %17, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 24
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483640
  %33 = insertelement <8 x i8> poison, i8 %17, i64 0
  %34 = shufflevector <8 x i8> %33, <8 x i8> poison, <8 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %22, %80
  %37 = phi i32 [ %81, %80 ], [ %9, %22 ]
  %38 = phi i32 [ %82, %80 ], [ 0, %22 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i8 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <16 x i8> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <16 x i8> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i8, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <16 x i8>, ptr %47, align 1, !tbaa !34
  %50 = load <16 x i8>, ptr %48, align 1, !tbaa !34
  %51 = mul <16 x i8> %28, %49
  %52 = mul <16 x i8> %28, %50
  %53 = add <16 x i8> %51, %45
  %54 = add <16 x i8> %52, %46
  %55 = add nuw i64 %44, 32
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !71

57:                                               ; preds = %43
  %58 = add <16 x i8> %54, %53
  %59 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i8 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <8 x i8> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i8, ptr %0, i64 %66
  %69 = load <8 x i8>, ptr %68, align 1, !tbaa !34
  %70 = mul <8 x i8> %34, %69
  %71 = add <8 x i8> %70, %67
  %72 = add nuw i64 %66, 8
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !72

74:                                               ; preds = %65
  %75 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %116, !llvm.loop !73

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i8 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i8, ptr %0, i64 %85
  %88 = load i8, ptr %87, align 1, !tbaa !34
  %89 = mul i8 %17, %88
  %90 = add i8 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !74

93:                                               ; preds = %84, %74, %57
  %94 = phi i8 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptosi double %95 to i8
  %97 = mul i8 %19, %96
  %98 = icmp eq i8 %94, %97
  br i1 %98, label %80, label %76

99:                                               ; preds = %20, %111
  %100 = phi i32 [ %112, %111 ], [ %9, %20 ]
  %101 = phi double [ %113, %111 ], [ %21, %20 ]
  %102 = phi i32 [ %114, %111 ], [ 0, %20 ]
  %103 = fptosi double %101 to i8
  %104 = mul i8 %19, %103
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %99
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %99, %106
  %112 = phi i32 [ %100, %99 ], [ %110, %106 ]
  %113 = phi double [ %101, %99 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %102, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %99, label %116, !llvm.loop !73

116:                                              ; preds = %111, %80, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %117

11:                                               ; preds = %7
  %12 = mul i8 %3, %4
  %13 = mul i8 %12, %5
  %14 = mul i8 %3, %5
  %15 = mul i8 %14, %2
  %16 = mul i8 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i8 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = icmp ult i32 %1, 32
  %25 = and i64 %22, 2147483616
  %26 = insertelement <16 x i8> poison, i8 %16, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %22
  %29 = and i64 %22, 24
  %30 = icmp eq i64 %29, 0
  %31 = and i64 %22, 2147483640
  %32 = insertelement <8 x i8> poison, i8 %16, i64 0
  %33 = shufflevector <8 x i8> %32, <8 x i8> poison, <8 x i32> zeroinitializer
  %34 = icmp eq i64 %31, %22
  br label %35

35:                                               ; preds = %21, %79
  %36 = phi i32 [ %80, %79 ], [ %9, %21 ]
  %37 = phi i32 [ %81, %79 ], [ 0, %21 ]
  br i1 %23, label %38, label %41

38:                                               ; preds = %59, %73, %35
  %39 = phi i64 [ 0, %35 ], [ %25, %59 ], [ %31, %73 ]
  %40 = phi i8 [ 0, %35 ], [ %58, %59 ], [ %74, %73 ]
  br label %83

41:                                               ; preds = %35
  br i1 %24, label %60, label %42

42:                                               ; preds = %41, %42
  %43 = phi i64 [ %54, %42 ], [ 0, %41 ]
  %44 = phi <16 x i8> [ %52, %42 ], [ zeroinitializer, %41 ]
  %45 = phi <16 x i8> [ %53, %42 ], [ zeroinitializer, %41 ]
  %46 = getelementptr inbounds nuw i8, ptr %0, i64 %43
  %47 = getelementptr inbounds nuw i8, ptr %46, i64 16
  %48 = load <16 x i8>, ptr %46, align 1, !tbaa !34
  %49 = load <16 x i8>, ptr %47, align 1, !tbaa !34
  %50 = add <16 x i8> %44, %27
  %51 = add <16 x i8> %45, %27
  %52 = add <16 x i8> %50, %48
  %53 = add <16 x i8> %51, %49
  %54 = add nuw i64 %43, 32
  %55 = icmp eq i64 %54, %25
  br i1 %55, label %56, label %42, !llvm.loop !75

56:                                               ; preds = %42
  %57 = add <16 x i8> %53, %52
  %58 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %57)
  br i1 %28, label %92, label %59

59:                                               ; preds = %56
  br i1 %30, label %38, label %60

60:                                               ; preds = %59, %41
  %61 = phi i64 [ %25, %59 ], [ 0, %41 ]
  %62 = phi i8 [ %58, %59 ], [ 0, %41 ]
  %63 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %62, i64 0
  br label %64

64:                                               ; preds = %64, %60
  %65 = phi i64 [ %61, %60 ], [ %71, %64 ]
  %66 = phi <8 x i8> [ %63, %60 ], [ %70, %64 ]
  %67 = getelementptr inbounds nuw i8, ptr %0, i64 %65
  %68 = load <8 x i8>, ptr %67, align 1, !tbaa !34
  %69 = add <8 x i8> %66, %33
  %70 = add <8 x i8> %69, %68
  %71 = add nuw i64 %65, 8
  %72 = icmp eq i64 %71, %31
  br i1 %72, label %73, label %64, !llvm.loop !76

73:                                               ; preds = %64
  %74 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %70)
  br i1 %34, label %92, label %38

75:                                               ; preds = %92
  %76 = load i32, ptr @current_test, align 4, !tbaa !11
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %75, %92
  %80 = phi i32 [ %78, %75 ], [ %36, %92 ]
  %81 = add nuw nsw i32 %37, 1
  %82 = icmp slt i32 %81, %80
  br i1 %82, label %35, label %117, !llvm.loop !77

83:                                               ; preds = %38, %83
  %84 = phi i64 [ %90, %83 ], [ %39, %38 ]
  %85 = phi i8 [ %89, %83 ], [ %40, %38 ]
  %86 = getelementptr inbounds nuw i8, ptr %0, i64 %84
  %87 = load i8, ptr %86, align 1, !tbaa !34
  %88 = add i8 %85, %16
  %89 = add i8 %88, %87
  %90 = add nuw nsw i64 %84, 1
  %91 = icmp eq i64 %90, %22
  br i1 %91, label %92, label %83, !llvm.loop !78

92:                                               ; preds = %83, %73, %56
  %93 = phi i8 [ %58, %56 ], [ %74, %73 ], [ %89, %83 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !33
  %95 = fptosi double %94 to i8
  %96 = add i8 %18, %95
  %97 = shl i8 %96, 6
  %98 = icmp eq i8 %93, %97
  br i1 %98, label %79, label %75

99:                                               ; preds = %19, %112
  %100 = phi i32 [ %113, %112 ], [ %9, %19 ]
  %101 = phi double [ %114, %112 ], [ %20, %19 ]
  %102 = phi i32 [ %115, %112 ], [ 0, %19 ]
  %103 = fptosi double %101 to i8
  %104 = add i8 %18, %103
  %105 = and i8 %104, 3
  %106 = icmp eq i8 %105, 0
  br i1 %106, label %112, label %107

107:                                              ; preds = %99
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %108)
  %110 = load double, ptr @init_value, align 8, !tbaa !33
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %99, %107
  %113 = phi i32 [ %100, %99 ], [ %111, %107 ]
  %114 = phi double [ %101, %99 ], [ %110, %107 ]
  %115 = add nuw nsw i32 %102, 1
  %116 = icmp slt i32 %115, %113
  br i1 %116, label %99, label %117, !llvm.loop !77

117:                                              ; preds = %112, %79, %7
  %118 = tail call i64 @clock() #17
  store i64 %118, ptr @end_time, align 8, !tbaa !30
  %119 = load i64, ptr @start_time, align 8, !tbaa !30
  %120 = load ptr, ptr @results, align 8, !tbaa !6
  %121 = icmp ne ptr %120, null
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = load i32, ptr @current_test, align 4
  %124 = icmp slt i32 %123, %122
  %125 = select i1 %121, i1 %124, i1 false
  br i1 %125, label %137, label %126

126:                                              ; preds = %117
  %127 = add nsw i32 %122, 10
  store i32 %127, ptr @allocated_results, align 4, !tbaa !11
  %128 = sext i32 %127 to i64
  %129 = shl nsw i64 %128, 4
  %130 = tail call ptr @realloc(ptr noundef %120, i64 noundef %129) #14
  store ptr %130, ptr @results, align 8, !tbaa !6
  %131 = icmp eq ptr %130, null
  br i1 %131, label %134, label %132

132:                                              ; preds = %126
  %133 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %137

134:                                              ; preds = %126
  %135 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %136 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %135)
  tail call void @exit(i32 noundef -1) #15
  unreachable

137:                                              ; preds = %117, %132
  %138 = phi i32 [ %133, %132 ], [ %123, %117 ]
  %139 = phi ptr [ %130, %132 ], [ %120, %117 ]
  %140 = sub nsw i64 %118, %119
  %141 = sitofp i64 %140 to double
  %142 = fdiv double %141, 1.000000e+06
  %143 = sext i32 %138 to i64
  %144 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143
  store double %142, ptr %144, align 8, !tbaa !13
  %145 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143, i32 1
  store ptr %6, ptr %145, align 8, !tbaa !17
  %146 = add nsw i32 %138, 1
  store i32 %146, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %92

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i8 %2 to i16
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %73

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %14, 2147483646
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %49
  %19 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %20 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %38, %21 ], [ 0, %18 ]
  %23 = phi i8 [ %36, %21 ], [ 0, %18 ]
  %24 = phi i8 [ %37, %21 ], [ 0, %18 ]
  %25 = getelementptr inbounds nuw i8, ptr %0, i64 %22
  %26 = getelementptr inbounds nuw i8, ptr %0, i64 %22
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 1
  %28 = load i8, ptr %25, align 1, !tbaa !34
  %29 = load i8, ptr %27, align 1, !tbaa !34
  %30 = sext i8 %28 to i16
  %31 = sext i8 %29 to i16
  %32 = sdiv i16 %30, %10
  %33 = sdiv i16 %31, %10
  %34 = trunc i16 %32 to i8
  %35 = trunc i16 %33 to i8
  %36 = add i8 %23, %34
  %37 = add i8 %24, %35
  %38 = add nuw i64 %22, 2
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %21, !llvm.loop !79

40:                                               ; preds = %21
  %41 = add i8 %37, %36
  br i1 %17, label %64, label %42

42:                                               ; preds = %18, %40
  %43 = phi i64 [ 0, %18 ], [ %16, %40 ]
  %44 = phi i8 [ 0, %18 ], [ %41, %40 ]
  br label %53

45:                                               ; preds = %64
  %46 = load i32, ptr @current_test, align 4, !tbaa !11
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %45, %64
  %50 = phi i32 [ %48, %45 ], [ %19, %64 ]
  %51 = add nuw nsw i32 %20, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %18, label %92, !llvm.loop !80

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %62, %53 ], [ %43, %42 ]
  %55 = phi i8 [ %61, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds nuw i8, ptr %0, i64 %54
  %57 = load i8, ptr %56, align 1, !tbaa !34
  %58 = sext i8 %57 to i16
  %59 = sdiv i16 %58, %10
  %60 = trunc i16 %59 to i8
  %61 = add i8 %55, %60
  %62 = add nuw nsw i64 %54, 1
  %63 = icmp eq i64 %62, %14
  br i1 %63, label %64, label %53, !llvm.loop !81

64:                                               ; preds = %53, %40
  %65 = phi i8 [ %41, %40 ], [ %61, %53 ]
  %66 = load double, ptr @init_value, align 8, !tbaa !33
  %67 = fptosi double %66 to i8
  %68 = sext i8 %67 to i16
  %69 = sdiv i16 %68, %10
  %70 = trunc i16 %69 to i8
  %71 = shl i8 %70, 6
  %72 = icmp eq i8 %65, %71
  br i1 %72, label %49, label %45

73:                                               ; preds = %11, %87
  %74 = phi i32 [ %88, %87 ], [ %6, %11 ]
  %75 = phi double [ %89, %87 ], [ %12, %11 ]
  %76 = phi i32 [ %90, %87 ], [ 0, %11 ]
  %77 = fptosi double %75 to i8
  %78 = sext i8 %77 to i16
  %79 = sdiv i16 %78, %10
  %80 = and i16 %79, 3
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %73
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %73, %82
  %88 = phi i32 [ %74, %73 ], [ %86, %82 ]
  %89 = phi double [ %75, %73 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %76, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %73, label %92, !llvm.loop !80

92:                                               ; preds = %87, %49, %4
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %3, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %113

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i8 %2 to i16
  %14 = sext i8 %3 to i16
  %15 = sext i8 %4 to i16
  %16 = sext i8 %5 to i16
  br i1 %12, label %19, label %17

17:                                               ; preds = %11
  %18 = load double, ptr @init_value, align 8, !tbaa !33
  br label %91

19:                                               ; preds = %11
  %20 = zext nneg i32 %1 to i64
  %21 = icmp eq i32 %1, 1
  %22 = and i64 %20, 2147483646
  %23 = icmp eq i64 %22, %20
  br label %24

24:                                               ; preds = %19, %61
  %25 = phi i32 [ %62, %61 ], [ %9, %19 ]
  %26 = phi i32 [ %63, %61 ], [ 0, %19 ]
  br i1 %21, label %54, label %27

27:                                               ; preds = %24, %27
  %28 = phi i64 [ %50, %27 ], [ 0, %24 ]
  %29 = phi i8 [ %48, %27 ], [ 0, %24 ]
  %30 = phi i8 [ %49, %27 ], [ 0, %24 ]
  %31 = getelementptr inbounds nuw i8, ptr %0, i64 %28
  %32 = getelementptr inbounds nuw i8, ptr %0, i64 %28
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 1
  %34 = load i8, ptr %31, align 1, !tbaa !34
  %35 = load i8, ptr %33, align 1, !tbaa !34
  %36 = sext i8 %34 to i16
  %37 = sext i8 %35 to i16
  %38 = sdiv i16 %36, %13
  %39 = sdiv i16 %37, %13
  %40 = sdiv i16 %38, %14
  %41 = sdiv i16 %39, %14
  %42 = sdiv i16 %40, %15
  %43 = sdiv i16 %41, %15
  %44 = sdiv i16 %42, %16
  %45 = sdiv i16 %43, %16
  %46 = trunc i16 %44 to i8
  %47 = trunc i16 %45 to i8
  %48 = add i8 %29, %46
  %49 = add i8 %30, %47
  %50 = add nuw i64 %28, 2
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %27, !llvm.loop !82

52:                                               ; preds = %27
  %53 = add i8 %49, %48
  br i1 %23, label %79, label %54

54:                                               ; preds = %24, %52
  %55 = phi i64 [ 0, %24 ], [ %22, %52 ]
  %56 = phi i8 [ 0, %24 ], [ %53, %52 ]
  br label %65

57:                                               ; preds = %79
  %58 = load i32, ptr @current_test, align 4, !tbaa !11
  %59 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %58)
  %60 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %61

61:                                               ; preds = %57, %79
  %62 = phi i32 [ %60, %57 ], [ %25, %79 ]
  %63 = add nuw nsw i32 %26, 1
  %64 = icmp slt i32 %63, %62
  br i1 %64, label %24, label %113, !llvm.loop !83

65:                                               ; preds = %54, %65
  %66 = phi i64 [ %77, %65 ], [ %55, %54 ]
  %67 = phi i8 [ %76, %65 ], [ %56, %54 ]
  %68 = getelementptr inbounds nuw i8, ptr %0, i64 %66
  %69 = load i8, ptr %68, align 1, !tbaa !34
  %70 = sext i8 %69 to i16
  %71 = sdiv i16 %70, %13
  %72 = sdiv i16 %71, %14
  %73 = sdiv i16 %72, %15
  %74 = sdiv i16 %73, %16
  %75 = trunc i16 %74 to i8
  %76 = add i8 %67, %75
  %77 = add nuw nsw i64 %66, 1
  %78 = icmp eq i64 %77, %20
  br i1 %78, label %79, label %65, !llvm.loop !84

79:                                               ; preds = %65, %52
  %80 = phi i8 [ %53, %52 ], [ %76, %65 ]
  %81 = load double, ptr @init_value, align 8, !tbaa !33
  %82 = fptosi double %81 to i8
  %83 = sext i8 %82 to i16
  %84 = sdiv i16 %83, %13
  %85 = sdiv i16 %84, %14
  %86 = sdiv i16 %85, %15
  %87 = sdiv i16 %86, %16
  %88 = trunc i16 %87 to i8
  %89 = shl i8 %88, 6
  %90 = icmp eq i8 %80, %89
  br i1 %90, label %61, label %57

91:                                               ; preds = %17, %108
  %92 = phi i32 [ %109, %108 ], [ %9, %17 ]
  %93 = phi double [ %110, %108 ], [ %18, %17 ]
  %94 = phi i32 [ %111, %108 ], [ 0, %17 ]
  %95 = fptosi double %93 to i8
  %96 = sext i8 %95 to i16
  %97 = sdiv i16 %96, %13
  %98 = sdiv i16 %97, %14
  %99 = sdiv i16 %98, %15
  %100 = sdiv i16 %99, %16
  %101 = and i16 %100, 3
  %102 = icmp eq i16 %101, 0
  br i1 %102, label %108, label %103

103:                                              ; preds = %91
  %104 = load i32, ptr @current_test, align 4, !tbaa !11
  %105 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %104)
  %106 = load double, ptr @init_value, align 8, !tbaa !33
  %107 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %108

108:                                              ; preds = %91, %103
  %109 = phi i32 [ %92, %91 ], [ %107, %103 ]
  %110 = phi double [ %93, %91 ], [ %106, %103 ]
  %111 = add nuw nsw i32 %94, 1
  %112 = icmp slt i32 %111, %109
  br i1 %112, label %91, label %113, !llvm.loop !83

113:                                              ; preds = %108, %61, %7
  %114 = tail call i64 @clock() #17
  store i64 %114, ptr @end_time, align 8, !tbaa !30
  %115 = load i64, ptr @start_time, align 8, !tbaa !30
  %116 = load ptr, ptr @results, align 8, !tbaa !6
  %117 = icmp ne ptr %116, null
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %119 = load i32, ptr @current_test, align 4
  %120 = icmp slt i32 %119, %118
  %121 = select i1 %117, i1 %120, i1 false
  br i1 %121, label %133, label %122

122:                                              ; preds = %113
  %123 = add nsw i32 %118, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !11
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %116, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !6
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %122
  %129 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %133

130:                                              ; preds = %122
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %113, %128
  %134 = phi i32 [ %129, %128 ], [ %119, %113 ]
  %135 = phi ptr [ %126, %128 ], [ %116, %113 ]
  %136 = sub nsw i64 %114, %115
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !13
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %6, ptr %141, align 8, !tbaa !17
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %119

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i8 %2 to i16
  %14 = sext i8 %3 to i16
  %15 = sdiv i16 %13, %14
  %16 = sext i8 %4 to i16
  %17 = sdiv i16 %15, %16
  %18 = sext i8 %5 to i16
  %19 = sdiv i16 %17, %18
  %20 = trunc i16 %19 to i8
  br i1 %12, label %23, label %21

21:                                               ; preds = %11
  %22 = load double, ptr @init_value, align 8, !tbaa !33
  br label %101

23:                                               ; preds = %11
  %24 = zext nneg i32 %1 to i64
  %25 = icmp ult i32 %1, 8
  %26 = icmp ult i32 %1, 32
  %27 = and i64 %24, 2147483616
  %28 = insertelement <16 x i8> poison, i8 %20, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = icmp eq i64 %27, %24
  %31 = and i64 %24, 24
  %32 = icmp eq i64 %31, 0
  %33 = and i64 %24, 2147483640
  %34 = insertelement <8 x i8> poison, i8 %20, i64 0
  %35 = shufflevector <8 x i8> %34, <8 x i8> poison, <8 x i32> zeroinitializer
  %36 = icmp eq i64 %33, %24
  br label %37

37:                                               ; preds = %81, %23
  %38 = phi i32 [ %9, %23 ], [ %82, %81 ]
  %39 = phi i32 [ 0, %23 ], [ %83, %81 ]
  br i1 %25, label %40, label %43

40:                                               ; preds = %61, %75, %37
  %41 = phi i64 [ 0, %37 ], [ %27, %61 ], [ %33, %75 ]
  %42 = phi i8 [ 0, %37 ], [ %60, %61 ], [ %76, %75 ]
  br label %85

43:                                               ; preds = %37
  br i1 %26, label %62, label %44

44:                                               ; preds = %43, %44
  %45 = phi i64 [ %56, %44 ], [ 0, %43 ]
  %46 = phi <16 x i8> [ %54, %44 ], [ zeroinitializer, %43 ]
  %47 = phi <16 x i8> [ %55, %44 ], [ zeroinitializer, %43 ]
  %48 = getelementptr inbounds nuw i8, ptr %0, i64 %45
  %49 = getelementptr inbounds nuw i8, ptr %48, i64 16
  %50 = load <16 x i8>, ptr %48, align 1, !tbaa !34
  %51 = load <16 x i8>, ptr %49, align 1, !tbaa !34
  %52 = add <16 x i8> %50, %46
  %53 = add <16 x i8> %51, %47
  %54 = add <16 x i8> %52, %29
  %55 = add <16 x i8> %53, %29
  %56 = add nuw i64 %45, 32
  %57 = icmp eq i64 %56, %27
  br i1 %57, label %58, label %44, !llvm.loop !85

58:                                               ; preds = %44
  %59 = add <16 x i8> %55, %54
  %60 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %59)
  br i1 %30, label %94, label %61

61:                                               ; preds = %58
  br i1 %32, label %40, label %62

62:                                               ; preds = %61, %43
  %63 = phi i64 [ %27, %61 ], [ 0, %43 ]
  %64 = phi i8 [ %60, %61 ], [ 0, %43 ]
  %65 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %64, i64 0
  br label %66

66:                                               ; preds = %66, %62
  %67 = phi i64 [ %63, %62 ], [ %73, %66 ]
  %68 = phi <8 x i8> [ %65, %62 ], [ %72, %66 ]
  %69 = getelementptr inbounds nuw i8, ptr %0, i64 %67
  %70 = load <8 x i8>, ptr %69, align 1, !tbaa !34
  %71 = add <8 x i8> %70, %68
  %72 = add <8 x i8> %71, %35
  %73 = add nuw i64 %67, 8
  %74 = icmp eq i64 %73, %33
  br i1 %74, label %75, label %66, !llvm.loop !86

75:                                               ; preds = %66
  %76 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %72)
  br i1 %36, label %94, label %40

77:                                               ; preds = %94
  %78 = load i32, ptr @current_test, align 4, !tbaa !11
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %81

81:                                               ; preds = %77, %94
  %82 = phi i32 [ %80, %77 ], [ %38, %94 ]
  %83 = add nuw nsw i32 %39, 1
  %84 = icmp slt i32 %83, %82
  br i1 %84, label %37, label %119, !llvm.loop !87

85:                                               ; preds = %40, %85
  %86 = phi i64 [ %92, %85 ], [ %41, %40 ]
  %87 = phi i8 [ %91, %85 ], [ %42, %40 ]
  %88 = getelementptr inbounds nuw i8, ptr %0, i64 %86
  %89 = load i8, ptr %88, align 1, !tbaa !34
  %90 = add i8 %89, %87
  %91 = add i8 %90, %20
  %92 = add nuw nsw i64 %86, 1
  %93 = icmp eq i64 %92, %24
  br i1 %93, label %94, label %85, !llvm.loop !88

94:                                               ; preds = %85, %75, %58
  %95 = phi i8 [ %60, %58 ], [ %76, %75 ], [ %91, %85 ]
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = fptosi double %96 to i8
  %98 = add i8 %20, %97
  %99 = shl i8 %98, 6
  %100 = icmp eq i8 %95, %99
  br i1 %100, label %81, label %77

101:                                              ; preds = %21, %114
  %102 = phi i32 [ %115, %114 ], [ %9, %21 ]
  %103 = phi double [ %116, %114 ], [ %22, %21 ]
  %104 = phi i32 [ %117, %114 ], [ 0, %21 ]
  %105 = fptosi double %103 to i8
  %106 = add i8 %20, %105
  %107 = and i8 %106, 3
  %108 = icmp eq i8 %107, 0
  br i1 %108, label %114, label %109

109:                                              ; preds = %101
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %110)
  %112 = load double, ptr @init_value, align 8, !tbaa !33
  %113 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %114

114:                                              ; preds = %101, %109
  %115 = phi i32 [ %102, %101 ], [ %113, %109 ]
  %116 = phi double [ %103, %101 ], [ %112, %109 ]
  %117 = add nuw nsw i32 %104, 1
  %118 = icmp slt i32 %117, %115
  br i1 %118, label %101, label %119, !llvm.loop !87

119:                                              ; preds = %114, %81, %7
  %120 = tail call i64 @clock() #17
  store i64 %120, ptr @end_time, align 8, !tbaa !30
  %121 = load i64, ptr @start_time, align 8, !tbaa !30
  %122 = load ptr, ptr @results, align 8, !tbaa !6
  %123 = icmp ne ptr %122, null
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %125 = load i32, ptr @current_test, align 4
  %126 = icmp slt i32 %125, %124
  %127 = select i1 %123, i1 %126, i1 false
  br i1 %127, label %139, label %128

128:                                              ; preds = %119
  %129 = add nsw i32 %124, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !11
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %122, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !6
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %128
  %135 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %139

136:                                              ; preds = %128
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %119, %134
  %140 = phi i32 [ %135, %134 ], [ %125, %119 ]
  %141 = phi ptr [ %132, %134 ], [ %122, %119 ]
  %142 = sub nsw i64 %120, %121
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !13
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !17
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %126

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i8 %3 to i16
  %14 = sext i8 %4 to i16
  %15 = mul nsw i16 %14, %13
  %16 = sext i8 %5 to i16
  %17 = sdiv i16 %15, %16
  %18 = trunc i16 %17 to i8
  %19 = sub i8 %2, %18
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %108

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = icmp ult i32 %1, 32
  %26 = and i64 %23, 2147483616
  %27 = insertelement <16 x i8> poison, i8 %2, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = insertelement <16 x i8> poison, i8 %18, i64 0
  %30 = shufflevector <16 x i8> %29, <16 x i8> poison, <16 x i32> zeroinitializer
  %31 = icmp eq i64 %26, %23
  %32 = and i64 %23, 24
  %33 = icmp eq i64 %32, 0
  %34 = and i64 %23, 2147483640
  %35 = insertelement <8 x i8> poison, i8 %2, i64 0
  %36 = shufflevector <8 x i8> %35, <8 x i8> poison, <8 x i32> zeroinitializer
  %37 = insertelement <8 x i8> poison, i8 %18, i64 0
  %38 = shufflevector <8 x i8> %37, <8 x i8> poison, <8 x i32> zeroinitializer
  %39 = icmp eq i64 %34, %23
  br label %40

40:                                               ; preds = %87, %22
  %41 = phi i32 [ %9, %22 ], [ %88, %87 ]
  %42 = phi i32 [ 0, %22 ], [ %89, %87 ]
  br i1 %24, label %43, label %46

43:                                               ; preds = %66, %81, %40
  %44 = phi i64 [ 0, %40 ], [ %26, %66 ], [ %34, %81 ]
  %45 = phi i8 [ 0, %40 ], [ %65, %66 ], [ %82, %81 ]
  br label %91

46:                                               ; preds = %40
  br i1 %25, label %67, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %61, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %59, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %60, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds nuw i8, ptr %0, i64 %48
  %52 = getelementptr inbounds nuw i8, ptr %51, i64 16
  %53 = load <16 x i8>, ptr %51, align 1, !tbaa !34
  %54 = load <16 x i8>, ptr %52, align 1, !tbaa !34
  %55 = add <16 x i8> %49, %28
  %56 = add <16 x i8> %50, %28
  %57 = add <16 x i8> %55, %53
  %58 = add <16 x i8> %56, %54
  %59 = sub <16 x i8> %57, %30
  %60 = sub <16 x i8> %58, %30
  %61 = add nuw i64 %48, 32
  %62 = icmp eq i64 %61, %26
  br i1 %62, label %63, label %47, !llvm.loop !89

63:                                               ; preds = %47
  %64 = add <16 x i8> %60, %59
  %65 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %64)
  br i1 %31, label %101, label %66

66:                                               ; preds = %63
  br i1 %33, label %43, label %67

67:                                               ; preds = %66, %46
  %68 = phi i64 [ %26, %66 ], [ 0, %46 ]
  %69 = phi i8 [ %65, %66 ], [ 0, %46 ]
  %70 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %69, i64 0
  br label %71

71:                                               ; preds = %71, %67
  %72 = phi i64 [ %68, %67 ], [ %79, %71 ]
  %73 = phi <8 x i8> [ %70, %67 ], [ %78, %71 ]
  %74 = getelementptr inbounds nuw i8, ptr %0, i64 %72
  %75 = load <8 x i8>, ptr %74, align 1, !tbaa !34
  %76 = add <8 x i8> %73, %36
  %77 = add <8 x i8> %76, %75
  %78 = sub <8 x i8> %77, %38
  %79 = add nuw i64 %72, 8
  %80 = icmp eq i64 %79, %34
  br i1 %80, label %81, label %71, !llvm.loop !90

81:                                               ; preds = %71
  %82 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %78)
  br i1 %39, label %101, label %43

83:                                               ; preds = %101
  %84 = load i32, ptr @current_test, align 4, !tbaa !11
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %83, %101
  %88 = phi i32 [ %86, %83 ], [ %41, %101 ]
  %89 = add nuw nsw i32 %42, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %40, label %126, !llvm.loop !91

91:                                               ; preds = %43, %91
  %92 = phi i64 [ %99, %91 ], [ %44, %43 ]
  %93 = phi i8 [ %98, %91 ], [ %45, %43 ]
  %94 = getelementptr inbounds nuw i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !34
  %96 = add i8 %93, %2
  %97 = add i8 %96, %95
  %98 = sub i8 %97, %18
  %99 = add nuw nsw i64 %92, 1
  %100 = icmp eq i64 %99, %23
  br i1 %100, label %101, label %91, !llvm.loop !92

101:                                              ; preds = %91, %81, %63
  %102 = phi i8 [ %65, %63 ], [ %82, %81 ], [ %98, %91 ]
  %103 = load double, ptr @init_value, align 8, !tbaa !33
  %104 = fptosi double %103 to i8
  %105 = add i8 %19, %104
  %106 = shl i8 %105, 6
  %107 = icmp eq i8 %102, %106
  br i1 %107, label %87, label %83

108:                                              ; preds = %20, %121
  %109 = phi i32 [ %122, %121 ], [ %9, %20 ]
  %110 = phi double [ %123, %121 ], [ %21, %20 ]
  %111 = phi i32 [ %124, %121 ], [ 0, %20 ]
  %112 = fptosi double %110 to i8
  %113 = add i8 %19, %112
  %114 = and i8 %113, 3
  %115 = icmp eq i8 %114, 0
  br i1 %115, label %121, label %116

116:                                              ; preds = %108
  %117 = load i32, ptr @current_test, align 4, !tbaa !11
  %118 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %117)
  %119 = load double, ptr @init_value, align 8, !tbaa !33
  %120 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %121

121:                                              ; preds = %108, %116
  %122 = phi i32 [ %109, %108 ], [ %120, %116 ]
  %123 = phi double [ %110, %108 ], [ %119, %116 ]
  %124 = add nuw nsw i32 %111, 1
  %125 = icmp slt i32 %124, %122
  br i1 %125, label %108, label %126, !llvm.loop !91

126:                                              ; preds = %121, %87, %7
  %127 = tail call i64 @clock() #17
  store i64 %127, ptr @end_time, align 8, !tbaa !30
  %128 = load i64, ptr @start_time, align 8, !tbaa !30
  %129 = load ptr, ptr @results, align 8, !tbaa !6
  %130 = icmp ne ptr %129, null
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %132 = load i32, ptr @current_test, align 4
  %133 = icmp slt i32 %132, %131
  %134 = select i1 %130, i1 %133, i1 false
  br i1 %134, label %146, label %135

135:                                              ; preds = %126
  %136 = add nsw i32 %131, 10
  store i32 %136, ptr @allocated_results, align 4, !tbaa !11
  %137 = sext i32 %136 to i64
  %138 = shl nsw i64 %137, 4
  %139 = tail call ptr @realloc(ptr noundef %129, i64 noundef %138) #14
  store ptr %139, ptr @results, align 8, !tbaa !6
  %140 = icmp eq ptr %139, null
  br i1 %140, label %143, label %141

141:                                              ; preds = %135
  %142 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %146

143:                                              ; preds = %135
  %144 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %145 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %144)
  tail call void @exit(i32 noundef -1) #15
  unreachable

146:                                              ; preds = %126, %141
  %147 = phi i32 [ %142, %141 ], [ %132, %126 ]
  %148 = phi ptr [ %139, %141 ], [ %129, %126 ]
  %149 = sub nsw i64 %127, %128
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  %152 = sext i32 %147 to i64
  %153 = getelementptr inbounds %struct.one_result, ptr %148, i64 %152
  store double %151, ptr %153, align 8, !tbaa !13
  %154 = getelementptr inbounds %struct.one_result, ptr %148, i64 %152, i32 1
  store ptr %6, ptr %154, align 8, !tbaa !17
  %155 = add nsw i32 %147, 1
  store i32 %155, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %13, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  %12 = and i8 %2, 3
  br label %91

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = icmp ult i32 %1, 32
  %17 = and i64 %14, 2147483616
  %18 = insertelement <16 x i8> poison, i8 %2, i64 0
  %19 = shufflevector <16 x i8> %18, <16 x i8> poison, <16 x i32> zeroinitializer
  %20 = icmp eq i64 %17, %14
  %21 = and i64 %14, 24
  %22 = icmp eq i64 %21, 0
  %23 = and i64 %14, 2147483640
  %24 = insertelement <8 x i8> poison, i8 %2, i64 0
  %25 = shufflevector <8 x i8> %24, <8 x i8> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %23, %14
  br label %27

27:                                               ; preds = %13, %71
  %28 = phi i32 [ %72, %71 ], [ %6, %13 ]
  %29 = phi i32 [ %73, %71 ], [ 0, %13 ]
  br i1 %15, label %30, label %33

30:                                               ; preds = %51, %65, %27
  %31 = phi i64 [ 0, %27 ], [ %17, %51 ], [ %23, %65 ]
  %32 = phi i8 [ 0, %27 ], [ %50, %51 ], [ %66, %65 ]
  br label %75

33:                                               ; preds = %27
  br i1 %16, label %52, label %34

34:                                               ; preds = %33, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %33 ]
  %36 = phi <16 x i8> [ %44, %34 ], [ zeroinitializer, %33 ]
  %37 = phi <16 x i8> [ %45, %34 ], [ zeroinitializer, %33 ]
  %38 = getelementptr inbounds nuw i8, ptr %0, i64 %35
  %39 = getelementptr inbounds nuw i8, ptr %38, i64 16
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = load <16 x i8>, ptr %39, align 1, !tbaa !34
  %42 = and <16 x i8> %40, %19
  %43 = and <16 x i8> %41, %19
  %44 = add <16 x i8> %42, %36
  %45 = add <16 x i8> %43, %37
  %46 = add nuw i64 %35, 32
  %47 = icmp eq i64 %46, %17
  br i1 %47, label %48, label %34, !llvm.loop !93

48:                                               ; preds = %34
  %49 = add <16 x i8> %45, %44
  %50 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %49)
  br i1 %20, label %84, label %51

51:                                               ; preds = %48
  br i1 %22, label %30, label %52

52:                                               ; preds = %51, %33
  %53 = phi i64 [ %17, %51 ], [ 0, %33 ]
  %54 = phi i8 [ %50, %51 ], [ 0, %33 ]
  %55 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %54, i64 0
  br label %56

56:                                               ; preds = %56, %52
  %57 = phi i64 [ %53, %52 ], [ %63, %56 ]
  %58 = phi <8 x i8> [ %55, %52 ], [ %62, %56 ]
  %59 = getelementptr inbounds nuw i8, ptr %0, i64 %57
  %60 = load <8 x i8>, ptr %59, align 1, !tbaa !34
  %61 = and <8 x i8> %60, %25
  %62 = add <8 x i8> %61, %58
  %63 = add nuw i64 %57, 8
  %64 = icmp eq i64 %63, %23
  br i1 %64, label %65, label %56, !llvm.loop !94

65:                                               ; preds = %56
  %66 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %62)
  br i1 %26, label %84, label %30

67:                                               ; preds = %84
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %68)
  %70 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %71

71:                                               ; preds = %67, %84
  %72 = phi i32 [ %70, %67 ], [ %28, %84 ]
  %73 = add nuw nsw i32 %29, 1
  %74 = icmp slt i32 %73, %72
  br i1 %74, label %27, label %108, !llvm.loop !95

75:                                               ; preds = %30, %75
  %76 = phi i64 [ %82, %75 ], [ %31, %30 ]
  %77 = phi i8 [ %81, %75 ], [ %32, %30 ]
  %78 = getelementptr inbounds nuw i8, ptr %0, i64 %76
  %79 = load i8, ptr %78, align 1, !tbaa !34
  %80 = and i8 %79, %2
  %81 = add i8 %80, %77
  %82 = add nuw nsw i64 %76, 1
  %83 = icmp eq i64 %82, %14
  br i1 %83, label %84, label %75, !llvm.loop !96

84:                                               ; preds = %75, %65, %48
  %85 = phi i8 [ %50, %48 ], [ %66, %65 ], [ %81, %75 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = fptosi double %86 to i8
  %88 = and i8 %2, %87
  %89 = shl i8 %88, 6
  %90 = icmp eq i8 %85, %89
  br i1 %90, label %71, label %67

91:                                               ; preds = %10, %103
  %92 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %93 = phi double [ %105, %103 ], [ %11, %10 ]
  %94 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %95 = fptosi double %93 to i8
  %96 = and i8 %12, %95
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %91, %98
  %104 = phi i32 [ %92, %91 ], [ %102, %98 ]
  %105 = phi double [ %93, %91 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %94, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %91, label %108, !llvm.loop !95

108:                                              ; preds = %103, %71, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = and i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i8 %2, %12
  %15 = and i8 %14, %3
  br i1 %13, label %19, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  %18 = and i8 %15, 3
  br label %115

19:                                               ; preds = %11
  %20 = zext nneg i32 %1 to i64
  %21 = icmp ult i32 %1, 8
  %22 = icmp ult i32 %1, 32
  %23 = and i64 %20, 2147483616
  %24 = insertelement <16 x i8> poison, i8 %4, i64 0
  %25 = shufflevector <16 x i8> %24, <16 x i8> poison, <16 x i32> zeroinitializer
  %26 = insertelement <16 x i8> poison, i8 %5, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = insertelement <16 x i8> poison, i8 %2, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = insertelement <16 x i8> poison, i8 %3, i64 0
  %31 = shufflevector <16 x i8> %30, <16 x i8> poison, <16 x i32> zeroinitializer
  %32 = and <16 x i8> %25, %27
  %33 = and <16 x i8> %25, %27
  %34 = and <16 x i8> %32, %29
  %35 = and <16 x i8> %33, %29
  %36 = and <16 x i8> %34, %31
  %37 = and <16 x i8> %35, %31
  %38 = icmp eq i64 %23, %20
  %39 = and i64 %20, 24
  %40 = icmp eq i64 %39, 0
  %41 = and i64 %20, 2147483640
  %42 = and i8 %5, %4
  %43 = and i8 %2, %42
  %44 = and i8 %3, %43
  %45 = insertelement <8 x i8> poison, i8 %44, i64 0
  %46 = shufflevector <8 x i8> %45, <8 x i8> poison, <8 x i32> zeroinitializer
  %47 = icmp eq i64 %41, %20
  %48 = and i8 %4, %5
  %49 = and i8 %48, %2
  %50 = and i8 %49, %3
  br label %51

51:                                               ; preds = %19, %95
  %52 = phi i32 [ %96, %95 ], [ %9, %19 ]
  %53 = phi i32 [ %97, %95 ], [ 0, %19 ]
  br i1 %21, label %54, label %57

54:                                               ; preds = %75, %89, %51
  %55 = phi i64 [ 0, %51 ], [ %23, %75 ], [ %41, %89 ]
  %56 = phi i8 [ 0, %51 ], [ %74, %75 ], [ %90, %89 ]
  br label %99

57:                                               ; preds = %51
  br i1 %22, label %76, label %58

58:                                               ; preds = %57, %58
  %59 = phi i64 [ %70, %58 ], [ 0, %57 ]
  %60 = phi <16 x i8> [ %68, %58 ], [ zeroinitializer, %57 ]
  %61 = phi <16 x i8> [ %69, %58 ], [ zeroinitializer, %57 ]
  %62 = getelementptr inbounds nuw i8, ptr %0, i64 %59
  %63 = getelementptr inbounds nuw i8, ptr %62, i64 16
  %64 = load <16 x i8>, ptr %62, align 1, !tbaa !34
  %65 = load <16 x i8>, ptr %63, align 1, !tbaa !34
  %66 = and <16 x i8> %64, %36
  %67 = and <16 x i8> %65, %37
  %68 = add <16 x i8> %66, %60
  %69 = add <16 x i8> %67, %61
  %70 = add nuw i64 %59, 32
  %71 = icmp eq i64 %70, %23
  br i1 %71, label %72, label %58, !llvm.loop !97

72:                                               ; preds = %58
  %73 = add <16 x i8> %69, %68
  %74 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %73)
  br i1 %38, label %108, label %75

75:                                               ; preds = %72
  br i1 %40, label %54, label %76

76:                                               ; preds = %75, %57
  %77 = phi i64 [ %23, %75 ], [ 0, %57 ]
  %78 = phi i8 [ %74, %75 ], [ 0, %57 ]
  %79 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %78, i64 0
  br label %80

80:                                               ; preds = %80, %76
  %81 = phi i64 [ %77, %76 ], [ %87, %80 ]
  %82 = phi <8 x i8> [ %79, %76 ], [ %86, %80 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load <8 x i8>, ptr %83, align 1, !tbaa !34
  %85 = and <8 x i8> %46, %84
  %86 = add <8 x i8> %85, %82
  %87 = add nuw i64 %81, 8
  %88 = icmp eq i64 %87, %41
  br i1 %88, label %89, label %80, !llvm.loop !98

89:                                               ; preds = %80
  %90 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %86)
  br i1 %47, label %108, label %54

91:                                               ; preds = %108
  %92 = load i32, ptr @current_test, align 4, !tbaa !11
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %95

95:                                               ; preds = %91, %108
  %96 = phi i32 [ %94, %91 ], [ %52, %108 ]
  %97 = add nuw nsw i32 %53, 1
  %98 = icmp slt i32 %97, %96
  br i1 %98, label %51, label %132, !llvm.loop !99

99:                                               ; preds = %54, %99
  %100 = phi i64 [ %106, %99 ], [ %55, %54 ]
  %101 = phi i8 [ %105, %99 ], [ %56, %54 ]
  %102 = getelementptr inbounds nuw i8, ptr %0, i64 %100
  %103 = load i8, ptr %102, align 1, !tbaa !34
  %104 = and i8 %103, %50
  %105 = add i8 %104, %101
  %106 = add nuw nsw i64 %100, 1
  %107 = icmp eq i64 %106, %20
  br i1 %107, label %108, label %99, !llvm.loop !100

108:                                              ; preds = %99, %89, %72
  %109 = phi i8 [ %74, %72 ], [ %90, %89 ], [ %105, %99 ]
  %110 = load double, ptr @init_value, align 8, !tbaa !33
  %111 = fptosi double %110 to i8
  %112 = and i8 %15, %111
  %113 = shl i8 %112, 6
  %114 = icmp eq i8 %109, %113
  br i1 %114, label %95, label %91

115:                                              ; preds = %16, %127
  %116 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %117 = phi double [ %129, %127 ], [ %17, %16 ]
  %118 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %119 = fptosi double %117 to i8
  %120 = and i8 %18, %119
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %115
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %115, %122
  %128 = phi i32 [ %116, %115 ], [ %126, %122 ]
  %129 = phi double [ %117, %115 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %118, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %115, label %132, !llvm.loop !99

132:                                              ; preds = %127, %95, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = or <16 x i8> %39, %18
  %42 = or <16 x i8> %40, %18
  %43 = add <16 x i8> %41, %35
  %44 = add <16 x i8> %42, %36
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !101

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = or <8 x i8> %59, %24
  %61 = add <8 x i8> %60, %57
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !102

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !103

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = or i8 %78, %2
  %80 = add i8 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !104

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i8
  %87 = or i8 %2, %86
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i8
  %95 = or i8 %2, %94
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !103

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = or i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i8 %2, %12
  %15 = or i8 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %4, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %5, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = insertelement <16 x i8> poison, i8 %2, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = insertelement <16 x i8> poison, i8 %3, i64 0
  %30 = shufflevector <16 x i8> %29, <16 x i8> poison, <16 x i32> zeroinitializer
  %31 = or <16 x i8> %24, %26
  %32 = or <16 x i8> %24, %26
  %33 = or <16 x i8> %31, %28
  %34 = or <16 x i8> %32, %28
  %35 = or <16 x i8> %33, %30
  %36 = or <16 x i8> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 24
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483640
  %41 = or i8 %5, %4
  %42 = or i8 %2, %41
  %43 = or i8 %3, %42
  %44 = insertelement <8 x i8> poison, i8 %43, i64 0
  %45 = shufflevector <8 x i8> %44, <8 x i8> poison, <8 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = or i8 %4, %5
  %48 = or i8 %47, %2
  %49 = or i8 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i8 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <16 x i8> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <16 x i8> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i8, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <16 x i8>, ptr %61, align 1, !tbaa !34
  %64 = load <16 x i8>, ptr %62, align 1, !tbaa !34
  %65 = or <16 x i8> %63, %35
  %66 = or <16 x i8> %64, %36
  %67 = add <16 x i8> %65, %59
  %68 = add <16 x i8> %66, %60
  %69 = add nuw i64 %58, 32
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !105

71:                                               ; preds = %57
  %72 = add <16 x i8> %68, %67
  %73 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i8 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <8 x i8> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i8, ptr %0, i64 %80
  %83 = load <8 x i8>, ptr %82, align 1, !tbaa !34
  %84 = or <8 x i8> %45, %83
  %85 = add <8 x i8> %84, %81
  %86 = add nuw i64 %80, 8
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !106

88:                                               ; preds = %79
  %89 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !107

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i8 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i8, ptr %0, i64 %99
  %102 = load i8, ptr %101, align 1, !tbaa !34
  %103 = or i8 %102, %49
  %104 = add i8 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !108

107:                                              ; preds = %98, %88, %71
  %108 = phi i8 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptosi double %109 to i8
  %111 = or i8 %15, %110
  %112 = shl i8 %111, 6
  %113 = icmp eq i8 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptosi double %116 to i8
  %119 = or i8 %15, %118
  %120 = and i8 %119, 3
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !107

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = xor <16 x i8> %39, %18
  %42 = xor <16 x i8> %40, %18
  %43 = add <16 x i8> %41, %35
  %44 = add <16 x i8> %42, %36
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !109

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = xor <8 x i8> %59, %24
  %61 = add <8 x i8> %60, %57
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !110

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !111

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = xor i8 %78, %2
  %80 = add i8 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !112

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i8
  %87 = xor i8 %2, %86
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i8
  %95 = xor i8 %2, %94
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !111

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = xor i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i8 %2, %12
  %15 = xor i8 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %4, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %5, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = insertelement <16 x i8> poison, i8 %2, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = insertelement <16 x i8> poison, i8 %3, i64 0
  %30 = shufflevector <16 x i8> %29, <16 x i8> poison, <16 x i32> zeroinitializer
  %31 = xor <16 x i8> %24, %26
  %32 = xor <16 x i8> %24, %26
  %33 = xor <16 x i8> %31, %28
  %34 = xor <16 x i8> %32, %28
  %35 = xor <16 x i8> %33, %30
  %36 = xor <16 x i8> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 24
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483640
  %41 = xor i8 %5, %4
  %42 = xor i8 %2, %41
  %43 = xor i8 %3, %42
  %44 = insertelement <8 x i8> poison, i8 %43, i64 0
  %45 = shufflevector <8 x i8> %44, <8 x i8> poison, <8 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = xor i8 %4, %5
  %48 = xor i8 %47, %2
  %49 = xor i8 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i8 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <16 x i8> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <16 x i8> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i8, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <16 x i8>, ptr %61, align 1, !tbaa !34
  %64 = load <16 x i8>, ptr %62, align 1, !tbaa !34
  %65 = xor <16 x i8> %63, %35
  %66 = xor <16 x i8> %64, %36
  %67 = add <16 x i8> %65, %59
  %68 = add <16 x i8> %66, %60
  %69 = add nuw i64 %58, 32
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !113

71:                                               ; preds = %57
  %72 = add <16 x i8> %68, %67
  %73 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i8 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <8 x i8> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i8, ptr %0, i64 %80
  %83 = load <8 x i8>, ptr %82, align 1, !tbaa !34
  %84 = xor <8 x i8> %45, %83
  %85 = add <8 x i8> %84, %81
  %86 = add nuw i64 %80, 8
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !114

88:                                               ; preds = %79
  %89 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !115

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i8 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i8, ptr %0, i64 %99
  %102 = load i8, ptr %101, align 1, !tbaa !34
  %103 = xor i8 %102, %49
  %104 = add i8 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !116

107:                                              ; preds = %98, %88, %71
  %108 = phi i8 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptosi double %109 to i8
  %111 = xor i8 %15, %110
  %112 = shl i8 %111, 6
  %113 = icmp eq i8 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptosi double %116 to i8
  %119 = xor i8 %15, %118
  %120 = and i8 %119, 3
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !115

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = add <16 x i8> %35, %18
  %42 = add <16 x i8> %36, %18
  %43 = add <16 x i8> %41, %39
  %44 = add <16 x i8> %42, %40
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !117

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = add <8 x i8> %57, %24
  %61 = add <8 x i8> %60, %59
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !118

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !119

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = add i8 %76, %2
  %80 = add i8 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !120

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i8
  %87 = add i8 %2, %86
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i8
  %95 = add i8 %2, %94
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !119

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %103

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i8
  %11 = mul i8 %2, %10
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !33
  br label %85

14:                                               ; preds = %8
  %15 = zext nneg i32 %1 to i64
  %16 = icmp ult i32 %1, 8
  %17 = icmp ult i32 %1, 32
  %18 = and i64 %15, 2147483616
  %19 = icmp eq i64 %18, %15
  %20 = and i64 %15, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %15, 2147483640
  %23 = icmp eq i64 %22, %15
  br label %24

24:                                               ; preds = %14, %65
  %25 = phi i32 [ %66, %65 ], [ %6, %14 ]
  %26 = phi i32 [ %67, %65 ], [ 0, %14 ]
  br i1 %16, label %27, label %30

27:                                               ; preds = %46, %59, %24
  %28 = phi i64 [ 0, %24 ], [ %18, %46 ], [ %22, %59 ]
  %29 = phi i8 [ 0, %24 ], [ %45, %46 ], [ %60, %59 ]
  br label %69

30:                                               ; preds = %24
  br i1 %17, label %47, label %31

31:                                               ; preds = %30, %31
  %32 = phi i64 [ %41, %31 ], [ 0, %30 ]
  %33 = phi <16 x i8> [ %39, %31 ], [ zeroinitializer, %30 ]
  %34 = phi <16 x i8> [ %40, %31 ], [ zeroinitializer, %30 ]
  %35 = getelementptr inbounds nuw i8, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <16 x i8>, ptr %35, align 1, !tbaa !34
  %38 = load <16 x i8>, ptr %36, align 1, !tbaa !34
  %39 = add <16 x i8> %37, %33
  %40 = add <16 x i8> %38, %34
  %41 = add nuw i64 %32, 32
  %42 = icmp eq i64 %41, %18
  br i1 %42, label %43, label %31, !llvm.loop !121

43:                                               ; preds = %31
  %44 = add <16 x i8> %40, %39
  %45 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %44)
  br i1 %19, label %77, label %46

46:                                               ; preds = %43
  br i1 %21, label %27, label %47

47:                                               ; preds = %46, %30
  %48 = phi i64 [ %18, %46 ], [ 0, %30 ]
  %49 = phi i8 [ %45, %46 ], [ 0, %30 ]
  %50 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %49, i64 0
  br label %51

51:                                               ; preds = %51, %47
  %52 = phi i64 [ %48, %47 ], [ %57, %51 ]
  %53 = phi <8 x i8> [ %50, %47 ], [ %56, %51 ]
  %54 = getelementptr inbounds nuw i8, ptr %0, i64 %52
  %55 = load <8 x i8>, ptr %54, align 1, !tbaa !34
  %56 = add <8 x i8> %55, %53
  %57 = add nuw i64 %52, 8
  %58 = icmp eq i64 %57, %22
  br i1 %58, label %59, label %51, !llvm.loop !122

59:                                               ; preds = %51
  %60 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %56)
  br i1 %23, label %77, label %27

61:                                               ; preds = %77
  %62 = load i32, ptr @current_test, align 4, !tbaa !11
  %63 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %62)
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %65

65:                                               ; preds = %61, %77
  %66 = phi i32 [ %64, %61 ], [ %25, %77 ]
  %67 = add nuw nsw i32 %26, 1
  %68 = icmp slt i32 %67, %66
  br i1 %68, label %24, label %103, !llvm.loop !123

69:                                               ; preds = %27, %69
  %70 = phi i64 [ %75, %69 ], [ %28, %27 ]
  %71 = phi i8 [ %74, %69 ], [ %29, %27 ]
  %72 = getelementptr inbounds nuw i8, ptr %0, i64 %70
  %73 = load i8, ptr %72, align 1, !tbaa !34
  %74 = add i8 %73, %71
  %75 = add nuw nsw i64 %70, 1
  %76 = icmp eq i64 %75, %15
  br i1 %76, label %77, label %69, !llvm.loop !124

77:                                               ; preds = %69, %59, %43
  %78 = phi i8 [ %45, %43 ], [ %60, %59 ], [ %74, %69 ]
  %79 = add i8 %78, %11
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = fptoui double %80 to i8
  %82 = add i8 %2, %81
  %83 = shl i8 %82, 6
  %84 = icmp eq i8 %79, %83
  br i1 %84, label %65, label %61

85:                                               ; preds = %12, %98
  %86 = phi i32 [ %99, %98 ], [ %6, %12 ]
  %87 = phi double [ %100, %98 ], [ %13, %12 ]
  %88 = phi i32 [ %101, %98 ], [ 0, %12 ]
  %89 = fptoui double %87 to i8
  %90 = add i8 %2, %89
  %91 = shl i8 %90, 6
  %92 = icmp eq i8 %11, %91
  br i1 %92, label %98, label %93

93:                                               ; preds = %85
  %94 = load i32, ptr @current_test, align 4, !tbaa !11
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %98

98:                                               ; preds = %85, %93
  %99 = phi i32 [ %86, %85 ], [ %97, %93 ]
  %100 = phi double [ %87, %85 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %88, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %85, label %103, !llvm.loop !123

103:                                              ; preds = %98, %65, %4
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !30
  %105 = load i64, ptr @start_time, align 8, !tbaa !30
  %106 = load ptr, ptr @results, align 8, !tbaa !6
  %107 = icmp ne ptr %106, null
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = load i32, ptr @current_test, align 4
  %110 = icmp slt i32 %109, %108
  %111 = select i1 %107, i1 %110, i1 false
  br i1 %111, label %123, label %112

112:                                              ; preds = %103
  %113 = add nsw i32 %108, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !11
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %106, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !6
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %112
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %123

120:                                              ; preds = %112
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %103, %118
  %124 = phi i32 [ %119, %118 ], [ %109, %103 ]
  %125 = phi ptr [ %116, %118 ], [ %106, %103 ]
  %126 = sub nsw i64 %104, %105
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !13
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %3, ptr %131, align 8, !tbaa !17
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i8 %3, %2
  %15 = add i8 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 24
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483640
  %29 = insertelement <8 x i8> poison, i8 %15, i64 0
  %30 = shufflevector <8 x i8> %29, <8 x i8> poison, <8 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i8 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <16 x i8> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <16 x i8> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i8, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <16 x i8>, ptr %43, align 1, !tbaa !34
  %46 = load <16 x i8>, ptr %44, align 1, !tbaa !34
  %47 = add <16 x i8> %24, %41
  %48 = add <16 x i8> %24, %42
  %49 = add <16 x i8> %47, %45
  %50 = add <16 x i8> %48, %46
  %51 = add nuw i64 %40, 32
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !125

53:                                               ; preds = %39
  %54 = add <16 x i8> %50, %49
  %55 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i8 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <8 x i8> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i8, ptr %0, i64 %62
  %65 = load <8 x i8>, ptr %64, align 1, !tbaa !34
  %66 = add <8 x i8> %30, %63
  %67 = add <8 x i8> %66, %65
  %68 = add nuw i64 %62, 8
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !126

70:                                               ; preds = %61
  %71 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !127

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i8 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load i8, ptr %83, align 1, !tbaa !34
  %85 = add i8 %15, %82
  %86 = add i8 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !128

89:                                               ; preds = %80, %70, %53
  %90 = phi i8 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptoui double %91 to i8
  %93 = add i8 %15, %92
  %94 = shl i8 %93, 6
  %95 = icmp eq i8 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptoui double %98 to i8
  %101 = add i8 %15, %100
  %102 = and i8 %101, 3
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !127

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = sub <16 x i8> %35, %18
  %42 = sub <16 x i8> %36, %18
  %43 = add <16 x i8> %41, %39
  %44 = add <16 x i8> %42, %40
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !129

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = sub <8 x i8> %57, %24
  %61 = add <8 x i8> %60, %59
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !130

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !131

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = sub i8 %76, %2
  %80 = add i8 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !132

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i8
  %87 = sub i8 %86, %2
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i8
  %95 = sub i8 %94, %2
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !131

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i8 %3, %2
  %15 = add i8 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 24
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483640
  %29 = insertelement <8 x i8> poison, i8 %15, i64 0
  %30 = shufflevector <8 x i8> %29, <8 x i8> poison, <8 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i8 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <16 x i8> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <16 x i8> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i8, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <16 x i8>, ptr %43, align 1, !tbaa !34
  %46 = load <16 x i8>, ptr %44, align 1, !tbaa !34
  %47 = sub <16 x i8> %41, %24
  %48 = sub <16 x i8> %42, %24
  %49 = add <16 x i8> %47, %45
  %50 = add <16 x i8> %48, %46
  %51 = add nuw i64 %40, 32
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !133

53:                                               ; preds = %39
  %54 = add <16 x i8> %50, %49
  %55 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i8 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <8 x i8> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i8, ptr %0, i64 %62
  %65 = load <8 x i8>, ptr %64, align 1, !tbaa !34
  %66 = sub <8 x i8> %63, %30
  %67 = add <8 x i8> %66, %65
  %68 = add nuw i64 %62, 8
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !134

70:                                               ; preds = %61
  %71 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !135

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i8 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load i8, ptr %83, align 1, !tbaa !34
  %85 = sub i8 %82, %15
  %86 = add i8 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !136

89:                                               ; preds = %80, %70, %53
  %90 = phi i8 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptoui double %91 to i8
  %93 = sub i8 %92, %15
  %94 = shl i8 %93, 6
  %95 = icmp eq i8 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptoui double %98 to i8
  %101 = sub i8 %100, %15
  %102 = and i8 %101, 3
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !135

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %107

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = shl i8 %2, 6
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = icmp ult i32 %1, 32
  %17 = and i64 %14, 2147483616
  %18 = insertelement <16 x i8> poison, i8 %2, i64 0
  %19 = shufflevector <16 x i8> %18, <16 x i8> poison, <16 x i32> zeroinitializer
  %20 = icmp eq i64 %17, %14
  %21 = and i64 %14, 24
  %22 = icmp eq i64 %21, 0
  %23 = and i64 %14, 2147483640
  %24 = insertelement <8 x i8> poison, i8 %2, i64 0
  %25 = shufflevector <8 x i8> %24, <8 x i8> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %23, %14
  br label %27

27:                                               ; preds = %13, %71
  %28 = phi i32 [ %72, %71 ], [ %6, %13 ]
  %29 = phi i32 [ %73, %71 ], [ 0, %13 ]
  br i1 %15, label %30, label %33

30:                                               ; preds = %51, %65, %27
  %31 = phi i64 [ 0, %27 ], [ %17, %51 ], [ %23, %65 ]
  %32 = phi i8 [ 0, %27 ], [ %50, %51 ], [ %66, %65 ]
  br label %75

33:                                               ; preds = %27
  br i1 %16, label %52, label %34

34:                                               ; preds = %33, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %33 ]
  %36 = phi <16 x i8> [ %44, %34 ], [ zeroinitializer, %33 ]
  %37 = phi <16 x i8> [ %45, %34 ], [ zeroinitializer, %33 ]
  %38 = getelementptr inbounds nuw i8, ptr %0, i64 %35
  %39 = getelementptr inbounds nuw i8, ptr %38, i64 16
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = load <16 x i8>, ptr %39, align 1, !tbaa !34
  %42 = mul <16 x i8> %40, %19
  %43 = mul <16 x i8> %41, %19
  %44 = add <16 x i8> %42, %36
  %45 = add <16 x i8> %43, %37
  %46 = add nuw i64 %35, 32
  %47 = icmp eq i64 %46, %17
  br i1 %47, label %48, label %34, !llvm.loop !137

48:                                               ; preds = %34
  %49 = add <16 x i8> %45, %44
  %50 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %49)
  br i1 %20, label %84, label %51

51:                                               ; preds = %48
  br i1 %22, label %30, label %52

52:                                               ; preds = %51, %33
  %53 = phi i64 [ %17, %51 ], [ 0, %33 ]
  %54 = phi i8 [ %50, %51 ], [ 0, %33 ]
  %55 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %54, i64 0
  br label %56

56:                                               ; preds = %56, %52
  %57 = phi i64 [ %53, %52 ], [ %63, %56 ]
  %58 = phi <8 x i8> [ %55, %52 ], [ %62, %56 ]
  %59 = getelementptr inbounds nuw i8, ptr %0, i64 %57
  %60 = load <8 x i8>, ptr %59, align 1, !tbaa !34
  %61 = mul <8 x i8> %60, %25
  %62 = add <8 x i8> %61, %58
  %63 = add nuw i64 %57, 8
  %64 = icmp eq i64 %63, %23
  br i1 %64, label %65, label %56, !llvm.loop !138

65:                                               ; preds = %56
  %66 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %62)
  br i1 %26, label %84, label %30

67:                                               ; preds = %84
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %68)
  %70 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %71

71:                                               ; preds = %67, %84
  %72 = phi i32 [ %70, %67 ], [ %28, %84 ]
  %73 = add nuw nsw i32 %29, 1
  %74 = icmp slt i32 %73, %72
  br i1 %74, label %27, label %107, !llvm.loop !139

75:                                               ; preds = %30, %75
  %76 = phi i64 [ %82, %75 ], [ %31, %30 ]
  %77 = phi i8 [ %81, %75 ], [ %32, %30 ]
  %78 = getelementptr inbounds nuw i8, ptr %0, i64 %76
  %79 = load i8, ptr %78, align 1, !tbaa !34
  %80 = mul i8 %79, %2
  %81 = add i8 %80, %77
  %82 = add nuw nsw i64 %76, 1
  %83 = icmp eq i64 %82, %14
  br i1 %83, label %84, label %75, !llvm.loop !140

84:                                               ; preds = %75, %65, %48
  %85 = phi i8 [ %50, %48 ], [ %66, %65 ], [ %81, %75 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = fptoui double %86 to i8
  %88 = mul i8 %10, %87
  %89 = icmp eq i8 %85, %88
  br i1 %89, label %71, label %67

90:                                               ; preds = %11, %102
  %91 = phi i32 [ %103, %102 ], [ %6, %11 ]
  %92 = phi double [ %104, %102 ], [ %12, %11 ]
  %93 = phi i32 [ %105, %102 ], [ 0, %11 ]
  %94 = fptoui double %92 to i8
  %95 = mul i8 %10, %94
  %96 = icmp eq i8 %95, 0
  br i1 %96, label %102, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %98)
  %100 = load double, ptr @init_value, align 8, !tbaa !33
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %90, %97
  %103 = phi i32 [ %91, %90 ], [ %101, %97 ]
  %104 = phi double [ %92, %90 ], [ %100, %97 ]
  %105 = add nuw nsw i32 %93, 1
  %106 = icmp slt i32 %105, %103
  br i1 %106, label %90, label %107, !llvm.loop !139

107:                                              ; preds = %102, %71, %4
  %108 = tail call i64 @clock() #17
  store i64 %108, ptr @end_time, align 8, !tbaa !30
  %109 = load i64, ptr @start_time, align 8, !tbaa !30
  %110 = load ptr, ptr @results, align 8, !tbaa !6
  %111 = icmp ne ptr %110, null
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = load i32, ptr @current_test, align 4
  %114 = icmp slt i32 %113, %112
  %115 = select i1 %111, i1 %114, i1 false
  br i1 %115, label %127, label %116

116:                                              ; preds = %107
  %117 = add nsw i32 %112, 10
  store i32 %117, ptr @allocated_results, align 4, !tbaa !11
  %118 = sext i32 %117 to i64
  %119 = shl nsw i64 %118, 4
  %120 = tail call ptr @realloc(ptr noundef %110, i64 noundef %119) #14
  store ptr %120, ptr @results, align 8, !tbaa !6
  %121 = icmp eq ptr %120, null
  br i1 %121, label %124, label %122

122:                                              ; preds = %116
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %127

124:                                              ; preds = %116
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %126 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %125)
  tail call void @exit(i32 noundef -1) #15
  unreachable

127:                                              ; preds = %107, %122
  %128 = phi i32 [ %123, %122 ], [ %113, %107 ]
  %129 = phi ptr [ %120, %122 ], [ %110, %107 ]
  %130 = sub nsw i64 %108, %109
  %131 = sitofp i64 %130 to double
  %132 = fdiv double %131, 1.000000e+06
  %133 = sext i32 %128 to i64
  %134 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133
  store double %132, ptr %134, align 8, !tbaa !13
  %135 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133, i32 1
  store ptr %3, ptr %135, align 8, !tbaa !17
  %136 = add nsw i32 %128, 1
  store i32 %136, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = shl i8 %4, 6
  %13 = mul i8 %12, %2
  %14 = mul i8 %13, %5
  %15 = mul i8 %4, %5
  %16 = mul i8 %15, %3
  %17 = mul i8 %16, %2
  %18 = icmp sgt i32 %1, 0
  %19 = mul i8 %14, %3
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = icmp ult i32 %1, 32
  %26 = and i64 %23, 2147483616
  %27 = insertelement <16 x i8> poison, i8 %17, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 24
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483640
  %33 = insertelement <8 x i8> poison, i8 %17, i64 0
  %34 = shufflevector <8 x i8> %33, <8 x i8> poison, <8 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %22, %80
  %37 = phi i32 [ %81, %80 ], [ %9, %22 ]
  %38 = phi i32 [ %82, %80 ], [ 0, %22 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i8 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <16 x i8> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <16 x i8> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i8, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <16 x i8>, ptr %47, align 1, !tbaa !34
  %50 = load <16 x i8>, ptr %48, align 1, !tbaa !34
  %51 = mul <16 x i8> %28, %49
  %52 = mul <16 x i8> %28, %50
  %53 = add <16 x i8> %51, %45
  %54 = add <16 x i8> %52, %46
  %55 = add nuw i64 %44, 32
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !141

57:                                               ; preds = %43
  %58 = add <16 x i8> %54, %53
  %59 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i8 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <8 x i8> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i8, ptr %0, i64 %66
  %69 = load <8 x i8>, ptr %68, align 1, !tbaa !34
  %70 = mul <8 x i8> %34, %69
  %71 = add <8 x i8> %70, %67
  %72 = add nuw i64 %66, 8
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !142

74:                                               ; preds = %65
  %75 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %116, !llvm.loop !143

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i8 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i8, ptr %0, i64 %85
  %88 = load i8, ptr %87, align 1, !tbaa !34
  %89 = mul i8 %17, %88
  %90 = add i8 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !144

93:                                               ; preds = %84, %74, %57
  %94 = phi i8 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptoui double %95 to i8
  %97 = mul i8 %19, %96
  %98 = icmp eq i8 %94, %97
  br i1 %98, label %80, label %76

99:                                               ; preds = %20, %111
  %100 = phi i32 [ %112, %111 ], [ %9, %20 ]
  %101 = phi double [ %113, %111 ], [ %21, %20 ]
  %102 = phi i32 [ %114, %111 ], [ 0, %20 ]
  %103 = fptoui double %101 to i8
  %104 = mul i8 %19, %103
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %99
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %99, %106
  %112 = phi i32 [ %100, %99 ], [ %110, %106 ]
  %113 = phi double [ %101, %99 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %102, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %99, label %116, !llvm.loop !143

116:                                              ; preds = %111, %80, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %117

11:                                               ; preds = %7
  %12 = mul i8 %3, %4
  %13 = mul i8 %12, %5
  %14 = mul i8 %3, %5
  %15 = mul i8 %14, %2
  %16 = mul i8 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i8 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = icmp ult i32 %1, 32
  %25 = and i64 %22, 2147483616
  %26 = insertelement <16 x i8> poison, i8 %16, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %22
  %29 = and i64 %22, 24
  %30 = icmp eq i64 %29, 0
  %31 = and i64 %22, 2147483640
  %32 = insertelement <8 x i8> poison, i8 %16, i64 0
  %33 = shufflevector <8 x i8> %32, <8 x i8> poison, <8 x i32> zeroinitializer
  %34 = icmp eq i64 %31, %22
  br label %35

35:                                               ; preds = %21, %79
  %36 = phi i32 [ %80, %79 ], [ %9, %21 ]
  %37 = phi i32 [ %81, %79 ], [ 0, %21 ]
  br i1 %23, label %38, label %41

38:                                               ; preds = %59, %73, %35
  %39 = phi i64 [ 0, %35 ], [ %25, %59 ], [ %31, %73 ]
  %40 = phi i8 [ 0, %35 ], [ %58, %59 ], [ %74, %73 ]
  br label %83

41:                                               ; preds = %35
  br i1 %24, label %60, label %42

42:                                               ; preds = %41, %42
  %43 = phi i64 [ %54, %42 ], [ 0, %41 ]
  %44 = phi <16 x i8> [ %52, %42 ], [ zeroinitializer, %41 ]
  %45 = phi <16 x i8> [ %53, %42 ], [ zeroinitializer, %41 ]
  %46 = getelementptr inbounds nuw i8, ptr %0, i64 %43
  %47 = getelementptr inbounds nuw i8, ptr %46, i64 16
  %48 = load <16 x i8>, ptr %46, align 1, !tbaa !34
  %49 = load <16 x i8>, ptr %47, align 1, !tbaa !34
  %50 = add <16 x i8> %44, %27
  %51 = add <16 x i8> %45, %27
  %52 = add <16 x i8> %50, %48
  %53 = add <16 x i8> %51, %49
  %54 = add nuw i64 %43, 32
  %55 = icmp eq i64 %54, %25
  br i1 %55, label %56, label %42, !llvm.loop !145

56:                                               ; preds = %42
  %57 = add <16 x i8> %53, %52
  %58 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %57)
  br i1 %28, label %92, label %59

59:                                               ; preds = %56
  br i1 %30, label %38, label %60

60:                                               ; preds = %59, %41
  %61 = phi i64 [ %25, %59 ], [ 0, %41 ]
  %62 = phi i8 [ %58, %59 ], [ 0, %41 ]
  %63 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %62, i64 0
  br label %64

64:                                               ; preds = %64, %60
  %65 = phi i64 [ %61, %60 ], [ %71, %64 ]
  %66 = phi <8 x i8> [ %63, %60 ], [ %70, %64 ]
  %67 = getelementptr inbounds nuw i8, ptr %0, i64 %65
  %68 = load <8 x i8>, ptr %67, align 1, !tbaa !34
  %69 = add <8 x i8> %66, %33
  %70 = add <8 x i8> %69, %68
  %71 = add nuw i64 %65, 8
  %72 = icmp eq i64 %71, %31
  br i1 %72, label %73, label %64, !llvm.loop !146

73:                                               ; preds = %64
  %74 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %70)
  br i1 %34, label %92, label %38

75:                                               ; preds = %92
  %76 = load i32, ptr @current_test, align 4, !tbaa !11
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %75, %92
  %80 = phi i32 [ %78, %75 ], [ %36, %92 ]
  %81 = add nuw nsw i32 %37, 1
  %82 = icmp slt i32 %81, %80
  br i1 %82, label %35, label %117, !llvm.loop !147

83:                                               ; preds = %38, %83
  %84 = phi i64 [ %90, %83 ], [ %39, %38 ]
  %85 = phi i8 [ %89, %83 ], [ %40, %38 ]
  %86 = getelementptr inbounds nuw i8, ptr %0, i64 %84
  %87 = load i8, ptr %86, align 1, !tbaa !34
  %88 = add i8 %85, %16
  %89 = add i8 %88, %87
  %90 = add nuw nsw i64 %84, 1
  %91 = icmp eq i64 %90, %22
  br i1 %91, label %92, label %83, !llvm.loop !148

92:                                               ; preds = %83, %73, %56
  %93 = phi i8 [ %58, %56 ], [ %74, %73 ], [ %89, %83 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !33
  %95 = fptoui double %94 to i8
  %96 = add i8 %18, %95
  %97 = shl i8 %96, 6
  %98 = icmp eq i8 %93, %97
  br i1 %98, label %79, label %75

99:                                               ; preds = %19, %112
  %100 = phi i32 [ %113, %112 ], [ %9, %19 ]
  %101 = phi double [ %114, %112 ], [ %20, %19 ]
  %102 = phi i32 [ %115, %112 ], [ 0, %19 ]
  %103 = fptoui double %101 to i8
  %104 = add i8 %18, %103
  %105 = and i8 %104, 3
  %106 = icmp eq i8 %105, 0
  br i1 %106, label %112, label %107

107:                                              ; preds = %99
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %108)
  %110 = load double, ptr @init_value, align 8, !tbaa !33
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %99, %107
  %113 = phi i32 [ %100, %99 ], [ %111, %107 ]
  %114 = phi double [ %101, %99 ], [ %110, %107 ]
  %115 = add nuw nsw i32 %102, 1
  %116 = icmp slt i32 %115, %113
  br i1 %116, label %99, label %117, !llvm.loop !147

117:                                              ; preds = %112, %79, %7
  %118 = tail call i64 @clock() #17
  store i64 %118, ptr @end_time, align 8, !tbaa !30
  %119 = load i64, ptr @start_time, align 8, !tbaa !30
  %120 = load ptr, ptr @results, align 8, !tbaa !6
  %121 = icmp ne ptr %120, null
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = load i32, ptr @current_test, align 4
  %124 = icmp slt i32 %123, %122
  %125 = select i1 %121, i1 %124, i1 false
  br i1 %125, label %137, label %126

126:                                              ; preds = %117
  %127 = add nsw i32 %122, 10
  store i32 %127, ptr @allocated_results, align 4, !tbaa !11
  %128 = sext i32 %127 to i64
  %129 = shl nsw i64 %128, 4
  %130 = tail call ptr @realloc(ptr noundef %120, i64 noundef %129) #14
  store ptr %130, ptr @results, align 8, !tbaa !6
  %131 = icmp eq ptr %130, null
  br i1 %131, label %134, label %132

132:                                              ; preds = %126
  %133 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %137

134:                                              ; preds = %126
  %135 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %136 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %135)
  tail call void @exit(i32 noundef -1) #15
  unreachable

137:                                              ; preds = %117, %132
  %138 = phi i32 [ %133, %132 ], [ %123, %117 ]
  %139 = phi ptr [ %130, %132 ], [ %120, %117 ]
  %140 = sub nsw i64 %118, %119
  %141 = sitofp i64 %140 to double
  %142 = fdiv double %141, 1.000000e+06
  %143 = sext i32 %138 to i64
  %144 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143
  store double %142, ptr %144, align 8, !tbaa !13
  %145 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143, i32 1
  store ptr %6, ptr %145, align 8, !tbaa !17
  %146 = add nsw i32 %138, 1
  store i32 %146, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp eq i32 %1, 1
  %15 = and i64 %13, 2147483646
  %16 = icmp eq i64 %15, %13
  br label %17

17:                                               ; preds = %12, %44
  %18 = phi i32 [ %45, %44 ], [ %6, %12 ]
  %19 = phi i32 [ %46, %44 ], [ 0, %12 ]
  br i1 %14, label %37, label %20

20:                                               ; preds = %17, %20
  %21 = phi i64 [ %33, %20 ], [ 0, %17 ]
  %22 = phi i8 [ %31, %20 ], [ 0, %17 ]
  %23 = phi i8 [ %32, %20 ], [ 0, %17 ]
  %24 = getelementptr inbounds nuw i8, ptr %0, i64 %21
  %25 = getelementptr inbounds nuw i8, ptr %0, i64 %21
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 1
  %27 = load i8, ptr %24, align 1, !tbaa !34
  %28 = load i8, ptr %26, align 1, !tbaa !34
  %29 = udiv i8 %27, %2
  %30 = udiv i8 %28, %2
  %31 = add i8 %29, %22
  %32 = add i8 %30, %23
  %33 = add nuw i64 %21, 2
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %20, !llvm.loop !149

35:                                               ; preds = %20
  %36 = add i8 %32, %31
  br i1 %16, label %57, label %37

37:                                               ; preds = %17, %35
  %38 = phi i64 [ 0, %17 ], [ %15, %35 ]
  %39 = phi i8 [ 0, %17 ], [ %36, %35 ]
  br label %48

40:                                               ; preds = %57
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %57
  %45 = phi i32 [ %43, %40 ], [ %18, %57 ]
  %46 = add nuw nsw i32 %19, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %17, label %82, !llvm.loop !150

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %55, %48 ], [ %38, %37 ]
  %50 = phi i8 [ %54, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i8, ptr %0, i64 %49
  %52 = load i8, ptr %51, align 1, !tbaa !34
  %53 = udiv i8 %52, %2
  %54 = add i8 %53, %50
  %55 = add nuw nsw i64 %49, 1
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %57, label %48, !llvm.loop !151

57:                                               ; preds = %48, %35
  %58 = phi i8 [ %36, %35 ], [ %54, %48 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptoui double %59 to i8
  %61 = udiv i8 %60, %2
  %62 = shl i8 %61, 6
  %63 = icmp eq i8 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %10, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %66 = phi double [ %79, %77 ], [ %11, %10 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %68 = fptoui double %66 to i8
  %69 = udiv i8 %68, %2
  %70 = and i8 %69, 3
  %71 = icmp eq i8 %70, 0
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !150

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp eq i32 %1, 1
  %18 = and i64 %16, 2147483646
  %19 = icmp eq i64 %18, %16
  br label %20

20:                                               ; preds = %15, %53
  %21 = phi i32 [ %54, %53 ], [ %9, %15 ]
  %22 = phi i32 [ %55, %53 ], [ 0, %15 ]
  br i1 %17, label %46, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %42, %23 ], [ 0, %20 ]
  %25 = phi i8 [ %40, %23 ], [ 0, %20 ]
  %26 = phi i8 [ %41, %23 ], [ 0, %20 ]
  %27 = getelementptr inbounds nuw i8, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i8, ptr %0, i64 %24
  %29 = getelementptr inbounds nuw i8, ptr %28, i64 1
  %30 = load i8, ptr %27, align 1, !tbaa !34
  %31 = load i8, ptr %29, align 1, !tbaa !34
  %32 = udiv i8 %30, %2
  %33 = udiv i8 %31, %2
  %34 = udiv i8 %32, %3
  %35 = udiv i8 %33, %3
  %36 = udiv i8 %34, %4
  %37 = udiv i8 %35, %4
  %38 = udiv i8 %36, %5
  %39 = udiv i8 %37, %5
  %40 = add i8 %38, %25
  %41 = add i8 %39, %26
  %42 = add nuw i64 %24, 2
  %43 = icmp eq i64 %42, %18
  br i1 %43, label %44, label %23, !llvm.loop !152

44:                                               ; preds = %23
  %45 = add i8 %41, %40
  br i1 %19, label %69, label %46

46:                                               ; preds = %20, %44
  %47 = phi i64 [ 0, %20 ], [ %18, %44 ]
  %48 = phi i8 [ 0, %20 ], [ %45, %44 ]
  br label %57

49:                                               ; preds = %69
  %50 = load i32, ptr @current_test, align 4, !tbaa !11
  %51 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %50)
  %52 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %53

53:                                               ; preds = %49, %69
  %54 = phi i32 [ %52, %49 ], [ %21, %69 ]
  %55 = add nuw nsw i32 %22, 1
  %56 = icmp slt i32 %55, %54
  br i1 %56, label %20, label %100, !llvm.loop !153

57:                                               ; preds = %46, %57
  %58 = phi i64 [ %67, %57 ], [ %47, %46 ]
  %59 = phi i8 [ %66, %57 ], [ %48, %46 ]
  %60 = getelementptr inbounds nuw i8, ptr %0, i64 %58
  %61 = load i8, ptr %60, align 1, !tbaa !34
  %62 = udiv i8 %61, %2
  %63 = udiv i8 %62, %3
  %64 = udiv i8 %63, %4
  %65 = udiv i8 %64, %5
  %66 = add i8 %65, %59
  %67 = add nuw nsw i64 %58, 1
  %68 = icmp eq i64 %67, %16
  br i1 %68, label %69, label %57, !llvm.loop !154

69:                                               ; preds = %57, %44
  %70 = phi i8 [ %45, %44 ], [ %66, %57 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptoui double %71 to i8
  %73 = udiv i8 %72, %2
  %74 = udiv i8 %73, %3
  %75 = udiv i8 %74, %4
  %76 = udiv i8 %75, %5
  %77 = shl i8 %76, 6
  %78 = icmp eq i8 %70, %77
  br i1 %78, label %53, label %49

79:                                               ; preds = %13, %95
  %80 = phi i32 [ %96, %95 ], [ %9, %13 ]
  %81 = phi double [ %97, %95 ], [ %14, %13 ]
  %82 = phi i32 [ %98, %95 ], [ 0, %13 ]
  %83 = fptoui double %81 to i8
  %84 = udiv i8 %83, %2
  %85 = udiv i8 %84, %3
  %86 = udiv i8 %85, %4
  %87 = udiv i8 %86, %5
  %88 = and i8 %87, 3
  %89 = icmp eq i8 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %79
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !33
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %95

95:                                               ; preds = %79, %90
  %96 = phi i32 [ %80, %79 ], [ %94, %90 ]
  %97 = phi double [ %81, %79 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %82, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %79, label %100, !llvm.loop !153

100:                                              ; preds = %95, %53, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !30
  %102 = load i64, ptr @start_time, align 8, !tbaa !30
  %103 = load ptr, ptr @results, align 8, !tbaa !6
  %104 = icmp ne ptr %103, null
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = load i32, ptr @current_test, align 4
  %107 = icmp slt i32 %106, %105
  %108 = select i1 %104, i1 %107, i1 false
  br i1 %108, label %120, label %109

109:                                              ; preds = %100
  %110 = add nsw i32 %105, 10
  store i32 %110, ptr @allocated_results, align 4, !tbaa !11
  %111 = sext i32 %110 to i64
  %112 = shl nsw i64 %111, 4
  %113 = tail call ptr @realloc(ptr noundef %103, i64 noundef %112) #14
  store ptr %113, ptr @results, align 8, !tbaa !6
  %114 = icmp eq ptr %113, null
  br i1 %114, label %117, label %115

115:                                              ; preds = %109
  %116 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %120

117:                                              ; preds = %109
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %119 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %118)
  tail call void @exit(i32 noundef -1) #15
  unreachable

120:                                              ; preds = %100, %115
  %121 = phi i32 [ %116, %115 ], [ %106, %100 ]
  %122 = phi ptr [ %113, %115 ], [ %103, %100 ]
  %123 = sub nsw i64 %101, %102
  %124 = sitofp i64 %123 to double
  %125 = fdiv double %124, 1.000000e+06
  %126 = sext i32 %121 to i64
  %127 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126
  store double %125, ptr %127, align 8, !tbaa !13
  %128 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126, i32 1
  store ptr %6, ptr %128, align 8, !tbaa !17
  %129 = add nsw i32 %121, 1
  store i32 %129, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i8 %2, %3
  %14 = udiv i8 %13, %4
  %15 = udiv i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 24
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483640
  %29 = insertelement <8 x i8> poison, i8 %15, i64 0
  %30 = shufflevector <8 x i8> %29, <8 x i8> poison, <8 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %76, %18
  %33 = phi i32 [ %9, %18 ], [ %77, %76 ]
  %34 = phi i32 [ 0, %18 ], [ %78, %76 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i8 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <16 x i8> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <16 x i8> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i8, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <16 x i8>, ptr %43, align 1, !tbaa !34
  %46 = load <16 x i8>, ptr %44, align 1, !tbaa !34
  %47 = add <16 x i8> %45, %41
  %48 = add <16 x i8> %46, %42
  %49 = add <16 x i8> %47, %24
  %50 = add <16 x i8> %48, %24
  %51 = add nuw i64 %40, 32
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !155

53:                                               ; preds = %39
  %54 = add <16 x i8> %50, %49
  %55 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i8 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <8 x i8> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i8, ptr %0, i64 %62
  %65 = load <8 x i8>, ptr %64, align 1, !tbaa !34
  %66 = add <8 x i8> %65, %63
  %67 = add <8 x i8> %66, %30
  %68 = add nuw i64 %62, 8
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !156

70:                                               ; preds = %61
  %71 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !157

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i8 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load i8, ptr %83, align 1, !tbaa !34
  %85 = add i8 %84, %82
  %86 = add i8 %85, %15
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !158

89:                                               ; preds = %80, %70, %53
  %90 = phi i8 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptoui double %91 to i8
  %93 = add i8 %15, %92
  %94 = shl i8 %93, 6
  %95 = icmp eq i8 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptoui double %98 to i8
  %101 = add i8 %15, %100
  %102 = and i8 %101, 3
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !157

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %118

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = zext i8 %3 to i16
  %14 = zext i8 %4 to i16
  %15 = mul nuw i16 %14, %13
  %16 = zext i8 %5 to i16
  %17 = udiv i16 %15, %16
  %18 = trunc i16 %17 to i8
  %19 = sub i8 %2, %18
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %100

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = icmp ult i32 %1, 32
  %26 = and i64 %23, 2147483616
  %27 = insertelement <16 x i8> poison, i8 %19, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 24
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483640
  %33 = insertelement <8 x i8> poison, i8 %19, i64 0
  %34 = shufflevector <8 x i8> %33, <8 x i8> poison, <8 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %80, %22
  %37 = phi i32 [ %9, %22 ], [ %81, %80 ]
  %38 = phi i32 [ 0, %22 ], [ %82, %80 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i8 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <16 x i8> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <16 x i8> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i8, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <16 x i8>, ptr %47, align 1, !tbaa !34
  %50 = load <16 x i8>, ptr %48, align 1, !tbaa !34
  %51 = add <16 x i8> %28, %49
  %52 = add <16 x i8> %28, %50
  %53 = add <16 x i8> %51, %45
  %54 = add <16 x i8> %52, %46
  %55 = add nuw i64 %44, 32
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !159

57:                                               ; preds = %43
  %58 = add <16 x i8> %54, %53
  %59 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i8 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <8 x i8> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i8, ptr %0, i64 %66
  %69 = load <8 x i8>, ptr %68, align 1, !tbaa !34
  %70 = add <8 x i8> %34, %69
  %71 = add <8 x i8> %70, %67
  %72 = add nuw i64 %66, 8
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !160

74:                                               ; preds = %65
  %75 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %118, !llvm.loop !161

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i8 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i8, ptr %0, i64 %85
  %88 = load i8, ptr %87, align 1, !tbaa !34
  %89 = add i8 %19, %88
  %90 = add i8 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !162

93:                                               ; preds = %84, %74, %57
  %94 = phi i8 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptoui double %95 to i8
  %97 = add i8 %19, %96
  %98 = shl i8 %97, 6
  %99 = icmp eq i8 %94, %98
  br i1 %99, label %80, label %76

100:                                              ; preds = %20, %113
  %101 = phi i32 [ %114, %113 ], [ %9, %20 ]
  %102 = phi double [ %115, %113 ], [ %21, %20 ]
  %103 = phi i32 [ %116, %113 ], [ 0, %20 ]
  %104 = fptoui double %102 to i8
  %105 = add i8 %19, %104
  %106 = and i8 %105, 3
  %107 = icmp eq i8 %106, 0
  br i1 %107, label %113, label %108

108:                                              ; preds = %100
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %109)
  %111 = load double, ptr @init_value, align 8, !tbaa !33
  %112 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %113

113:                                              ; preds = %100, %108
  %114 = phi i32 [ %101, %100 ], [ %112, %108 ]
  %115 = phi double [ %102, %100 ], [ %111, %108 ]
  %116 = add nuw nsw i32 %103, 1
  %117 = icmp slt i32 %116, %114
  br i1 %117, label %100, label %118, !llvm.loop !161

118:                                              ; preds = %113, %80, %7
  %119 = tail call i64 @clock() #17
  store i64 %119, ptr @end_time, align 8, !tbaa !30
  %120 = load i64, ptr @start_time, align 8, !tbaa !30
  %121 = load ptr, ptr @results, align 8, !tbaa !6
  %122 = icmp ne ptr %121, null
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = load i32, ptr @current_test, align 4
  %125 = icmp slt i32 %124, %123
  %126 = select i1 %122, i1 %125, i1 false
  br i1 %126, label %138, label %127

127:                                              ; preds = %118
  %128 = add nsw i32 %123, 10
  store i32 %128, ptr @allocated_results, align 4, !tbaa !11
  %129 = sext i32 %128 to i64
  %130 = shl nsw i64 %129, 4
  %131 = tail call ptr @realloc(ptr noundef %121, i64 noundef %130) #14
  store ptr %131, ptr @results, align 8, !tbaa !6
  %132 = icmp eq ptr %131, null
  br i1 %132, label %135, label %133

133:                                              ; preds = %127
  %134 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %138

135:                                              ; preds = %127
  %136 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %137 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %136)
  tail call void @exit(i32 noundef -1) #15
  unreachable

138:                                              ; preds = %118, %133
  %139 = phi i32 [ %134, %133 ], [ %124, %118 ]
  %140 = phi ptr [ %131, %133 ], [ %121, %118 ]
  %141 = sub nsw i64 %119, %120
  %142 = sitofp i64 %141 to double
  %143 = fdiv double %142, 1.000000e+06
  %144 = sext i32 %139 to i64
  %145 = getelementptr inbounds %struct.one_result, ptr %140, i64 %144
  store double %143, ptr %145, align 8, !tbaa !13
  %146 = getelementptr inbounds %struct.one_result, ptr %140, i64 %144, i32 1
  store ptr %6, ptr %146, align 8, !tbaa !17
  %147 = add nsw i32 %139, 1
  store i32 %147, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %13, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  %12 = and i8 %2, 3
  br label %91

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = icmp ult i32 %1, 32
  %17 = and i64 %14, 2147483616
  %18 = insertelement <16 x i8> poison, i8 %2, i64 0
  %19 = shufflevector <16 x i8> %18, <16 x i8> poison, <16 x i32> zeroinitializer
  %20 = icmp eq i64 %17, %14
  %21 = and i64 %14, 24
  %22 = icmp eq i64 %21, 0
  %23 = and i64 %14, 2147483640
  %24 = insertelement <8 x i8> poison, i8 %2, i64 0
  %25 = shufflevector <8 x i8> %24, <8 x i8> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %23, %14
  br label %27

27:                                               ; preds = %13, %71
  %28 = phi i32 [ %72, %71 ], [ %6, %13 ]
  %29 = phi i32 [ %73, %71 ], [ 0, %13 ]
  br i1 %15, label %30, label %33

30:                                               ; preds = %51, %65, %27
  %31 = phi i64 [ 0, %27 ], [ %17, %51 ], [ %23, %65 ]
  %32 = phi i8 [ 0, %27 ], [ %50, %51 ], [ %66, %65 ]
  br label %75

33:                                               ; preds = %27
  br i1 %16, label %52, label %34

34:                                               ; preds = %33, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %33 ]
  %36 = phi <16 x i8> [ %44, %34 ], [ zeroinitializer, %33 ]
  %37 = phi <16 x i8> [ %45, %34 ], [ zeroinitializer, %33 ]
  %38 = getelementptr inbounds nuw i8, ptr %0, i64 %35
  %39 = getelementptr inbounds nuw i8, ptr %38, i64 16
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = load <16 x i8>, ptr %39, align 1, !tbaa !34
  %42 = and <16 x i8> %40, %19
  %43 = and <16 x i8> %41, %19
  %44 = add <16 x i8> %42, %36
  %45 = add <16 x i8> %43, %37
  %46 = add nuw i64 %35, 32
  %47 = icmp eq i64 %46, %17
  br i1 %47, label %48, label %34, !llvm.loop !163

48:                                               ; preds = %34
  %49 = add <16 x i8> %45, %44
  %50 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %49)
  br i1 %20, label %84, label %51

51:                                               ; preds = %48
  br i1 %22, label %30, label %52

52:                                               ; preds = %51, %33
  %53 = phi i64 [ %17, %51 ], [ 0, %33 ]
  %54 = phi i8 [ %50, %51 ], [ 0, %33 ]
  %55 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %54, i64 0
  br label %56

56:                                               ; preds = %56, %52
  %57 = phi i64 [ %53, %52 ], [ %63, %56 ]
  %58 = phi <8 x i8> [ %55, %52 ], [ %62, %56 ]
  %59 = getelementptr inbounds nuw i8, ptr %0, i64 %57
  %60 = load <8 x i8>, ptr %59, align 1, !tbaa !34
  %61 = and <8 x i8> %60, %25
  %62 = add <8 x i8> %61, %58
  %63 = add nuw i64 %57, 8
  %64 = icmp eq i64 %63, %23
  br i1 %64, label %65, label %56, !llvm.loop !164

65:                                               ; preds = %56
  %66 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %62)
  br i1 %26, label %84, label %30

67:                                               ; preds = %84
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %68)
  %70 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %71

71:                                               ; preds = %67, %84
  %72 = phi i32 [ %70, %67 ], [ %28, %84 ]
  %73 = add nuw nsw i32 %29, 1
  %74 = icmp slt i32 %73, %72
  br i1 %74, label %27, label %108, !llvm.loop !165

75:                                               ; preds = %30, %75
  %76 = phi i64 [ %82, %75 ], [ %31, %30 ]
  %77 = phi i8 [ %81, %75 ], [ %32, %30 ]
  %78 = getelementptr inbounds nuw i8, ptr %0, i64 %76
  %79 = load i8, ptr %78, align 1, !tbaa !34
  %80 = and i8 %79, %2
  %81 = add i8 %80, %77
  %82 = add nuw nsw i64 %76, 1
  %83 = icmp eq i64 %82, %14
  br i1 %83, label %84, label %75, !llvm.loop !166

84:                                               ; preds = %75, %65, %48
  %85 = phi i8 [ %50, %48 ], [ %66, %65 ], [ %81, %75 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = fptoui double %86 to i8
  %88 = and i8 %2, %87
  %89 = shl i8 %88, 6
  %90 = icmp eq i8 %85, %89
  br i1 %90, label %71, label %67

91:                                               ; preds = %10, %103
  %92 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %93 = phi double [ %105, %103 ], [ %11, %10 ]
  %94 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %95 = fptoui double %93 to i8
  %96 = and i8 %12, %95
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %91, %98
  %104 = phi i32 [ %92, %91 ], [ %102, %98 ]
  %105 = phi double [ %93, %91 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %94, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %91, label %108, !llvm.loop !165

108:                                              ; preds = %103, %71, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = and i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i8 %2, %12
  %15 = and i8 %14, %3
  br i1 %13, label %19, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  %18 = and i8 %15, 3
  br label %115

19:                                               ; preds = %11
  %20 = zext nneg i32 %1 to i64
  %21 = icmp ult i32 %1, 8
  %22 = icmp ult i32 %1, 32
  %23 = and i64 %20, 2147483616
  %24 = insertelement <16 x i8> poison, i8 %4, i64 0
  %25 = shufflevector <16 x i8> %24, <16 x i8> poison, <16 x i32> zeroinitializer
  %26 = insertelement <16 x i8> poison, i8 %5, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = insertelement <16 x i8> poison, i8 %2, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = insertelement <16 x i8> poison, i8 %3, i64 0
  %31 = shufflevector <16 x i8> %30, <16 x i8> poison, <16 x i32> zeroinitializer
  %32 = and <16 x i8> %25, %27
  %33 = and <16 x i8> %25, %27
  %34 = and <16 x i8> %32, %29
  %35 = and <16 x i8> %33, %29
  %36 = and <16 x i8> %34, %31
  %37 = and <16 x i8> %35, %31
  %38 = icmp eq i64 %23, %20
  %39 = and i64 %20, 24
  %40 = icmp eq i64 %39, 0
  %41 = and i64 %20, 2147483640
  %42 = and i8 %5, %4
  %43 = and i8 %2, %42
  %44 = and i8 %3, %43
  %45 = insertelement <8 x i8> poison, i8 %44, i64 0
  %46 = shufflevector <8 x i8> %45, <8 x i8> poison, <8 x i32> zeroinitializer
  %47 = icmp eq i64 %41, %20
  %48 = and i8 %4, %5
  %49 = and i8 %48, %2
  %50 = and i8 %49, %3
  br label %51

51:                                               ; preds = %19, %95
  %52 = phi i32 [ %96, %95 ], [ %9, %19 ]
  %53 = phi i32 [ %97, %95 ], [ 0, %19 ]
  br i1 %21, label %54, label %57

54:                                               ; preds = %75, %89, %51
  %55 = phi i64 [ 0, %51 ], [ %23, %75 ], [ %41, %89 ]
  %56 = phi i8 [ 0, %51 ], [ %74, %75 ], [ %90, %89 ]
  br label %99

57:                                               ; preds = %51
  br i1 %22, label %76, label %58

58:                                               ; preds = %57, %58
  %59 = phi i64 [ %70, %58 ], [ 0, %57 ]
  %60 = phi <16 x i8> [ %68, %58 ], [ zeroinitializer, %57 ]
  %61 = phi <16 x i8> [ %69, %58 ], [ zeroinitializer, %57 ]
  %62 = getelementptr inbounds nuw i8, ptr %0, i64 %59
  %63 = getelementptr inbounds nuw i8, ptr %62, i64 16
  %64 = load <16 x i8>, ptr %62, align 1, !tbaa !34
  %65 = load <16 x i8>, ptr %63, align 1, !tbaa !34
  %66 = and <16 x i8> %64, %36
  %67 = and <16 x i8> %65, %37
  %68 = add <16 x i8> %66, %60
  %69 = add <16 x i8> %67, %61
  %70 = add nuw i64 %59, 32
  %71 = icmp eq i64 %70, %23
  br i1 %71, label %72, label %58, !llvm.loop !167

72:                                               ; preds = %58
  %73 = add <16 x i8> %69, %68
  %74 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %73)
  br i1 %38, label %108, label %75

75:                                               ; preds = %72
  br i1 %40, label %54, label %76

76:                                               ; preds = %75, %57
  %77 = phi i64 [ %23, %75 ], [ 0, %57 ]
  %78 = phi i8 [ %74, %75 ], [ 0, %57 ]
  %79 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %78, i64 0
  br label %80

80:                                               ; preds = %80, %76
  %81 = phi i64 [ %77, %76 ], [ %87, %80 ]
  %82 = phi <8 x i8> [ %79, %76 ], [ %86, %80 ]
  %83 = getelementptr inbounds nuw i8, ptr %0, i64 %81
  %84 = load <8 x i8>, ptr %83, align 1, !tbaa !34
  %85 = and <8 x i8> %46, %84
  %86 = add <8 x i8> %85, %82
  %87 = add nuw i64 %81, 8
  %88 = icmp eq i64 %87, %41
  br i1 %88, label %89, label %80, !llvm.loop !168

89:                                               ; preds = %80
  %90 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %86)
  br i1 %47, label %108, label %54

91:                                               ; preds = %108
  %92 = load i32, ptr @current_test, align 4, !tbaa !11
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %95

95:                                               ; preds = %91, %108
  %96 = phi i32 [ %94, %91 ], [ %52, %108 ]
  %97 = add nuw nsw i32 %53, 1
  %98 = icmp slt i32 %97, %96
  br i1 %98, label %51, label %132, !llvm.loop !169

99:                                               ; preds = %54, %99
  %100 = phi i64 [ %106, %99 ], [ %55, %54 ]
  %101 = phi i8 [ %105, %99 ], [ %56, %54 ]
  %102 = getelementptr inbounds nuw i8, ptr %0, i64 %100
  %103 = load i8, ptr %102, align 1, !tbaa !34
  %104 = and i8 %103, %50
  %105 = add i8 %104, %101
  %106 = add nuw nsw i64 %100, 1
  %107 = icmp eq i64 %106, %20
  br i1 %107, label %108, label %99, !llvm.loop !170

108:                                              ; preds = %99, %89, %72
  %109 = phi i8 [ %74, %72 ], [ %90, %89 ], [ %105, %99 ]
  %110 = load double, ptr @init_value, align 8, !tbaa !33
  %111 = fptoui double %110 to i8
  %112 = and i8 %15, %111
  %113 = shl i8 %112, 6
  %114 = icmp eq i8 %109, %113
  br i1 %114, label %95, label %91

115:                                              ; preds = %16, %127
  %116 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %117 = phi double [ %129, %127 ], [ %17, %16 ]
  %118 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %119 = fptoui double %117 to i8
  %120 = and i8 %18, %119
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %115
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %115, %122
  %128 = phi i32 [ %116, %115 ], [ %126, %122 ]
  %129 = phi double [ %117, %115 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %118, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %115, label %132, !llvm.loop !169

132:                                              ; preds = %127, %95, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = or <16 x i8> %39, %18
  %42 = or <16 x i8> %40, %18
  %43 = add <16 x i8> %41, %35
  %44 = add <16 x i8> %42, %36
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !171

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = or <8 x i8> %59, %24
  %61 = add <8 x i8> %60, %57
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !172

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !173

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = or i8 %78, %2
  %80 = add i8 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !174

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i8
  %87 = or i8 %2, %86
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i8
  %95 = or i8 %2, %94
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !173

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = or i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i8 %2, %12
  %15 = or i8 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %4, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %5, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = insertelement <16 x i8> poison, i8 %2, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = insertelement <16 x i8> poison, i8 %3, i64 0
  %30 = shufflevector <16 x i8> %29, <16 x i8> poison, <16 x i32> zeroinitializer
  %31 = or <16 x i8> %24, %26
  %32 = or <16 x i8> %24, %26
  %33 = or <16 x i8> %31, %28
  %34 = or <16 x i8> %32, %28
  %35 = or <16 x i8> %33, %30
  %36 = or <16 x i8> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 24
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483640
  %41 = or i8 %5, %4
  %42 = or i8 %2, %41
  %43 = or i8 %3, %42
  %44 = insertelement <8 x i8> poison, i8 %43, i64 0
  %45 = shufflevector <8 x i8> %44, <8 x i8> poison, <8 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = or i8 %4, %5
  %48 = or i8 %47, %2
  %49 = or i8 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i8 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <16 x i8> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <16 x i8> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i8, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <16 x i8>, ptr %61, align 1, !tbaa !34
  %64 = load <16 x i8>, ptr %62, align 1, !tbaa !34
  %65 = or <16 x i8> %63, %35
  %66 = or <16 x i8> %64, %36
  %67 = add <16 x i8> %65, %59
  %68 = add <16 x i8> %66, %60
  %69 = add nuw i64 %58, 32
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !175

71:                                               ; preds = %57
  %72 = add <16 x i8> %68, %67
  %73 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i8 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <8 x i8> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i8, ptr %0, i64 %80
  %83 = load <8 x i8>, ptr %82, align 1, !tbaa !34
  %84 = or <8 x i8> %45, %83
  %85 = add <8 x i8> %84, %81
  %86 = add nuw i64 %80, 8
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !176

88:                                               ; preds = %79
  %89 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !177

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i8 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i8, ptr %0, i64 %99
  %102 = load i8, ptr %101, align 1, !tbaa !34
  %103 = or i8 %102, %49
  %104 = add i8 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !178

107:                                              ; preds = %98, %88, %71
  %108 = phi i8 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptoui double %109 to i8
  %111 = or i8 %15, %110
  %112 = shl i8 %111, 6
  %113 = icmp eq i8 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptoui double %116 to i8
  %119 = or i8 %15, %118
  %120 = and i8 %119, 3
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !177

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 2147483616
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483640
  %23 = insertelement <8 x i8> poison, i8 %2, i64 0
  %24 = shufflevector <8 x i8> %23, <8 x i8> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i8 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i8, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <16 x i8>, ptr %37, align 1, !tbaa !34
  %40 = load <16 x i8>, ptr %38, align 1, !tbaa !34
  %41 = xor <16 x i8> %39, %18
  %42 = xor <16 x i8> %40, %18
  %43 = add <16 x i8> %41, %35
  %44 = add <16 x i8> %42, %36
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !179

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i8 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !34
  %60 = xor <8 x i8> %59, %24
  %61 = add <8 x i8> %60, %57
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !180

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !181

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i8 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i8, ptr %0, i64 %75
  %78 = load i8, ptr %77, align 1, !tbaa !34
  %79 = xor i8 %78, %2
  %80 = add i8 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !182

83:                                               ; preds = %74, %64, %47
  %84 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i8
  %87 = xor i8 %2, %86
  %88 = shl i8 %87, 6
  %89 = icmp eq i8 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i8
  %95 = xor i8 %2, %94
  %96 = and i8 %95, 3
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !181

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef %2, i8 noundef %3, i8 noundef %4, i8 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = xor i8 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i8 %2, %12
  %15 = xor i8 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 2147483616
  %23 = insertelement <16 x i8> poison, i8 %4, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %5, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = insertelement <16 x i8> poison, i8 %2, i64 0
  %28 = shufflevector <16 x i8> %27, <16 x i8> poison, <16 x i32> zeroinitializer
  %29 = insertelement <16 x i8> poison, i8 %3, i64 0
  %30 = shufflevector <16 x i8> %29, <16 x i8> poison, <16 x i32> zeroinitializer
  %31 = xor <16 x i8> %24, %26
  %32 = xor <16 x i8> %24, %26
  %33 = xor <16 x i8> %31, %28
  %34 = xor <16 x i8> %32, %28
  %35 = xor <16 x i8> %33, %30
  %36 = xor <16 x i8> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 24
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483640
  %41 = xor i8 %5, %4
  %42 = xor i8 %2, %41
  %43 = xor i8 %3, %42
  %44 = insertelement <8 x i8> poison, i8 %43, i64 0
  %45 = shufflevector <8 x i8> %44, <8 x i8> poison, <8 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = xor i8 %4, %5
  %48 = xor i8 %47, %2
  %49 = xor i8 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i8 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <16 x i8> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <16 x i8> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i8, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <16 x i8>, ptr %61, align 1, !tbaa !34
  %64 = load <16 x i8>, ptr %62, align 1, !tbaa !34
  %65 = xor <16 x i8> %63, %35
  %66 = xor <16 x i8> %64, %36
  %67 = add <16 x i8> %65, %59
  %68 = add <16 x i8> %66, %60
  %69 = add nuw i64 %58, 32
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !183

71:                                               ; preds = %57
  %72 = add <16 x i8> %68, %67
  %73 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i8 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <8 x i8> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i8, ptr %0, i64 %80
  %83 = load <8 x i8>, ptr %82, align 1, !tbaa !34
  %84 = xor <8 x i8> %45, %83
  %85 = add <8 x i8> %84, %81
  %86 = add nuw i64 %80, 8
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !184

88:                                               ; preds = %79
  %89 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !185

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i8 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i8, ptr %0, i64 %99
  %102 = load i8, ptr %101, align 1, !tbaa !34
  %103 = xor i8 %102, %49
  %104 = add i8 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !186

107:                                              ; preds = %98, %88, %71
  %108 = phi i8 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptoui double %109 to i8
  %111 = xor i8 %15, %110
  %112 = shl i8 %111, 6
  %113 = icmp eq i8 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptoui double %116 to i8
  %119 = xor i8 %15, %118
  %120 = and i8 %119, 3
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !185

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = add <8 x i16> %35, %18
  %42 = add <8 x i16> %36, %18
  %43 = add <8 x i16> %41, %39
  %44 = add <8 x i16> %42, %40
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !187

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = add <4 x i16> %57, %24
  %61 = add <4 x i16> %60, %59
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !188

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !189

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = add i16 %76, %2
  %80 = add i16 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !190

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i16
  %87 = add i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i16
  %95 = add i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !189

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %103

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i16
  %11 = mul i16 %2, %10
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !33
  br label %85

14:                                               ; preds = %8
  %15 = zext nneg i32 %1 to i64
  %16 = icmp ult i32 %1, 4
  %17 = icmp ult i32 %1, 16
  %18 = and i64 %15, 2147483632
  %19 = icmp eq i64 %18, %15
  %20 = and i64 %15, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %15, 2147483644
  %23 = icmp eq i64 %22, %15
  br label %24

24:                                               ; preds = %14, %65
  %25 = phi i32 [ %66, %65 ], [ %6, %14 ]
  %26 = phi i32 [ %67, %65 ], [ 0, %14 ]
  br i1 %16, label %27, label %30

27:                                               ; preds = %46, %59, %24
  %28 = phi i64 [ 0, %24 ], [ %18, %46 ], [ %22, %59 ]
  %29 = phi i16 [ 0, %24 ], [ %45, %46 ], [ %60, %59 ]
  br label %69

30:                                               ; preds = %24
  br i1 %17, label %47, label %31

31:                                               ; preds = %30, %31
  %32 = phi i64 [ %41, %31 ], [ 0, %30 ]
  %33 = phi <8 x i16> [ %39, %31 ], [ zeroinitializer, %30 ]
  %34 = phi <8 x i16> [ %40, %31 ], [ zeroinitializer, %30 ]
  %35 = getelementptr inbounds nuw i16, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <8 x i16>, ptr %35, align 2, !tbaa !35
  %38 = load <8 x i16>, ptr %36, align 2, !tbaa !35
  %39 = add <8 x i16> %37, %33
  %40 = add <8 x i16> %38, %34
  %41 = add nuw i64 %32, 16
  %42 = icmp eq i64 %41, %18
  br i1 %42, label %43, label %31, !llvm.loop !191

43:                                               ; preds = %31
  %44 = add <8 x i16> %40, %39
  %45 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %44)
  br i1 %19, label %77, label %46

46:                                               ; preds = %43
  br i1 %21, label %27, label %47

47:                                               ; preds = %46, %30
  %48 = phi i64 [ %18, %46 ], [ 0, %30 ]
  %49 = phi i16 [ %45, %46 ], [ 0, %30 ]
  %50 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %49, i64 0
  br label %51

51:                                               ; preds = %51, %47
  %52 = phi i64 [ %48, %47 ], [ %57, %51 ]
  %53 = phi <4 x i16> [ %50, %47 ], [ %56, %51 ]
  %54 = getelementptr inbounds nuw i16, ptr %0, i64 %52
  %55 = load <4 x i16>, ptr %54, align 2, !tbaa !35
  %56 = add <4 x i16> %55, %53
  %57 = add nuw i64 %52, 4
  %58 = icmp eq i64 %57, %22
  br i1 %58, label %59, label %51, !llvm.loop !192

59:                                               ; preds = %51
  %60 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %56)
  br i1 %23, label %77, label %27

61:                                               ; preds = %77
  %62 = load i32, ptr @current_test, align 4, !tbaa !11
  %63 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %62)
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %65

65:                                               ; preds = %61, %77
  %66 = phi i32 [ %64, %61 ], [ %25, %77 ]
  %67 = add nuw nsw i32 %26, 1
  %68 = icmp slt i32 %67, %66
  br i1 %68, label %24, label %103, !llvm.loop !193

69:                                               ; preds = %27, %69
  %70 = phi i64 [ %75, %69 ], [ %28, %27 ]
  %71 = phi i16 [ %74, %69 ], [ %29, %27 ]
  %72 = getelementptr inbounds nuw i16, ptr %0, i64 %70
  %73 = load i16, ptr %72, align 2, !tbaa !35
  %74 = add i16 %73, %71
  %75 = add nuw nsw i64 %70, 1
  %76 = icmp eq i64 %75, %15
  br i1 %76, label %77, label %69, !llvm.loop !194

77:                                               ; preds = %69, %59, %43
  %78 = phi i16 [ %45, %43 ], [ %60, %59 ], [ %74, %69 ]
  %79 = add i16 %78, %11
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = fptosi double %80 to i16
  %82 = add i16 %2, %81
  %83 = mul i16 %82, 8000
  %84 = icmp eq i16 %79, %83
  br i1 %84, label %65, label %61

85:                                               ; preds = %12, %98
  %86 = phi i32 [ %99, %98 ], [ %6, %12 ]
  %87 = phi double [ %100, %98 ], [ %13, %12 ]
  %88 = phi i32 [ %101, %98 ], [ 0, %12 ]
  %89 = fptosi double %87 to i16
  %90 = add i16 %2, %89
  %91 = mul i16 %90, 8000
  %92 = icmp eq i16 %11, %91
  br i1 %92, label %98, label %93

93:                                               ; preds = %85
  %94 = load i32, ptr @current_test, align 4, !tbaa !11
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %98

98:                                               ; preds = %85, %93
  %99 = phi i32 [ %86, %85 ], [ %97, %93 ]
  %100 = phi double [ %87, %85 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %88, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %85, label %103, !llvm.loop !193

103:                                              ; preds = %98, %65, %4
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !30
  %105 = load i64, ptr @start_time, align 8, !tbaa !30
  %106 = load ptr, ptr @results, align 8, !tbaa !6
  %107 = icmp ne ptr %106, null
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = load i32, ptr @current_test, align 4
  %110 = icmp slt i32 %109, %108
  %111 = select i1 %107, i1 %110, i1 false
  br i1 %111, label %123, label %112

112:                                              ; preds = %103
  %113 = add nsw i32 %108, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !11
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %106, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !6
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %112
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %123

120:                                              ; preds = %112
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %103, %118
  %124 = phi i32 [ %119, %118 ], [ %109, %103 ]
  %125 = phi ptr [ %116, %118 ], [ %106, %103 ]
  %126 = sub nsw i64 %104, %105
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !13
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %3, ptr %131, align 8, !tbaa !17
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i16 %3, %2
  %15 = add i16 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %15, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 12
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483644
  %29 = insertelement <4 x i16> poison, i16 %15, i64 0
  %30 = shufflevector <4 x i16> %29, <4 x i16> poison, <4 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i16 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <8 x i16> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <8 x i16> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i16, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <8 x i16>, ptr %43, align 2, !tbaa !35
  %46 = load <8 x i16>, ptr %44, align 2, !tbaa !35
  %47 = add <8 x i16> %24, %41
  %48 = add <8 x i16> %24, %42
  %49 = add <8 x i16> %47, %45
  %50 = add <8 x i16> %48, %46
  %51 = add nuw i64 %40, 16
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !195

53:                                               ; preds = %39
  %54 = add <8 x i16> %50, %49
  %55 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i16 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <4 x i16> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i16, ptr %0, i64 %62
  %65 = load <4 x i16>, ptr %64, align 2, !tbaa !35
  %66 = add <4 x i16> %30, %63
  %67 = add <4 x i16> %66, %65
  %68 = add nuw i64 %62, 4
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !196

70:                                               ; preds = %61
  %71 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !197

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i16 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i16, ptr %0, i64 %81
  %84 = load i16, ptr %83, align 2, !tbaa !35
  %85 = add i16 %15, %82
  %86 = add i16 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !198

89:                                               ; preds = %80, %70, %53
  %90 = phi i16 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptosi double %91 to i16
  %93 = add i16 %15, %92
  %94 = mul i16 %93, 8000
  %95 = icmp eq i16 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptosi double %98 to i16
  %101 = add i16 %15, %100
  %102 = mul i16 %101, 8000
  %103 = icmp eq i16 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !197

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = sub <8 x i16> %35, %18
  %42 = sub <8 x i16> %36, %18
  %43 = add <8 x i16> %41, %39
  %44 = add <8 x i16> %42, %40
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !199

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = sub <4 x i16> %57, %24
  %61 = add <4 x i16> %60, %59
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !200

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !201

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = sub i16 %76, %2
  %80 = add i16 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !202

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i16
  %87 = sub i16 %86, %2
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i16
  %95 = sub i16 %94, %2
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !201

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i16 %3, %2
  %15 = add i16 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %15, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 12
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483644
  %29 = insertelement <4 x i16> poison, i16 %15, i64 0
  %30 = shufflevector <4 x i16> %29, <4 x i16> poison, <4 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i16 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <8 x i16> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <8 x i16> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i16, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <8 x i16>, ptr %43, align 2, !tbaa !35
  %46 = load <8 x i16>, ptr %44, align 2, !tbaa !35
  %47 = sub <8 x i16> %41, %24
  %48 = sub <8 x i16> %42, %24
  %49 = add <8 x i16> %47, %45
  %50 = add <8 x i16> %48, %46
  %51 = add nuw i64 %40, 16
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !203

53:                                               ; preds = %39
  %54 = add <8 x i16> %50, %49
  %55 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i16 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <4 x i16> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i16, ptr %0, i64 %62
  %65 = load <4 x i16>, ptr %64, align 2, !tbaa !35
  %66 = sub <4 x i16> %63, %30
  %67 = add <4 x i16> %66, %65
  %68 = add nuw i64 %62, 4
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !204

70:                                               ; preds = %61
  %71 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !205

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i16 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i16, ptr %0, i64 %81
  %84 = load i16, ptr %83, align 2, !tbaa !35
  %85 = sub i16 %82, %15
  %86 = add i16 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !206

89:                                               ; preds = %80, %70, %53
  %90 = phi i16 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptosi double %91 to i16
  %93 = sub i16 %92, %15
  %94 = mul i16 %93, 8000
  %95 = icmp eq i16 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptosi double %98 to i16
  %101 = sub i16 %100, %15
  %102 = mul i16 %101, 8000
  %103 = icmp eq i16 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !205

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %107

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i16 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 4
  %16 = icmp ult i32 %1, 16
  %17 = and i64 %14, 2147483632
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %17, %14
  %21 = and i64 %14, 12
  %22 = icmp eq i64 %21, 0
  %23 = and i64 %14, 2147483644
  %24 = insertelement <4 x i16> poison, i16 %2, i64 0
  %25 = shufflevector <4 x i16> %24, <4 x i16> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %23, %14
  br label %27

27:                                               ; preds = %13, %71
  %28 = phi i32 [ %72, %71 ], [ %6, %13 ]
  %29 = phi i32 [ %73, %71 ], [ 0, %13 ]
  br i1 %15, label %30, label %33

30:                                               ; preds = %51, %65, %27
  %31 = phi i64 [ 0, %27 ], [ %17, %51 ], [ %23, %65 ]
  %32 = phi i16 [ 0, %27 ], [ %50, %51 ], [ %66, %65 ]
  br label %75

33:                                               ; preds = %27
  br i1 %16, label %52, label %34

34:                                               ; preds = %33, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %33 ]
  %36 = phi <8 x i16> [ %44, %34 ], [ zeroinitializer, %33 ]
  %37 = phi <8 x i16> [ %45, %34 ], [ zeroinitializer, %33 ]
  %38 = getelementptr inbounds nuw i16, ptr %0, i64 %35
  %39 = getelementptr inbounds nuw i8, ptr %38, i64 16
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = load <8 x i16>, ptr %39, align 2, !tbaa !35
  %42 = mul <8 x i16> %40, %19
  %43 = mul <8 x i16> %41, %19
  %44 = add <8 x i16> %42, %36
  %45 = add <8 x i16> %43, %37
  %46 = add nuw i64 %35, 16
  %47 = icmp eq i64 %46, %17
  br i1 %47, label %48, label %34, !llvm.loop !207

48:                                               ; preds = %34
  %49 = add <8 x i16> %45, %44
  %50 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %49)
  br i1 %20, label %84, label %51

51:                                               ; preds = %48
  br i1 %22, label %30, label %52

52:                                               ; preds = %51, %33
  %53 = phi i64 [ %17, %51 ], [ 0, %33 ]
  %54 = phi i16 [ %50, %51 ], [ 0, %33 ]
  %55 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %54, i64 0
  br label %56

56:                                               ; preds = %56, %52
  %57 = phi i64 [ %53, %52 ], [ %63, %56 ]
  %58 = phi <4 x i16> [ %55, %52 ], [ %62, %56 ]
  %59 = getelementptr inbounds nuw i16, ptr %0, i64 %57
  %60 = load <4 x i16>, ptr %59, align 2, !tbaa !35
  %61 = mul <4 x i16> %60, %25
  %62 = add <4 x i16> %61, %58
  %63 = add nuw i64 %57, 4
  %64 = icmp eq i64 %63, %23
  br i1 %64, label %65, label %56, !llvm.loop !208

65:                                               ; preds = %56
  %66 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %62)
  br i1 %26, label %84, label %30

67:                                               ; preds = %84
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %68)
  %70 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %71

71:                                               ; preds = %67, %84
  %72 = phi i32 [ %70, %67 ], [ %28, %84 ]
  %73 = add nuw nsw i32 %29, 1
  %74 = icmp slt i32 %73, %72
  br i1 %74, label %27, label %107, !llvm.loop !209

75:                                               ; preds = %30, %75
  %76 = phi i64 [ %82, %75 ], [ %31, %30 ]
  %77 = phi i16 [ %81, %75 ], [ %32, %30 ]
  %78 = getelementptr inbounds nuw i16, ptr %0, i64 %76
  %79 = load i16, ptr %78, align 2, !tbaa !35
  %80 = mul i16 %79, %2
  %81 = add i16 %80, %77
  %82 = add nuw nsw i64 %76, 1
  %83 = icmp eq i64 %82, %14
  br i1 %83, label %84, label %75, !llvm.loop !210

84:                                               ; preds = %75, %65, %48
  %85 = phi i16 [ %50, %48 ], [ %66, %65 ], [ %81, %75 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = fptosi double %86 to i16
  %88 = mul i16 %10, %87
  %89 = icmp eq i16 %85, %88
  br i1 %89, label %71, label %67

90:                                               ; preds = %11, %102
  %91 = phi i32 [ %103, %102 ], [ %6, %11 ]
  %92 = phi double [ %104, %102 ], [ %12, %11 ]
  %93 = phi i32 [ %105, %102 ], [ 0, %11 ]
  %94 = fptosi double %92 to i16
  %95 = mul i16 %10, %94
  %96 = icmp eq i16 %95, 0
  br i1 %96, label %102, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %98)
  %100 = load double, ptr @init_value, align 8, !tbaa !33
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %90, %97
  %103 = phi i32 [ %91, %90 ], [ %101, %97 ]
  %104 = phi double [ %92, %90 ], [ %100, %97 ]
  %105 = add nuw nsw i32 %93, 1
  %106 = icmp slt i32 %105, %103
  br i1 %106, label %90, label %107, !llvm.loop !209

107:                                              ; preds = %102, %71, %4
  %108 = tail call i64 @clock() #17
  store i64 %108, ptr @end_time, align 8, !tbaa !30
  %109 = load i64, ptr @start_time, align 8, !tbaa !30
  %110 = load ptr, ptr @results, align 8, !tbaa !6
  %111 = icmp ne ptr %110, null
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = load i32, ptr @current_test, align 4
  %114 = icmp slt i32 %113, %112
  %115 = select i1 %111, i1 %114, i1 false
  br i1 %115, label %127, label %116

116:                                              ; preds = %107
  %117 = add nsw i32 %112, 10
  store i32 %117, ptr @allocated_results, align 4, !tbaa !11
  %118 = sext i32 %117 to i64
  %119 = shl nsw i64 %118, 4
  %120 = tail call ptr @realloc(ptr noundef %110, i64 noundef %119) #14
  store ptr %120, ptr @results, align 8, !tbaa !6
  %121 = icmp eq ptr %120, null
  br i1 %121, label %124, label %122

122:                                              ; preds = %116
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %127

124:                                              ; preds = %116
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %126 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %125)
  tail call void @exit(i32 noundef -1) #15
  unreachable

127:                                              ; preds = %107, %122
  %128 = phi i32 [ %123, %122 ], [ %113, %107 ]
  %129 = phi ptr [ %120, %122 ], [ %110, %107 ]
  %130 = sub nsw i64 %108, %109
  %131 = sitofp i64 %130 to double
  %132 = fdiv double %131, 1.000000e+06
  %133 = sext i32 %128 to i64
  %134 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133
  store double %132, ptr %134, align 8, !tbaa !13
  %135 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133, i32 1
  store ptr %3, ptr %135, align 8, !tbaa !17
  %136 = add nsw i32 %128, 1
  store i32 %136, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = mul i16 %3, 8000
  %13 = mul i16 %12, %4
  %14 = mul i16 %13, %5
  %15 = mul i16 %3, %5
  %16 = mul i16 %15, %2
  %17 = mul i16 %16, %4
  %18 = icmp sgt i32 %1, 0
  %19 = mul i16 %14, %2
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 4
  %25 = icmp ult i32 %1, 16
  %26 = and i64 %23, 2147483632
  %27 = insertelement <8 x i16> poison, i16 %17, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 12
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483644
  %33 = insertelement <4 x i16> poison, i16 %17, i64 0
  %34 = shufflevector <4 x i16> %33, <4 x i16> poison, <4 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %22, %80
  %37 = phi i32 [ %81, %80 ], [ %9, %22 ]
  %38 = phi i32 [ %82, %80 ], [ 0, %22 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i16 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <8 x i16> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <8 x i16> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i16, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <8 x i16>, ptr %47, align 2, !tbaa !35
  %50 = load <8 x i16>, ptr %48, align 2, !tbaa !35
  %51 = mul <8 x i16> %28, %49
  %52 = mul <8 x i16> %28, %50
  %53 = add <8 x i16> %51, %45
  %54 = add <8 x i16> %52, %46
  %55 = add nuw i64 %44, 16
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !211

57:                                               ; preds = %43
  %58 = add <8 x i16> %54, %53
  %59 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i16 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <4 x i16> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i16, ptr %0, i64 %66
  %69 = load <4 x i16>, ptr %68, align 2, !tbaa !35
  %70 = mul <4 x i16> %34, %69
  %71 = add <4 x i16> %70, %67
  %72 = add nuw i64 %66, 4
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !212

74:                                               ; preds = %65
  %75 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %116, !llvm.loop !213

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i16 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i16, ptr %0, i64 %85
  %88 = load i16, ptr %87, align 2, !tbaa !35
  %89 = mul i16 %17, %88
  %90 = add i16 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !214

93:                                               ; preds = %84, %74, %57
  %94 = phi i16 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptosi double %95 to i16
  %97 = mul i16 %19, %96
  %98 = icmp eq i16 %94, %97
  br i1 %98, label %80, label %76

99:                                               ; preds = %20, %111
  %100 = phi i32 [ %112, %111 ], [ %9, %20 ]
  %101 = phi double [ %113, %111 ], [ %21, %20 ]
  %102 = phi i32 [ %114, %111 ], [ 0, %20 ]
  %103 = fptosi double %101 to i16
  %104 = mul i16 %19, %103
  %105 = icmp eq i16 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %99
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %99, %106
  %112 = phi i32 [ %100, %99 ], [ %110, %106 ]
  %113 = phi double [ %101, %99 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %102, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %99, label %116, !llvm.loop !213

116:                                              ; preds = %111, %80, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %117

11:                                               ; preds = %7
  %12 = mul i16 %3, %4
  %13 = mul i16 %12, %5
  %14 = mul i16 %3, %5
  %15 = mul i16 %14, %2
  %16 = mul i16 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i16 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 4
  %24 = icmp ult i32 %1, 16
  %25 = and i64 %22, 2147483632
  %26 = insertelement <8 x i16> poison, i16 %16, i64 0
  %27 = shufflevector <8 x i16> %26, <8 x i16> poison, <8 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %22
  %29 = and i64 %22, 12
  %30 = icmp eq i64 %29, 0
  %31 = and i64 %22, 2147483644
  %32 = insertelement <4 x i16> poison, i16 %16, i64 0
  %33 = shufflevector <4 x i16> %32, <4 x i16> poison, <4 x i32> zeroinitializer
  %34 = icmp eq i64 %31, %22
  br label %35

35:                                               ; preds = %21, %79
  %36 = phi i32 [ %80, %79 ], [ %9, %21 ]
  %37 = phi i32 [ %81, %79 ], [ 0, %21 ]
  br i1 %23, label %38, label %41

38:                                               ; preds = %59, %73, %35
  %39 = phi i64 [ 0, %35 ], [ %25, %59 ], [ %31, %73 ]
  %40 = phi i16 [ 0, %35 ], [ %58, %59 ], [ %74, %73 ]
  br label %83

41:                                               ; preds = %35
  br i1 %24, label %60, label %42

42:                                               ; preds = %41, %42
  %43 = phi i64 [ %54, %42 ], [ 0, %41 ]
  %44 = phi <8 x i16> [ %52, %42 ], [ zeroinitializer, %41 ]
  %45 = phi <8 x i16> [ %53, %42 ], [ zeroinitializer, %41 ]
  %46 = getelementptr inbounds nuw i16, ptr %0, i64 %43
  %47 = getelementptr inbounds nuw i8, ptr %46, i64 16
  %48 = load <8 x i16>, ptr %46, align 2, !tbaa !35
  %49 = load <8 x i16>, ptr %47, align 2, !tbaa !35
  %50 = add <8 x i16> %44, %27
  %51 = add <8 x i16> %45, %27
  %52 = add <8 x i16> %50, %48
  %53 = add <8 x i16> %51, %49
  %54 = add nuw i64 %43, 16
  %55 = icmp eq i64 %54, %25
  br i1 %55, label %56, label %42, !llvm.loop !215

56:                                               ; preds = %42
  %57 = add <8 x i16> %53, %52
  %58 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %57)
  br i1 %28, label %92, label %59

59:                                               ; preds = %56
  br i1 %30, label %38, label %60

60:                                               ; preds = %59, %41
  %61 = phi i64 [ %25, %59 ], [ 0, %41 ]
  %62 = phi i16 [ %58, %59 ], [ 0, %41 ]
  %63 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %62, i64 0
  br label %64

64:                                               ; preds = %64, %60
  %65 = phi i64 [ %61, %60 ], [ %71, %64 ]
  %66 = phi <4 x i16> [ %63, %60 ], [ %70, %64 ]
  %67 = getelementptr inbounds nuw i16, ptr %0, i64 %65
  %68 = load <4 x i16>, ptr %67, align 2, !tbaa !35
  %69 = add <4 x i16> %66, %33
  %70 = add <4 x i16> %69, %68
  %71 = add nuw i64 %65, 4
  %72 = icmp eq i64 %71, %31
  br i1 %72, label %73, label %64, !llvm.loop !216

73:                                               ; preds = %64
  %74 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %70)
  br i1 %34, label %92, label %38

75:                                               ; preds = %92
  %76 = load i32, ptr @current_test, align 4, !tbaa !11
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %75, %92
  %80 = phi i32 [ %78, %75 ], [ %36, %92 ]
  %81 = add nuw nsw i32 %37, 1
  %82 = icmp slt i32 %81, %80
  br i1 %82, label %35, label %117, !llvm.loop !217

83:                                               ; preds = %38, %83
  %84 = phi i64 [ %90, %83 ], [ %39, %38 ]
  %85 = phi i16 [ %89, %83 ], [ %40, %38 ]
  %86 = getelementptr inbounds nuw i16, ptr %0, i64 %84
  %87 = load i16, ptr %86, align 2, !tbaa !35
  %88 = add i16 %85, %16
  %89 = add i16 %88, %87
  %90 = add nuw nsw i64 %84, 1
  %91 = icmp eq i64 %90, %22
  br i1 %91, label %92, label %83, !llvm.loop !218

92:                                               ; preds = %83, %73, %56
  %93 = phi i16 [ %58, %56 ], [ %74, %73 ], [ %89, %83 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !33
  %95 = fptosi double %94 to i16
  %96 = add i16 %18, %95
  %97 = mul i16 %96, 8000
  %98 = icmp eq i16 %93, %97
  br i1 %98, label %79, label %75

99:                                               ; preds = %19, %112
  %100 = phi i32 [ %113, %112 ], [ %9, %19 ]
  %101 = phi double [ %114, %112 ], [ %20, %19 ]
  %102 = phi i32 [ %115, %112 ], [ 0, %19 ]
  %103 = fptosi double %101 to i16
  %104 = add i16 %18, %103
  %105 = mul i16 %104, 8000
  %106 = icmp eq i16 %105, 0
  br i1 %106, label %112, label %107

107:                                              ; preds = %99
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %108)
  %110 = load double, ptr @init_value, align 8, !tbaa !33
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %99, %107
  %113 = phi i32 [ %100, %99 ], [ %111, %107 ]
  %114 = phi double [ %101, %99 ], [ %110, %107 ]
  %115 = add nuw nsw i32 %102, 1
  %116 = icmp slt i32 %115, %113
  br i1 %116, label %99, label %117, !llvm.loop !217

117:                                              ; preds = %112, %79, %7
  %118 = tail call i64 @clock() #17
  store i64 %118, ptr @end_time, align 8, !tbaa !30
  %119 = load i64, ptr @start_time, align 8, !tbaa !30
  %120 = load ptr, ptr @results, align 8, !tbaa !6
  %121 = icmp ne ptr %120, null
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = load i32, ptr @current_test, align 4
  %124 = icmp slt i32 %123, %122
  %125 = select i1 %121, i1 %124, i1 false
  br i1 %125, label %137, label %126

126:                                              ; preds = %117
  %127 = add nsw i32 %122, 10
  store i32 %127, ptr @allocated_results, align 4, !tbaa !11
  %128 = sext i32 %127 to i64
  %129 = shl nsw i64 %128, 4
  %130 = tail call ptr @realloc(ptr noundef %120, i64 noundef %129) #14
  store ptr %130, ptr @results, align 8, !tbaa !6
  %131 = icmp eq ptr %130, null
  br i1 %131, label %134, label %132

132:                                              ; preds = %126
  %133 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %137

134:                                              ; preds = %126
  %135 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %136 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %135)
  tail call void @exit(i32 noundef -1) #15
  unreachable

137:                                              ; preds = %117, %132
  %138 = phi i32 [ %133, %132 ], [ %123, %117 ]
  %139 = phi ptr [ %130, %132 ], [ %120, %117 ]
  %140 = sub nsw i64 %118, %119
  %141 = sitofp i64 %140 to double
  %142 = fdiv double %141, 1.000000e+06
  %143 = sext i32 %138 to i64
  %144 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143
  store double %142, ptr %144, align 8, !tbaa !13
  %145 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143, i32 1
  store ptr %6, ptr %145, align 8, !tbaa !17
  %146 = add nsw i32 %138, 1
  store i32 %146, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %93

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i16 %2 to i32
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %73

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %14, 2147483646
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %49
  %19 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %20 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %38, %21 ], [ 0, %18 ]
  %23 = phi i16 [ %36, %21 ], [ 0, %18 ]
  %24 = phi i16 [ %37, %21 ], [ 0, %18 ]
  %25 = getelementptr inbounds nuw i16, ptr %0, i64 %22
  %26 = getelementptr inbounds nuw i16, ptr %0, i64 %22
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 2
  %28 = load i16, ptr %25, align 2, !tbaa !35
  %29 = load i16, ptr %27, align 2, !tbaa !35
  %30 = sext i16 %28 to i32
  %31 = sext i16 %29 to i32
  %32 = sdiv i32 %30, %10
  %33 = sdiv i32 %31, %10
  %34 = trunc i32 %32 to i16
  %35 = trunc i32 %33 to i16
  %36 = add i16 %23, %34
  %37 = add i16 %24, %35
  %38 = add nuw i64 %22, 2
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %21, !llvm.loop !219

40:                                               ; preds = %21
  %41 = add i16 %37, %36
  br i1 %17, label %64, label %42

42:                                               ; preds = %18, %40
  %43 = phi i64 [ 0, %18 ], [ %16, %40 ]
  %44 = phi i16 [ 0, %18 ], [ %41, %40 ]
  br label %53

45:                                               ; preds = %64
  %46 = load i32, ptr @current_test, align 4, !tbaa !11
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %45, %64
  %50 = phi i32 [ %48, %45 ], [ %19, %64 ]
  %51 = add nuw nsw i32 %20, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %18, label %93, !llvm.loop !220

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %62, %53 ], [ %43, %42 ]
  %55 = phi i16 [ %61, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds nuw i16, ptr %0, i64 %54
  %57 = load i16, ptr %56, align 2, !tbaa !35
  %58 = sext i16 %57 to i32
  %59 = sdiv i32 %58, %10
  %60 = trunc i32 %59 to i16
  %61 = add i16 %55, %60
  %62 = add nuw nsw i64 %54, 1
  %63 = icmp eq i64 %62, %14
  br i1 %63, label %64, label %53, !llvm.loop !221

64:                                               ; preds = %53, %40
  %65 = phi i16 [ %41, %40 ], [ %61, %53 ]
  %66 = load double, ptr @init_value, align 8, !tbaa !33
  %67 = fptosi double %66 to i16
  %68 = sext i16 %67 to i32
  %69 = sdiv i32 %68, %10
  %70 = trunc i32 %69 to i16
  %71 = mul i16 %70, 8000
  %72 = icmp eq i16 %65, %71
  br i1 %72, label %49, label %45

73:                                               ; preds = %11, %88
  %74 = phi i32 [ %89, %88 ], [ %6, %11 ]
  %75 = phi double [ %90, %88 ], [ %12, %11 ]
  %76 = phi i32 [ %91, %88 ], [ 0, %11 ]
  %77 = fptosi double %75 to i16
  %78 = sext i16 %77 to i32
  %79 = sdiv i32 %78, %10
  %80 = trunc i32 %79 to i16
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %73
  %84 = load i32, ptr @current_test, align 4, !tbaa !11
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %88

88:                                               ; preds = %73, %83
  %89 = phi i32 [ %74, %73 ], [ %87, %83 ]
  %90 = phi double [ %75, %73 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %76, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %73, label %93, !llvm.loop !220

93:                                               ; preds = %88, %49, %4
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !30
  %95 = load i64, ptr @start_time, align 8, !tbaa !30
  %96 = load ptr, ptr @results, align 8, !tbaa !6
  %97 = icmp ne ptr %96, null
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %99 = load i32, ptr @current_test, align 4
  %100 = icmp slt i32 %99, %98
  %101 = select i1 %97, i1 %100, i1 false
  br i1 %101, label %113, label %102

102:                                              ; preds = %93
  %103 = add nsw i32 %98, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !11
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %96, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !6
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %102
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %113

110:                                              ; preds = %102
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %93, %108
  %114 = phi i32 [ %109, %108 ], [ %99, %93 ]
  %115 = phi ptr [ %106, %108 ], [ %96, %93 ]
  %116 = sub nsw i64 %94, %95
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !13
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %3, ptr %121, align 8, !tbaa !17
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i16 %2 to i32
  %14 = sext i16 %3 to i32
  %15 = sext i16 %4 to i32
  %16 = sext i16 %5 to i32
  br i1 %12, label %19, label %17

17:                                               ; preds = %11
  %18 = load double, ptr @init_value, align 8, !tbaa !33
  br label %91

19:                                               ; preds = %11
  %20 = zext nneg i32 %1 to i64
  %21 = icmp eq i32 %1, 1
  %22 = and i64 %20, 2147483646
  %23 = icmp eq i64 %22, %20
  br label %24

24:                                               ; preds = %19, %61
  %25 = phi i32 [ %62, %61 ], [ %9, %19 ]
  %26 = phi i32 [ %63, %61 ], [ 0, %19 ]
  br i1 %21, label %54, label %27

27:                                               ; preds = %24, %27
  %28 = phi i64 [ %50, %27 ], [ 0, %24 ]
  %29 = phi i16 [ %48, %27 ], [ 0, %24 ]
  %30 = phi i16 [ %49, %27 ], [ 0, %24 ]
  %31 = getelementptr inbounds nuw i16, ptr %0, i64 %28
  %32 = getelementptr inbounds nuw i16, ptr %0, i64 %28
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 2
  %34 = load i16, ptr %31, align 2, !tbaa !35
  %35 = load i16, ptr %33, align 2, !tbaa !35
  %36 = sext i16 %34 to i32
  %37 = sext i16 %35 to i32
  %38 = sdiv i32 %36, %13
  %39 = sdiv i32 %37, %13
  %40 = sdiv i32 %38, %14
  %41 = sdiv i32 %39, %14
  %42 = sdiv i32 %40, %15
  %43 = sdiv i32 %41, %15
  %44 = sdiv i32 %42, %16
  %45 = sdiv i32 %43, %16
  %46 = trunc i32 %44 to i16
  %47 = trunc i32 %45 to i16
  %48 = add i16 %29, %46
  %49 = add i16 %30, %47
  %50 = add nuw i64 %28, 2
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %27, !llvm.loop !222

52:                                               ; preds = %27
  %53 = add i16 %49, %48
  br i1 %23, label %79, label %54

54:                                               ; preds = %24, %52
  %55 = phi i64 [ 0, %24 ], [ %22, %52 ]
  %56 = phi i16 [ 0, %24 ], [ %53, %52 ]
  br label %65

57:                                               ; preds = %79
  %58 = load i32, ptr @current_test, align 4, !tbaa !11
  %59 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %58)
  %60 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %61

61:                                               ; preds = %57, %79
  %62 = phi i32 [ %60, %57 ], [ %25, %79 ]
  %63 = add nuw nsw i32 %26, 1
  %64 = icmp slt i32 %63, %62
  br i1 %64, label %24, label %114, !llvm.loop !223

65:                                               ; preds = %54, %65
  %66 = phi i64 [ %77, %65 ], [ %55, %54 ]
  %67 = phi i16 [ %76, %65 ], [ %56, %54 ]
  %68 = getelementptr inbounds nuw i16, ptr %0, i64 %66
  %69 = load i16, ptr %68, align 2, !tbaa !35
  %70 = sext i16 %69 to i32
  %71 = sdiv i32 %70, %13
  %72 = sdiv i32 %71, %14
  %73 = sdiv i32 %72, %15
  %74 = sdiv i32 %73, %16
  %75 = trunc i32 %74 to i16
  %76 = add i16 %67, %75
  %77 = add nuw nsw i64 %66, 1
  %78 = icmp eq i64 %77, %20
  br i1 %78, label %79, label %65, !llvm.loop !224

79:                                               ; preds = %65, %52
  %80 = phi i16 [ %53, %52 ], [ %76, %65 ]
  %81 = load double, ptr @init_value, align 8, !tbaa !33
  %82 = fptosi double %81 to i16
  %83 = sext i16 %82 to i32
  %84 = sdiv i32 %83, %13
  %85 = sdiv i32 %84, %14
  %86 = sdiv i32 %85, %15
  %87 = sdiv i32 %86, %16
  %88 = trunc i32 %87 to i16
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %80, %89
  br i1 %90, label %61, label %57

91:                                               ; preds = %17, %109
  %92 = phi i32 [ %110, %109 ], [ %9, %17 ]
  %93 = phi double [ %111, %109 ], [ %18, %17 ]
  %94 = phi i32 [ %112, %109 ], [ 0, %17 ]
  %95 = fptosi double %93 to i16
  %96 = sext i16 %95 to i32
  %97 = sdiv i32 %96, %13
  %98 = sdiv i32 %97, %14
  %99 = sdiv i32 %98, %15
  %100 = sdiv i32 %99, %16
  %101 = trunc i32 %100 to i16
  %102 = mul i16 %101, 8000
  %103 = icmp eq i16 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %91
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %91, %104
  %110 = phi i32 [ %92, %91 ], [ %108, %104 ]
  %111 = phi double [ %93, %91 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %94, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %91, label %114, !llvm.loop !223

114:                                              ; preds = %109, %61, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %119

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i16 %2 to i32
  %14 = sext i16 %3 to i32
  %15 = sdiv i32 %13, %14
  %16 = sext i16 %4 to i32
  %17 = sdiv i32 %15, %16
  %18 = sext i16 %5 to i32
  %19 = sdiv i32 %17, %18
  %20 = trunc i32 %19 to i16
  br i1 %12, label %23, label %21

21:                                               ; preds = %11
  %22 = load double, ptr @init_value, align 8, !tbaa !33
  br label %101

23:                                               ; preds = %11
  %24 = zext nneg i32 %1 to i64
  %25 = icmp ult i32 %1, 4
  %26 = icmp ult i32 %1, 16
  %27 = and i64 %24, 2147483632
  %28 = insertelement <8 x i16> poison, i16 %20, i64 0
  %29 = shufflevector <8 x i16> %28, <8 x i16> poison, <8 x i32> zeroinitializer
  %30 = icmp eq i64 %27, %24
  %31 = and i64 %24, 12
  %32 = icmp eq i64 %31, 0
  %33 = and i64 %24, 2147483644
  %34 = insertelement <4 x i16> poison, i16 %20, i64 0
  %35 = shufflevector <4 x i16> %34, <4 x i16> poison, <4 x i32> zeroinitializer
  %36 = icmp eq i64 %33, %24
  br label %37

37:                                               ; preds = %81, %23
  %38 = phi i32 [ %9, %23 ], [ %82, %81 ]
  %39 = phi i32 [ 0, %23 ], [ %83, %81 ]
  br i1 %25, label %40, label %43

40:                                               ; preds = %61, %75, %37
  %41 = phi i64 [ 0, %37 ], [ %27, %61 ], [ %33, %75 ]
  %42 = phi i16 [ 0, %37 ], [ %60, %61 ], [ %76, %75 ]
  br label %85

43:                                               ; preds = %37
  br i1 %26, label %62, label %44

44:                                               ; preds = %43, %44
  %45 = phi i64 [ %56, %44 ], [ 0, %43 ]
  %46 = phi <8 x i16> [ %54, %44 ], [ zeroinitializer, %43 ]
  %47 = phi <8 x i16> [ %55, %44 ], [ zeroinitializer, %43 ]
  %48 = getelementptr inbounds nuw i16, ptr %0, i64 %45
  %49 = getelementptr inbounds nuw i8, ptr %48, i64 16
  %50 = load <8 x i16>, ptr %48, align 2, !tbaa !35
  %51 = load <8 x i16>, ptr %49, align 2, !tbaa !35
  %52 = add <8 x i16> %50, %46
  %53 = add <8 x i16> %51, %47
  %54 = add <8 x i16> %52, %29
  %55 = add <8 x i16> %53, %29
  %56 = add nuw i64 %45, 16
  %57 = icmp eq i64 %56, %27
  br i1 %57, label %58, label %44, !llvm.loop !225

58:                                               ; preds = %44
  %59 = add <8 x i16> %55, %54
  %60 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %59)
  br i1 %30, label %94, label %61

61:                                               ; preds = %58
  br i1 %32, label %40, label %62

62:                                               ; preds = %61, %43
  %63 = phi i64 [ %27, %61 ], [ 0, %43 ]
  %64 = phi i16 [ %60, %61 ], [ 0, %43 ]
  %65 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %64, i64 0
  br label %66

66:                                               ; preds = %66, %62
  %67 = phi i64 [ %63, %62 ], [ %73, %66 ]
  %68 = phi <4 x i16> [ %65, %62 ], [ %72, %66 ]
  %69 = getelementptr inbounds nuw i16, ptr %0, i64 %67
  %70 = load <4 x i16>, ptr %69, align 2, !tbaa !35
  %71 = add <4 x i16> %70, %68
  %72 = add <4 x i16> %71, %35
  %73 = add nuw i64 %67, 4
  %74 = icmp eq i64 %73, %33
  br i1 %74, label %75, label %66, !llvm.loop !226

75:                                               ; preds = %66
  %76 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %72)
  br i1 %36, label %94, label %40

77:                                               ; preds = %94
  %78 = load i32, ptr @current_test, align 4, !tbaa !11
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %81

81:                                               ; preds = %77, %94
  %82 = phi i32 [ %80, %77 ], [ %38, %94 ]
  %83 = add nuw nsw i32 %39, 1
  %84 = icmp slt i32 %83, %82
  br i1 %84, label %37, label %119, !llvm.loop !227

85:                                               ; preds = %40, %85
  %86 = phi i64 [ %92, %85 ], [ %41, %40 ]
  %87 = phi i16 [ %91, %85 ], [ %42, %40 ]
  %88 = getelementptr inbounds nuw i16, ptr %0, i64 %86
  %89 = load i16, ptr %88, align 2, !tbaa !35
  %90 = add i16 %89, %87
  %91 = add i16 %90, %20
  %92 = add nuw nsw i64 %86, 1
  %93 = icmp eq i64 %92, %24
  br i1 %93, label %94, label %85, !llvm.loop !228

94:                                               ; preds = %85, %75, %58
  %95 = phi i16 [ %60, %58 ], [ %76, %75 ], [ %91, %85 ]
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = fptosi double %96 to i16
  %98 = add i16 %20, %97
  %99 = mul i16 %98, 8000
  %100 = icmp eq i16 %95, %99
  br i1 %100, label %81, label %77

101:                                              ; preds = %21, %114
  %102 = phi i32 [ %115, %114 ], [ %9, %21 ]
  %103 = phi double [ %116, %114 ], [ %22, %21 ]
  %104 = phi i32 [ %117, %114 ], [ 0, %21 ]
  %105 = fptosi double %103 to i16
  %106 = add i16 %20, %105
  %107 = mul i16 %106, 8000
  %108 = icmp eq i16 %107, 0
  br i1 %108, label %114, label %109

109:                                              ; preds = %101
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %110)
  %112 = load double, ptr @init_value, align 8, !tbaa !33
  %113 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %114

114:                                              ; preds = %101, %109
  %115 = phi i32 [ %102, %101 ], [ %113, %109 ]
  %116 = phi double [ %103, %101 ], [ %112, %109 ]
  %117 = add nuw nsw i32 %104, 1
  %118 = icmp slt i32 %117, %115
  br i1 %118, label %101, label %119, !llvm.loop !227

119:                                              ; preds = %114, %81, %7
  %120 = tail call i64 @clock() #17
  store i64 %120, ptr @end_time, align 8, !tbaa !30
  %121 = load i64, ptr @start_time, align 8, !tbaa !30
  %122 = load ptr, ptr @results, align 8, !tbaa !6
  %123 = icmp ne ptr %122, null
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %125 = load i32, ptr @current_test, align 4
  %126 = icmp slt i32 %125, %124
  %127 = select i1 %123, i1 %126, i1 false
  br i1 %127, label %139, label %128

128:                                              ; preds = %119
  %129 = add nsw i32 %124, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !11
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %122, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !6
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %128
  %135 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %139

136:                                              ; preds = %128
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %119, %134
  %140 = phi i32 [ %135, %134 ], [ %125, %119 ]
  %141 = phi ptr [ %132, %134 ], [ %122, %119 ]
  %142 = sub nsw i64 %120, %121
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !13
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !17
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %118

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i16 %3 to i32
  %14 = sext i16 %4 to i32
  %15 = mul nsw i32 %14, %13
  %16 = sext i16 %5 to i32
  %17 = sdiv i32 %15, %16
  %18 = trunc i32 %17 to i16
  %19 = sub i16 %2, %18
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %100

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 4
  %25 = icmp ult i32 %1, 16
  %26 = and i64 %23, 2147483632
  %27 = insertelement <8 x i16> poison, i16 %19, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 12
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483644
  %33 = insertelement <4 x i16> poison, i16 %19, i64 0
  %34 = shufflevector <4 x i16> %33, <4 x i16> poison, <4 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %80, %22
  %37 = phi i32 [ %9, %22 ], [ %81, %80 ]
  %38 = phi i32 [ 0, %22 ], [ %82, %80 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i16 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <8 x i16> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <8 x i16> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i16, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <8 x i16>, ptr %47, align 2, !tbaa !35
  %50 = load <8 x i16>, ptr %48, align 2, !tbaa !35
  %51 = add <8 x i16> %28, %49
  %52 = add <8 x i16> %28, %50
  %53 = add <8 x i16> %51, %45
  %54 = add <8 x i16> %52, %46
  %55 = add nuw i64 %44, 16
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !229

57:                                               ; preds = %43
  %58 = add <8 x i16> %54, %53
  %59 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i16 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <4 x i16> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i16, ptr %0, i64 %66
  %69 = load <4 x i16>, ptr %68, align 2, !tbaa !35
  %70 = add <4 x i16> %34, %69
  %71 = add <4 x i16> %70, %67
  %72 = add nuw i64 %66, 4
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !230

74:                                               ; preds = %65
  %75 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %118, !llvm.loop !231

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i16 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i16, ptr %0, i64 %85
  %88 = load i16, ptr %87, align 2, !tbaa !35
  %89 = add i16 %19, %88
  %90 = add i16 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !232

93:                                               ; preds = %84, %74, %57
  %94 = phi i16 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptosi double %95 to i16
  %97 = add i16 %19, %96
  %98 = mul i16 %97, 8000
  %99 = icmp eq i16 %94, %98
  br i1 %99, label %80, label %76

100:                                              ; preds = %20, %113
  %101 = phi i32 [ %114, %113 ], [ %9, %20 ]
  %102 = phi double [ %115, %113 ], [ %21, %20 ]
  %103 = phi i32 [ %116, %113 ], [ 0, %20 ]
  %104 = fptosi double %102 to i16
  %105 = add i16 %19, %104
  %106 = mul i16 %105, 8000
  %107 = icmp eq i16 %106, 0
  br i1 %107, label %113, label %108

108:                                              ; preds = %100
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %109)
  %111 = load double, ptr @init_value, align 8, !tbaa !33
  %112 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %113

113:                                              ; preds = %100, %108
  %114 = phi i32 [ %101, %100 ], [ %112, %108 ]
  %115 = phi double [ %102, %100 ], [ %111, %108 ]
  %116 = add nuw nsw i32 %103, 1
  %117 = icmp slt i32 %116, %114
  br i1 %117, label %100, label %118, !llvm.loop !231

118:                                              ; preds = %113, %80, %7
  %119 = tail call i64 @clock() #17
  store i64 %119, ptr @end_time, align 8, !tbaa !30
  %120 = load i64, ptr @start_time, align 8, !tbaa !30
  %121 = load ptr, ptr @results, align 8, !tbaa !6
  %122 = icmp ne ptr %121, null
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = load i32, ptr @current_test, align 4
  %125 = icmp slt i32 %124, %123
  %126 = select i1 %122, i1 %125, i1 false
  br i1 %126, label %138, label %127

127:                                              ; preds = %118
  %128 = add nsw i32 %123, 10
  store i32 %128, ptr @allocated_results, align 4, !tbaa !11
  %129 = sext i32 %128 to i64
  %130 = shl nsw i64 %129, 4
  %131 = tail call ptr @realloc(ptr noundef %121, i64 noundef %130) #14
  store ptr %131, ptr @results, align 8, !tbaa !6
  %132 = icmp eq ptr %131, null
  br i1 %132, label %135, label %133

133:                                              ; preds = %127
  %134 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %138

135:                                              ; preds = %127
  %136 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %137 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %136)
  tail call void @exit(i32 noundef -1) #15
  unreachable

138:                                              ; preds = %118, %133
  %139 = phi i32 [ %134, %133 ], [ %124, %118 ]
  %140 = phi ptr [ %131, %133 ], [ %121, %118 ]
  %141 = sub nsw i64 %119, %120
  %142 = sitofp i64 %141 to double
  %143 = fdiv double %142, 1.000000e+06
  %144 = sext i32 %139 to i64
  %145 = getelementptr inbounds %struct.one_result, ptr %140, i64 %144
  store double %143, ptr %145, align 8, !tbaa !13
  %146 = getelementptr inbounds %struct.one_result, ptr %140, i64 %144, i32 1
  store ptr %6, ptr %146, align 8, !tbaa !17
  %147 = add nsw i32 %139, 1
  store i32 %147, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = and <8 x i16> %39, %18
  %42 = and <8 x i16> %40, %18
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !233

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = and <4 x i16> %59, %24
  %61 = add <4 x i16> %60, %57
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !234

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !235

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = and i16 %78, %2
  %80 = add i16 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !236

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i16
  %87 = and i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i16
  %95 = and i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !235

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = and i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i16 %2, %12
  %15 = and i16 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %4, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = insertelement <8 x i16> poison, i16 %5, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %2, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %3, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = and <8 x i16> %24, %26
  %32 = and <8 x i16> %24, %26
  %33 = and <8 x i16> %31, %28
  %34 = and <8 x i16> %32, %28
  %35 = and <8 x i16> %33, %30
  %36 = and <8 x i16> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 12
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483644
  %41 = and i16 %5, %4
  %42 = and i16 %2, %41
  %43 = and i16 %3, %42
  %44 = insertelement <4 x i16> poison, i16 %43, i64 0
  %45 = shufflevector <4 x i16> %44, <4 x i16> poison, <4 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = and i16 %4, %5
  %48 = and i16 %47, %2
  %49 = and i16 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i16 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <8 x i16> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <8 x i16> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <8 x i16>, ptr %61, align 2, !tbaa !35
  %64 = load <8 x i16>, ptr %62, align 2, !tbaa !35
  %65 = and <8 x i16> %63, %35
  %66 = and <8 x i16> %64, %36
  %67 = add <8 x i16> %65, %59
  %68 = add <8 x i16> %66, %60
  %69 = add nuw i64 %58, 16
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !237

71:                                               ; preds = %57
  %72 = add <8 x i16> %68, %67
  %73 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i16 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <4 x i16> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i16, ptr %0, i64 %80
  %83 = load <4 x i16>, ptr %82, align 2, !tbaa !35
  %84 = and <4 x i16> %45, %83
  %85 = add <4 x i16> %84, %81
  %86 = add nuw i64 %80, 4
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !238

88:                                               ; preds = %79
  %89 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !239

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i16 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i16, ptr %0, i64 %99
  %102 = load i16, ptr %101, align 2, !tbaa !35
  %103 = and i16 %102, %49
  %104 = add i16 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !240

107:                                              ; preds = %98, %88, %71
  %108 = phi i16 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptosi double %109 to i16
  %111 = and i16 %15, %110
  %112 = mul i16 %111, 8000
  %113 = icmp eq i16 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptosi double %116 to i16
  %119 = and i16 %15, %118
  %120 = mul i16 %119, 8000
  %121 = icmp eq i16 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !239

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = or <8 x i16> %39, %18
  %42 = or <8 x i16> %40, %18
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !241

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = or <4 x i16> %59, %24
  %61 = add <4 x i16> %60, %57
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !242

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !243

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = or i16 %78, %2
  %80 = add i16 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !244

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i16
  %87 = or i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i16
  %95 = or i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !243

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = or i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i16 %2, %12
  %15 = or i16 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %4, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = insertelement <8 x i16> poison, i16 %5, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %2, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %3, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = or <8 x i16> %24, %26
  %32 = or <8 x i16> %24, %26
  %33 = or <8 x i16> %31, %28
  %34 = or <8 x i16> %32, %28
  %35 = or <8 x i16> %33, %30
  %36 = or <8 x i16> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 12
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483644
  %41 = or i16 %5, %4
  %42 = or i16 %2, %41
  %43 = or i16 %3, %42
  %44 = insertelement <4 x i16> poison, i16 %43, i64 0
  %45 = shufflevector <4 x i16> %44, <4 x i16> poison, <4 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = or i16 %4, %5
  %48 = or i16 %47, %2
  %49 = or i16 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i16 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <8 x i16> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <8 x i16> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <8 x i16>, ptr %61, align 2, !tbaa !35
  %64 = load <8 x i16>, ptr %62, align 2, !tbaa !35
  %65 = or <8 x i16> %63, %35
  %66 = or <8 x i16> %64, %36
  %67 = add <8 x i16> %65, %59
  %68 = add <8 x i16> %66, %60
  %69 = add nuw i64 %58, 16
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !245

71:                                               ; preds = %57
  %72 = add <8 x i16> %68, %67
  %73 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i16 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <4 x i16> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i16, ptr %0, i64 %80
  %83 = load <4 x i16>, ptr %82, align 2, !tbaa !35
  %84 = or <4 x i16> %45, %83
  %85 = add <4 x i16> %84, %81
  %86 = add nuw i64 %80, 4
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !246

88:                                               ; preds = %79
  %89 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !247

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i16 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i16, ptr %0, i64 %99
  %102 = load i16, ptr %101, align 2, !tbaa !35
  %103 = or i16 %102, %49
  %104 = add i16 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !248

107:                                              ; preds = %98, %88, %71
  %108 = phi i16 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptosi double %109 to i16
  %111 = or i16 %15, %110
  %112 = mul i16 %111, 8000
  %113 = icmp eq i16 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptosi double %116 to i16
  %119 = or i16 %15, %118
  %120 = mul i16 %119, 8000
  %121 = icmp eq i16 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !247

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = xor <8 x i16> %39, %18
  %42 = xor <8 x i16> %40, %18
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !249

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = xor <4 x i16> %59, %24
  %61 = add <4 x i16> %60, %57
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !250

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !251

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = xor i16 %78, %2
  %80 = add i16 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !252

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptosi double %85 to i16
  %87 = xor i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptosi double %92 to i16
  %95 = xor i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !251

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = xor i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i16 %2, %12
  %15 = xor i16 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %4, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = insertelement <8 x i16> poison, i16 %5, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %2, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %3, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = xor <8 x i16> %24, %26
  %32 = xor <8 x i16> %24, %26
  %33 = xor <8 x i16> %31, %28
  %34 = xor <8 x i16> %32, %28
  %35 = xor <8 x i16> %33, %30
  %36 = xor <8 x i16> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 12
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483644
  %41 = xor i16 %5, %4
  %42 = xor i16 %2, %41
  %43 = xor i16 %3, %42
  %44 = insertelement <4 x i16> poison, i16 %43, i64 0
  %45 = shufflevector <4 x i16> %44, <4 x i16> poison, <4 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = xor i16 %4, %5
  %48 = xor i16 %47, %2
  %49 = xor i16 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i16 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <8 x i16> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <8 x i16> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <8 x i16>, ptr %61, align 2, !tbaa !35
  %64 = load <8 x i16>, ptr %62, align 2, !tbaa !35
  %65 = xor <8 x i16> %63, %35
  %66 = xor <8 x i16> %64, %36
  %67 = add <8 x i16> %65, %59
  %68 = add <8 x i16> %66, %60
  %69 = add nuw i64 %58, 16
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !253

71:                                               ; preds = %57
  %72 = add <8 x i16> %68, %67
  %73 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i16 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <4 x i16> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i16, ptr %0, i64 %80
  %83 = load <4 x i16>, ptr %82, align 2, !tbaa !35
  %84 = xor <4 x i16> %45, %83
  %85 = add <4 x i16> %84, %81
  %86 = add nuw i64 %80, 4
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !254

88:                                               ; preds = %79
  %89 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !255

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i16 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i16, ptr %0, i64 %99
  %102 = load i16, ptr %101, align 2, !tbaa !35
  %103 = xor i16 %102, %49
  %104 = add i16 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !256

107:                                              ; preds = %98, %88, %71
  %108 = phi i16 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptosi double %109 to i16
  %111 = xor i16 %15, %110
  %112 = mul i16 %111, 8000
  %113 = icmp eq i16 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptosi double %116 to i16
  %119 = xor i16 %15, %118
  %120 = mul i16 %119, 8000
  %121 = icmp eq i16 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !255

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = add <8 x i16> %35, %18
  %42 = add <8 x i16> %36, %18
  %43 = add <8 x i16> %41, %39
  %44 = add <8 x i16> %42, %40
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !257

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = add <4 x i16> %57, %24
  %61 = add <4 x i16> %60, %59
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !258

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !259

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = add i16 %76, %2
  %80 = add i16 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !260

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i16
  %87 = add i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i16
  %95 = add i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !259

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %103

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i16
  %11 = mul i16 %2, %10
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !33
  br label %85

14:                                               ; preds = %8
  %15 = zext nneg i32 %1 to i64
  %16 = icmp ult i32 %1, 4
  %17 = icmp ult i32 %1, 16
  %18 = and i64 %15, 2147483632
  %19 = icmp eq i64 %18, %15
  %20 = and i64 %15, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %15, 2147483644
  %23 = icmp eq i64 %22, %15
  br label %24

24:                                               ; preds = %14, %65
  %25 = phi i32 [ %66, %65 ], [ %6, %14 ]
  %26 = phi i32 [ %67, %65 ], [ 0, %14 ]
  br i1 %16, label %27, label %30

27:                                               ; preds = %46, %59, %24
  %28 = phi i64 [ 0, %24 ], [ %18, %46 ], [ %22, %59 ]
  %29 = phi i16 [ 0, %24 ], [ %45, %46 ], [ %60, %59 ]
  br label %69

30:                                               ; preds = %24
  br i1 %17, label %47, label %31

31:                                               ; preds = %30, %31
  %32 = phi i64 [ %41, %31 ], [ 0, %30 ]
  %33 = phi <8 x i16> [ %39, %31 ], [ zeroinitializer, %30 ]
  %34 = phi <8 x i16> [ %40, %31 ], [ zeroinitializer, %30 ]
  %35 = getelementptr inbounds nuw i16, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <8 x i16>, ptr %35, align 2, !tbaa !35
  %38 = load <8 x i16>, ptr %36, align 2, !tbaa !35
  %39 = add <8 x i16> %37, %33
  %40 = add <8 x i16> %38, %34
  %41 = add nuw i64 %32, 16
  %42 = icmp eq i64 %41, %18
  br i1 %42, label %43, label %31, !llvm.loop !261

43:                                               ; preds = %31
  %44 = add <8 x i16> %40, %39
  %45 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %44)
  br i1 %19, label %77, label %46

46:                                               ; preds = %43
  br i1 %21, label %27, label %47

47:                                               ; preds = %46, %30
  %48 = phi i64 [ %18, %46 ], [ 0, %30 ]
  %49 = phi i16 [ %45, %46 ], [ 0, %30 ]
  %50 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %49, i64 0
  br label %51

51:                                               ; preds = %51, %47
  %52 = phi i64 [ %48, %47 ], [ %57, %51 ]
  %53 = phi <4 x i16> [ %50, %47 ], [ %56, %51 ]
  %54 = getelementptr inbounds nuw i16, ptr %0, i64 %52
  %55 = load <4 x i16>, ptr %54, align 2, !tbaa !35
  %56 = add <4 x i16> %55, %53
  %57 = add nuw i64 %52, 4
  %58 = icmp eq i64 %57, %22
  br i1 %58, label %59, label %51, !llvm.loop !262

59:                                               ; preds = %51
  %60 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %56)
  br i1 %23, label %77, label %27

61:                                               ; preds = %77
  %62 = load i32, ptr @current_test, align 4, !tbaa !11
  %63 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %62)
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %65

65:                                               ; preds = %61, %77
  %66 = phi i32 [ %64, %61 ], [ %25, %77 ]
  %67 = add nuw nsw i32 %26, 1
  %68 = icmp slt i32 %67, %66
  br i1 %68, label %24, label %103, !llvm.loop !263

69:                                               ; preds = %27, %69
  %70 = phi i64 [ %75, %69 ], [ %28, %27 ]
  %71 = phi i16 [ %74, %69 ], [ %29, %27 ]
  %72 = getelementptr inbounds nuw i16, ptr %0, i64 %70
  %73 = load i16, ptr %72, align 2, !tbaa !35
  %74 = add i16 %73, %71
  %75 = add nuw nsw i64 %70, 1
  %76 = icmp eq i64 %75, %15
  br i1 %76, label %77, label %69, !llvm.loop !264

77:                                               ; preds = %69, %59, %43
  %78 = phi i16 [ %45, %43 ], [ %60, %59 ], [ %74, %69 ]
  %79 = add i16 %78, %11
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = fptoui double %80 to i16
  %82 = add i16 %2, %81
  %83 = mul i16 %82, 8000
  %84 = icmp eq i16 %79, %83
  br i1 %84, label %65, label %61

85:                                               ; preds = %12, %98
  %86 = phi i32 [ %99, %98 ], [ %6, %12 ]
  %87 = phi double [ %100, %98 ], [ %13, %12 ]
  %88 = phi i32 [ %101, %98 ], [ 0, %12 ]
  %89 = fptoui double %87 to i16
  %90 = add i16 %2, %89
  %91 = mul i16 %90, 8000
  %92 = icmp eq i16 %11, %91
  br i1 %92, label %98, label %93

93:                                               ; preds = %85
  %94 = load i32, ptr @current_test, align 4, !tbaa !11
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %98

98:                                               ; preds = %85, %93
  %99 = phi i32 [ %86, %85 ], [ %97, %93 ]
  %100 = phi double [ %87, %85 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %88, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %85, label %103, !llvm.loop !263

103:                                              ; preds = %98, %65, %4
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !30
  %105 = load i64, ptr @start_time, align 8, !tbaa !30
  %106 = load ptr, ptr @results, align 8, !tbaa !6
  %107 = icmp ne ptr %106, null
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = load i32, ptr @current_test, align 4
  %110 = icmp slt i32 %109, %108
  %111 = select i1 %107, i1 %110, i1 false
  br i1 %111, label %123, label %112

112:                                              ; preds = %103
  %113 = add nsw i32 %108, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !11
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %106, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !6
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %112
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %123

120:                                              ; preds = %112
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %103, %118
  %124 = phi i32 [ %119, %118 ], [ %109, %103 ]
  %125 = phi ptr [ %116, %118 ], [ %106, %103 ]
  %126 = sub nsw i64 %104, %105
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !13
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %3, ptr %131, align 8, !tbaa !17
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i16 %3, %2
  %15 = add i16 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %15, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 12
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483644
  %29 = insertelement <4 x i16> poison, i16 %15, i64 0
  %30 = shufflevector <4 x i16> %29, <4 x i16> poison, <4 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i16 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <8 x i16> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <8 x i16> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i16, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <8 x i16>, ptr %43, align 2, !tbaa !35
  %46 = load <8 x i16>, ptr %44, align 2, !tbaa !35
  %47 = add <8 x i16> %24, %41
  %48 = add <8 x i16> %24, %42
  %49 = add <8 x i16> %47, %45
  %50 = add <8 x i16> %48, %46
  %51 = add nuw i64 %40, 16
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !265

53:                                               ; preds = %39
  %54 = add <8 x i16> %50, %49
  %55 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i16 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <4 x i16> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i16, ptr %0, i64 %62
  %65 = load <4 x i16>, ptr %64, align 2, !tbaa !35
  %66 = add <4 x i16> %30, %63
  %67 = add <4 x i16> %66, %65
  %68 = add nuw i64 %62, 4
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !266

70:                                               ; preds = %61
  %71 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !267

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i16 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i16, ptr %0, i64 %81
  %84 = load i16, ptr %83, align 2, !tbaa !35
  %85 = add i16 %15, %82
  %86 = add i16 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !268

89:                                               ; preds = %80, %70, %53
  %90 = phi i16 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptoui double %91 to i16
  %93 = add i16 %15, %92
  %94 = mul i16 %93, 8000
  %95 = icmp eq i16 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptoui double %98 to i16
  %101 = add i16 %15, %100
  %102 = mul i16 %101, 8000
  %103 = icmp eq i16 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !267

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = sub <8 x i16> %35, %18
  %42 = sub <8 x i16> %36, %18
  %43 = add <8 x i16> %41, %39
  %44 = add <8 x i16> %42, %40
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !269

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = sub <4 x i16> %57, %24
  %61 = add <4 x i16> %60, %59
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !270

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !271

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = sub i16 %76, %2
  %80 = add i16 %79, %78
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !272

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i16
  %87 = sub i16 %86, %2
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i16
  %95 = sub i16 %94, %2
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !271

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = add i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i16 %3, %2
  %15 = add i16 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %15, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 12
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483644
  %29 = insertelement <4 x i16> poison, i16 %15, i64 0
  %30 = shufflevector <4 x i16> %29, <4 x i16> poison, <4 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %18, %76
  %33 = phi i32 [ %77, %76 ], [ %9, %18 ]
  %34 = phi i32 [ %78, %76 ], [ 0, %18 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i16 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <8 x i16> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <8 x i16> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i16, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <8 x i16>, ptr %43, align 2, !tbaa !35
  %46 = load <8 x i16>, ptr %44, align 2, !tbaa !35
  %47 = sub <8 x i16> %41, %24
  %48 = sub <8 x i16> %42, %24
  %49 = add <8 x i16> %47, %45
  %50 = add <8 x i16> %48, %46
  %51 = add nuw i64 %40, 16
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !273

53:                                               ; preds = %39
  %54 = add <8 x i16> %50, %49
  %55 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i16 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <4 x i16> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i16, ptr %0, i64 %62
  %65 = load <4 x i16>, ptr %64, align 2, !tbaa !35
  %66 = sub <4 x i16> %63, %30
  %67 = add <4 x i16> %66, %65
  %68 = add nuw i64 %62, 4
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !274

70:                                               ; preds = %61
  %71 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !275

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i16 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i16, ptr %0, i64 %81
  %84 = load i16, ptr %83, align 2, !tbaa !35
  %85 = sub i16 %82, %15
  %86 = add i16 %85, %84
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !276

89:                                               ; preds = %80, %70, %53
  %90 = phi i16 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptoui double %91 to i16
  %93 = sub i16 %92, %15
  %94 = mul i16 %93, 8000
  %95 = icmp eq i16 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptoui double %98 to i16
  %101 = sub i16 %100, %15
  %102 = mul i16 %101, 8000
  %103 = icmp eq i16 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !275

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %107

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i16 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 4
  %16 = icmp ult i32 %1, 16
  %17 = and i64 %14, 2147483632
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %17, %14
  %21 = and i64 %14, 12
  %22 = icmp eq i64 %21, 0
  %23 = and i64 %14, 2147483644
  %24 = insertelement <4 x i16> poison, i16 %2, i64 0
  %25 = shufflevector <4 x i16> %24, <4 x i16> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %23, %14
  br label %27

27:                                               ; preds = %13, %71
  %28 = phi i32 [ %72, %71 ], [ %6, %13 ]
  %29 = phi i32 [ %73, %71 ], [ 0, %13 ]
  br i1 %15, label %30, label %33

30:                                               ; preds = %51, %65, %27
  %31 = phi i64 [ 0, %27 ], [ %17, %51 ], [ %23, %65 ]
  %32 = phi i16 [ 0, %27 ], [ %50, %51 ], [ %66, %65 ]
  br label %75

33:                                               ; preds = %27
  br i1 %16, label %52, label %34

34:                                               ; preds = %33, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %33 ]
  %36 = phi <8 x i16> [ %44, %34 ], [ zeroinitializer, %33 ]
  %37 = phi <8 x i16> [ %45, %34 ], [ zeroinitializer, %33 ]
  %38 = getelementptr inbounds nuw i16, ptr %0, i64 %35
  %39 = getelementptr inbounds nuw i8, ptr %38, i64 16
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = load <8 x i16>, ptr %39, align 2, !tbaa !35
  %42 = mul <8 x i16> %40, %19
  %43 = mul <8 x i16> %41, %19
  %44 = add <8 x i16> %42, %36
  %45 = add <8 x i16> %43, %37
  %46 = add nuw i64 %35, 16
  %47 = icmp eq i64 %46, %17
  br i1 %47, label %48, label %34, !llvm.loop !277

48:                                               ; preds = %34
  %49 = add <8 x i16> %45, %44
  %50 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %49)
  br i1 %20, label %84, label %51

51:                                               ; preds = %48
  br i1 %22, label %30, label %52

52:                                               ; preds = %51, %33
  %53 = phi i64 [ %17, %51 ], [ 0, %33 ]
  %54 = phi i16 [ %50, %51 ], [ 0, %33 ]
  %55 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %54, i64 0
  br label %56

56:                                               ; preds = %56, %52
  %57 = phi i64 [ %53, %52 ], [ %63, %56 ]
  %58 = phi <4 x i16> [ %55, %52 ], [ %62, %56 ]
  %59 = getelementptr inbounds nuw i16, ptr %0, i64 %57
  %60 = load <4 x i16>, ptr %59, align 2, !tbaa !35
  %61 = mul <4 x i16> %60, %25
  %62 = add <4 x i16> %61, %58
  %63 = add nuw i64 %57, 4
  %64 = icmp eq i64 %63, %23
  br i1 %64, label %65, label %56, !llvm.loop !278

65:                                               ; preds = %56
  %66 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %62)
  br i1 %26, label %84, label %30

67:                                               ; preds = %84
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %68)
  %70 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %71

71:                                               ; preds = %67, %84
  %72 = phi i32 [ %70, %67 ], [ %28, %84 ]
  %73 = add nuw nsw i32 %29, 1
  %74 = icmp slt i32 %73, %72
  br i1 %74, label %27, label %107, !llvm.loop !279

75:                                               ; preds = %30, %75
  %76 = phi i64 [ %82, %75 ], [ %31, %30 ]
  %77 = phi i16 [ %81, %75 ], [ %32, %30 ]
  %78 = getelementptr inbounds nuw i16, ptr %0, i64 %76
  %79 = load i16, ptr %78, align 2, !tbaa !35
  %80 = mul i16 %79, %2
  %81 = add i16 %80, %77
  %82 = add nuw nsw i64 %76, 1
  %83 = icmp eq i64 %82, %14
  br i1 %83, label %84, label %75, !llvm.loop !280

84:                                               ; preds = %75, %65, %48
  %85 = phi i16 [ %50, %48 ], [ %66, %65 ], [ %81, %75 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = fptoui double %86 to i16
  %88 = mul i16 %10, %87
  %89 = icmp eq i16 %85, %88
  br i1 %89, label %71, label %67

90:                                               ; preds = %11, %102
  %91 = phi i32 [ %103, %102 ], [ %6, %11 ]
  %92 = phi double [ %104, %102 ], [ %12, %11 ]
  %93 = phi i32 [ %105, %102 ], [ 0, %11 ]
  %94 = fptoui double %92 to i16
  %95 = mul i16 %10, %94
  %96 = icmp eq i16 %95, 0
  br i1 %96, label %102, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %98)
  %100 = load double, ptr @init_value, align 8, !tbaa !33
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %90, %97
  %103 = phi i32 [ %91, %90 ], [ %101, %97 ]
  %104 = phi double [ %92, %90 ], [ %100, %97 ]
  %105 = add nuw nsw i32 %93, 1
  %106 = icmp slt i32 %105, %103
  br i1 %106, label %90, label %107, !llvm.loop !279

107:                                              ; preds = %102, %71, %4
  %108 = tail call i64 @clock() #17
  store i64 %108, ptr @end_time, align 8, !tbaa !30
  %109 = load i64, ptr @start_time, align 8, !tbaa !30
  %110 = load ptr, ptr @results, align 8, !tbaa !6
  %111 = icmp ne ptr %110, null
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = load i32, ptr @current_test, align 4
  %114 = icmp slt i32 %113, %112
  %115 = select i1 %111, i1 %114, i1 false
  br i1 %115, label %127, label %116

116:                                              ; preds = %107
  %117 = add nsw i32 %112, 10
  store i32 %117, ptr @allocated_results, align 4, !tbaa !11
  %118 = sext i32 %117 to i64
  %119 = shl nsw i64 %118, 4
  %120 = tail call ptr @realloc(ptr noundef %110, i64 noundef %119) #14
  store ptr %120, ptr @results, align 8, !tbaa !6
  %121 = icmp eq ptr %120, null
  br i1 %121, label %124, label %122

122:                                              ; preds = %116
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %127

124:                                              ; preds = %116
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %126 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %125)
  tail call void @exit(i32 noundef -1) #15
  unreachable

127:                                              ; preds = %107, %122
  %128 = phi i32 [ %123, %122 ], [ %113, %107 ]
  %129 = phi ptr [ %120, %122 ], [ %110, %107 ]
  %130 = sub nsw i64 %108, %109
  %131 = sitofp i64 %130 to double
  %132 = fdiv double %131, 1.000000e+06
  %133 = sext i32 %128 to i64
  %134 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133
  store double %132, ptr %134, align 8, !tbaa !13
  %135 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133, i32 1
  store ptr %3, ptr %135, align 8, !tbaa !17
  %136 = add nsw i32 %128, 1
  store i32 %136, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = mul i16 %3, 8000
  %13 = mul i16 %12, %4
  %14 = mul i16 %13, %5
  %15 = mul i16 %3, %5
  %16 = mul i16 %15, %2
  %17 = mul i16 %16, %4
  %18 = icmp sgt i32 %1, 0
  %19 = mul i16 %14, %2
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 4
  %25 = icmp ult i32 %1, 16
  %26 = and i64 %23, 2147483632
  %27 = insertelement <8 x i16> poison, i16 %17, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 12
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483644
  %33 = insertelement <4 x i16> poison, i16 %17, i64 0
  %34 = shufflevector <4 x i16> %33, <4 x i16> poison, <4 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %22, %80
  %37 = phi i32 [ %81, %80 ], [ %9, %22 ]
  %38 = phi i32 [ %82, %80 ], [ 0, %22 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i16 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <8 x i16> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <8 x i16> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i16, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <8 x i16>, ptr %47, align 2, !tbaa !35
  %50 = load <8 x i16>, ptr %48, align 2, !tbaa !35
  %51 = mul <8 x i16> %28, %49
  %52 = mul <8 x i16> %28, %50
  %53 = add <8 x i16> %51, %45
  %54 = add <8 x i16> %52, %46
  %55 = add nuw i64 %44, 16
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !281

57:                                               ; preds = %43
  %58 = add <8 x i16> %54, %53
  %59 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i16 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <4 x i16> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i16, ptr %0, i64 %66
  %69 = load <4 x i16>, ptr %68, align 2, !tbaa !35
  %70 = mul <4 x i16> %34, %69
  %71 = add <4 x i16> %70, %67
  %72 = add nuw i64 %66, 4
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !282

74:                                               ; preds = %65
  %75 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %116, !llvm.loop !283

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i16 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i16, ptr %0, i64 %85
  %88 = load i16, ptr %87, align 2, !tbaa !35
  %89 = mul i16 %17, %88
  %90 = add i16 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !284

93:                                               ; preds = %84, %74, %57
  %94 = phi i16 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptoui double %95 to i16
  %97 = mul i16 %19, %96
  %98 = icmp eq i16 %94, %97
  br i1 %98, label %80, label %76

99:                                               ; preds = %20, %111
  %100 = phi i32 [ %112, %111 ], [ %9, %20 ]
  %101 = phi double [ %113, %111 ], [ %21, %20 ]
  %102 = phi i32 [ %114, %111 ], [ 0, %20 ]
  %103 = fptoui double %101 to i16
  %104 = mul i16 %19, %103
  %105 = icmp eq i16 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %99
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %99, %106
  %112 = phi i32 [ %100, %99 ], [ %110, %106 ]
  %113 = phi double [ %101, %99 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %102, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %99, label %116, !llvm.loop !283

116:                                              ; preds = %111, %80, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %117

11:                                               ; preds = %7
  %12 = mul i16 %3, %4
  %13 = mul i16 %12, %5
  %14 = mul i16 %3, %5
  %15 = mul i16 %14, %2
  %16 = mul i16 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i16 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %99

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 4
  %24 = icmp ult i32 %1, 16
  %25 = and i64 %22, 2147483632
  %26 = insertelement <8 x i16> poison, i16 %16, i64 0
  %27 = shufflevector <8 x i16> %26, <8 x i16> poison, <8 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %22
  %29 = and i64 %22, 12
  %30 = icmp eq i64 %29, 0
  %31 = and i64 %22, 2147483644
  %32 = insertelement <4 x i16> poison, i16 %16, i64 0
  %33 = shufflevector <4 x i16> %32, <4 x i16> poison, <4 x i32> zeroinitializer
  %34 = icmp eq i64 %31, %22
  br label %35

35:                                               ; preds = %21, %79
  %36 = phi i32 [ %80, %79 ], [ %9, %21 ]
  %37 = phi i32 [ %81, %79 ], [ 0, %21 ]
  br i1 %23, label %38, label %41

38:                                               ; preds = %59, %73, %35
  %39 = phi i64 [ 0, %35 ], [ %25, %59 ], [ %31, %73 ]
  %40 = phi i16 [ 0, %35 ], [ %58, %59 ], [ %74, %73 ]
  br label %83

41:                                               ; preds = %35
  br i1 %24, label %60, label %42

42:                                               ; preds = %41, %42
  %43 = phi i64 [ %54, %42 ], [ 0, %41 ]
  %44 = phi <8 x i16> [ %52, %42 ], [ zeroinitializer, %41 ]
  %45 = phi <8 x i16> [ %53, %42 ], [ zeroinitializer, %41 ]
  %46 = getelementptr inbounds nuw i16, ptr %0, i64 %43
  %47 = getelementptr inbounds nuw i8, ptr %46, i64 16
  %48 = load <8 x i16>, ptr %46, align 2, !tbaa !35
  %49 = load <8 x i16>, ptr %47, align 2, !tbaa !35
  %50 = add <8 x i16> %44, %27
  %51 = add <8 x i16> %45, %27
  %52 = add <8 x i16> %50, %48
  %53 = add <8 x i16> %51, %49
  %54 = add nuw i64 %43, 16
  %55 = icmp eq i64 %54, %25
  br i1 %55, label %56, label %42, !llvm.loop !285

56:                                               ; preds = %42
  %57 = add <8 x i16> %53, %52
  %58 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %57)
  br i1 %28, label %92, label %59

59:                                               ; preds = %56
  br i1 %30, label %38, label %60

60:                                               ; preds = %59, %41
  %61 = phi i64 [ %25, %59 ], [ 0, %41 ]
  %62 = phi i16 [ %58, %59 ], [ 0, %41 ]
  %63 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %62, i64 0
  br label %64

64:                                               ; preds = %64, %60
  %65 = phi i64 [ %61, %60 ], [ %71, %64 ]
  %66 = phi <4 x i16> [ %63, %60 ], [ %70, %64 ]
  %67 = getelementptr inbounds nuw i16, ptr %0, i64 %65
  %68 = load <4 x i16>, ptr %67, align 2, !tbaa !35
  %69 = add <4 x i16> %66, %33
  %70 = add <4 x i16> %69, %68
  %71 = add nuw i64 %65, 4
  %72 = icmp eq i64 %71, %31
  br i1 %72, label %73, label %64, !llvm.loop !286

73:                                               ; preds = %64
  %74 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %70)
  br i1 %34, label %92, label %38

75:                                               ; preds = %92
  %76 = load i32, ptr @current_test, align 4, !tbaa !11
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %75, %92
  %80 = phi i32 [ %78, %75 ], [ %36, %92 ]
  %81 = add nuw nsw i32 %37, 1
  %82 = icmp slt i32 %81, %80
  br i1 %82, label %35, label %117, !llvm.loop !287

83:                                               ; preds = %38, %83
  %84 = phi i64 [ %90, %83 ], [ %39, %38 ]
  %85 = phi i16 [ %89, %83 ], [ %40, %38 ]
  %86 = getelementptr inbounds nuw i16, ptr %0, i64 %84
  %87 = load i16, ptr %86, align 2, !tbaa !35
  %88 = add i16 %85, %16
  %89 = add i16 %88, %87
  %90 = add nuw nsw i64 %84, 1
  %91 = icmp eq i64 %90, %22
  br i1 %91, label %92, label %83, !llvm.loop !288

92:                                               ; preds = %83, %73, %56
  %93 = phi i16 [ %58, %56 ], [ %74, %73 ], [ %89, %83 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !33
  %95 = fptoui double %94 to i16
  %96 = add i16 %18, %95
  %97 = mul i16 %96, 8000
  %98 = icmp eq i16 %93, %97
  br i1 %98, label %79, label %75

99:                                               ; preds = %19, %112
  %100 = phi i32 [ %113, %112 ], [ %9, %19 ]
  %101 = phi double [ %114, %112 ], [ %20, %19 ]
  %102 = phi i32 [ %115, %112 ], [ 0, %19 ]
  %103 = fptoui double %101 to i16
  %104 = add i16 %18, %103
  %105 = mul i16 %104, 8000
  %106 = icmp eq i16 %105, 0
  br i1 %106, label %112, label %107

107:                                              ; preds = %99
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %108)
  %110 = load double, ptr @init_value, align 8, !tbaa !33
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %99, %107
  %113 = phi i32 [ %100, %99 ], [ %111, %107 ]
  %114 = phi double [ %101, %99 ], [ %110, %107 ]
  %115 = add nuw nsw i32 %102, 1
  %116 = icmp slt i32 %115, %113
  br i1 %116, label %99, label %117, !llvm.loop !287

117:                                              ; preds = %112, %79, %7
  %118 = tail call i64 @clock() #17
  store i64 %118, ptr @end_time, align 8, !tbaa !30
  %119 = load i64, ptr @start_time, align 8, !tbaa !30
  %120 = load ptr, ptr @results, align 8, !tbaa !6
  %121 = icmp ne ptr %120, null
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = load i32, ptr @current_test, align 4
  %124 = icmp slt i32 %123, %122
  %125 = select i1 %121, i1 %124, i1 false
  br i1 %125, label %137, label %126

126:                                              ; preds = %117
  %127 = add nsw i32 %122, 10
  store i32 %127, ptr @allocated_results, align 4, !tbaa !11
  %128 = sext i32 %127 to i64
  %129 = shl nsw i64 %128, 4
  %130 = tail call ptr @realloc(ptr noundef %120, i64 noundef %129) #14
  store ptr %130, ptr @results, align 8, !tbaa !6
  %131 = icmp eq ptr %130, null
  br i1 %131, label %134, label %132

132:                                              ; preds = %126
  %133 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %137

134:                                              ; preds = %126
  %135 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %136 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %135)
  tail call void @exit(i32 noundef -1) #15
  unreachable

137:                                              ; preds = %117, %132
  %138 = phi i32 [ %133, %132 ], [ %123, %117 ]
  %139 = phi ptr [ %130, %132 ], [ %120, %117 ]
  %140 = sub nsw i64 %118, %119
  %141 = sitofp i64 %140 to double
  %142 = fdiv double %141, 1.000000e+06
  %143 = sext i32 %138 to i64
  %144 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143
  store double %142, ptr %144, align 8, !tbaa !13
  %145 = getelementptr inbounds %struct.one_result, ptr %139, i64 %143, i32 1
  store ptr %6, ptr %145, align 8, !tbaa !17
  %146 = add nsw i32 %138, 1
  store i32 %146, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp eq i32 %1, 1
  %15 = and i64 %13, 2147483646
  %16 = icmp eq i64 %15, %13
  br label %17

17:                                               ; preds = %12, %44
  %18 = phi i32 [ %45, %44 ], [ %6, %12 ]
  %19 = phi i32 [ %46, %44 ], [ 0, %12 ]
  br i1 %14, label %37, label %20

20:                                               ; preds = %17, %20
  %21 = phi i64 [ %33, %20 ], [ 0, %17 ]
  %22 = phi i16 [ %31, %20 ], [ 0, %17 ]
  %23 = phi i16 [ %32, %20 ], [ 0, %17 ]
  %24 = getelementptr inbounds nuw i16, ptr %0, i64 %21
  %25 = getelementptr inbounds nuw i16, ptr %0, i64 %21
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 2
  %27 = load i16, ptr %24, align 2, !tbaa !35
  %28 = load i16, ptr %26, align 2, !tbaa !35
  %29 = udiv i16 %27, %2
  %30 = udiv i16 %28, %2
  %31 = add i16 %29, %22
  %32 = add i16 %30, %23
  %33 = add nuw i64 %21, 2
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %20, !llvm.loop !289

35:                                               ; preds = %20
  %36 = add i16 %32, %31
  br i1 %16, label %57, label %37

37:                                               ; preds = %17, %35
  %38 = phi i64 [ 0, %17 ], [ %15, %35 ]
  %39 = phi i16 [ 0, %17 ], [ %36, %35 ]
  br label %48

40:                                               ; preds = %57
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %57
  %45 = phi i32 [ %43, %40 ], [ %18, %57 ]
  %46 = add nuw nsw i32 %19, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %17, label %82, !llvm.loop !290

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %55, %48 ], [ %38, %37 ]
  %50 = phi i16 [ %54, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i16, ptr %0, i64 %49
  %52 = load i16, ptr %51, align 2, !tbaa !35
  %53 = udiv i16 %52, %2
  %54 = add i16 %53, %50
  %55 = add nuw nsw i64 %49, 1
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %57, label %48, !llvm.loop !291

57:                                               ; preds = %48, %35
  %58 = phi i16 [ %36, %35 ], [ %54, %48 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptoui double %59 to i16
  %61 = udiv i16 %60, %2
  %62 = mul i16 %61, 8000
  %63 = icmp eq i16 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %10, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %66 = phi double [ %79, %77 ], [ %11, %10 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %68 = fptoui double %66 to i16
  %69 = udiv i16 %68, %2
  %70 = mul i16 %69, 8000
  %71 = icmp eq i16 %70, 0
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !290

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp eq i32 %1, 1
  %18 = and i64 %16, 2147483646
  %19 = icmp eq i64 %18, %16
  br label %20

20:                                               ; preds = %15, %53
  %21 = phi i32 [ %54, %53 ], [ %9, %15 ]
  %22 = phi i32 [ %55, %53 ], [ 0, %15 ]
  br i1 %17, label %46, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %42, %23 ], [ 0, %20 ]
  %25 = phi i16 [ %40, %23 ], [ 0, %20 ]
  %26 = phi i16 [ %41, %23 ], [ 0, %20 ]
  %27 = getelementptr inbounds nuw i16, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i16, ptr %0, i64 %24
  %29 = getelementptr inbounds nuw i8, ptr %28, i64 2
  %30 = load i16, ptr %27, align 2, !tbaa !35
  %31 = load i16, ptr %29, align 2, !tbaa !35
  %32 = udiv i16 %30, %2
  %33 = udiv i16 %31, %2
  %34 = udiv i16 %32, %3
  %35 = udiv i16 %33, %3
  %36 = udiv i16 %34, %4
  %37 = udiv i16 %35, %4
  %38 = udiv i16 %36, %5
  %39 = udiv i16 %37, %5
  %40 = add i16 %38, %25
  %41 = add i16 %39, %26
  %42 = add nuw i64 %24, 2
  %43 = icmp eq i64 %42, %18
  br i1 %43, label %44, label %23, !llvm.loop !292

44:                                               ; preds = %23
  %45 = add i16 %41, %40
  br i1 %19, label %69, label %46

46:                                               ; preds = %20, %44
  %47 = phi i64 [ 0, %20 ], [ %18, %44 ]
  %48 = phi i16 [ 0, %20 ], [ %45, %44 ]
  br label %57

49:                                               ; preds = %69
  %50 = load i32, ptr @current_test, align 4, !tbaa !11
  %51 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %50)
  %52 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %53

53:                                               ; preds = %49, %69
  %54 = phi i32 [ %52, %49 ], [ %21, %69 ]
  %55 = add nuw nsw i32 %22, 1
  %56 = icmp slt i32 %55, %54
  br i1 %56, label %20, label %100, !llvm.loop !293

57:                                               ; preds = %46, %57
  %58 = phi i64 [ %67, %57 ], [ %47, %46 ]
  %59 = phi i16 [ %66, %57 ], [ %48, %46 ]
  %60 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %61 = load i16, ptr %60, align 2, !tbaa !35
  %62 = udiv i16 %61, %2
  %63 = udiv i16 %62, %3
  %64 = udiv i16 %63, %4
  %65 = udiv i16 %64, %5
  %66 = add i16 %65, %59
  %67 = add nuw nsw i64 %58, 1
  %68 = icmp eq i64 %67, %16
  br i1 %68, label %69, label %57, !llvm.loop !294

69:                                               ; preds = %57, %44
  %70 = phi i16 [ %45, %44 ], [ %66, %57 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptoui double %71 to i16
  %73 = udiv i16 %72, %2
  %74 = udiv i16 %73, %3
  %75 = udiv i16 %74, %4
  %76 = udiv i16 %75, %5
  %77 = mul i16 %76, 8000
  %78 = icmp eq i16 %70, %77
  br i1 %78, label %53, label %49

79:                                               ; preds = %13, %95
  %80 = phi i32 [ %96, %95 ], [ %9, %13 ]
  %81 = phi double [ %97, %95 ], [ %14, %13 ]
  %82 = phi i32 [ %98, %95 ], [ 0, %13 ]
  %83 = fptoui double %81 to i16
  %84 = udiv i16 %83, %2
  %85 = udiv i16 %84, %3
  %86 = udiv i16 %85, %4
  %87 = udiv i16 %86, %5
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %79
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !33
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %95

95:                                               ; preds = %79, %90
  %96 = phi i32 [ %80, %79 ], [ %94, %90 ]
  %97 = phi double [ %81, %79 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %82, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %79, label %100, !llvm.loop !293

100:                                              ; preds = %95, %53, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !30
  %102 = load i64, ptr @start_time, align 8, !tbaa !30
  %103 = load ptr, ptr @results, align 8, !tbaa !6
  %104 = icmp ne ptr %103, null
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = load i32, ptr @current_test, align 4
  %107 = icmp slt i32 %106, %105
  %108 = select i1 %104, i1 %107, i1 false
  br i1 %108, label %120, label %109

109:                                              ; preds = %100
  %110 = add nsw i32 %105, 10
  store i32 %110, ptr @allocated_results, align 4, !tbaa !11
  %111 = sext i32 %110 to i64
  %112 = shl nsw i64 %111, 4
  %113 = tail call ptr @realloc(ptr noundef %103, i64 noundef %112) #14
  store ptr %113, ptr @results, align 8, !tbaa !6
  %114 = icmp eq ptr %113, null
  br i1 %114, label %117, label %115

115:                                              ; preds = %109
  %116 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %120

117:                                              ; preds = %109
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %119 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %118)
  tail call void @exit(i32 noundef -1) #15
  unreachable

120:                                              ; preds = %100, %115
  %121 = phi i32 [ %116, %115 ], [ %106, %100 ]
  %122 = phi ptr [ %113, %115 ], [ %103, %100 ]
  %123 = sub nsw i64 %101, %102
  %124 = sitofp i64 %123 to double
  %125 = fdiv double %124, 1.000000e+06
  %126 = sext i32 %121 to i64
  %127 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126
  store double %125, ptr %127, align 8, !tbaa !13
  %128 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126, i32 1
  store ptr %6, ptr %128, align 8, !tbaa !17
  %129 = add nsw i32 %121, 1
  store i32 %129, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %114

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i16 %2, %3
  %14 = udiv i16 %13, %4
  %15 = udiv i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %96

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %15, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %19
  %26 = and i64 %19, 12
  %27 = icmp eq i64 %26, 0
  %28 = and i64 %19, 2147483644
  %29 = insertelement <4 x i16> poison, i16 %15, i64 0
  %30 = shufflevector <4 x i16> %29, <4 x i16> poison, <4 x i32> zeroinitializer
  %31 = icmp eq i64 %28, %19
  br label %32

32:                                               ; preds = %76, %18
  %33 = phi i32 [ %9, %18 ], [ %77, %76 ]
  %34 = phi i32 [ 0, %18 ], [ %78, %76 ]
  br i1 %20, label %35, label %38

35:                                               ; preds = %56, %70, %32
  %36 = phi i64 [ 0, %32 ], [ %22, %56 ], [ %28, %70 ]
  %37 = phi i16 [ 0, %32 ], [ %55, %56 ], [ %71, %70 ]
  br label %80

38:                                               ; preds = %32
  br i1 %21, label %57, label %39

39:                                               ; preds = %38, %39
  %40 = phi i64 [ %51, %39 ], [ 0, %38 ]
  %41 = phi <8 x i16> [ %49, %39 ], [ zeroinitializer, %38 ]
  %42 = phi <8 x i16> [ %50, %39 ], [ zeroinitializer, %38 ]
  %43 = getelementptr inbounds nuw i16, ptr %0, i64 %40
  %44 = getelementptr inbounds nuw i8, ptr %43, i64 16
  %45 = load <8 x i16>, ptr %43, align 2, !tbaa !35
  %46 = load <8 x i16>, ptr %44, align 2, !tbaa !35
  %47 = add <8 x i16> %45, %41
  %48 = add <8 x i16> %46, %42
  %49 = add <8 x i16> %47, %24
  %50 = add <8 x i16> %48, %24
  %51 = add nuw i64 %40, 16
  %52 = icmp eq i64 %51, %22
  br i1 %52, label %53, label %39, !llvm.loop !295

53:                                               ; preds = %39
  %54 = add <8 x i16> %50, %49
  %55 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %54)
  br i1 %25, label %89, label %56

56:                                               ; preds = %53
  br i1 %27, label %35, label %57

57:                                               ; preds = %56, %38
  %58 = phi i64 [ %22, %56 ], [ 0, %38 ]
  %59 = phi i16 [ %55, %56 ], [ 0, %38 ]
  %60 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %59, i64 0
  br label %61

61:                                               ; preds = %61, %57
  %62 = phi i64 [ %58, %57 ], [ %68, %61 ]
  %63 = phi <4 x i16> [ %60, %57 ], [ %67, %61 ]
  %64 = getelementptr inbounds nuw i16, ptr %0, i64 %62
  %65 = load <4 x i16>, ptr %64, align 2, !tbaa !35
  %66 = add <4 x i16> %65, %63
  %67 = add <4 x i16> %66, %30
  %68 = add nuw i64 %62, 4
  %69 = icmp eq i64 %68, %28
  br i1 %69, label %70, label %61, !llvm.loop !296

70:                                               ; preds = %61
  %71 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %67)
  br i1 %31, label %89, label %35

72:                                               ; preds = %89
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %72, %89
  %77 = phi i32 [ %75, %72 ], [ %33, %89 ]
  %78 = add nuw nsw i32 %34, 1
  %79 = icmp slt i32 %78, %77
  br i1 %79, label %32, label %114, !llvm.loop !297

80:                                               ; preds = %35, %80
  %81 = phi i64 [ %87, %80 ], [ %36, %35 ]
  %82 = phi i16 [ %86, %80 ], [ %37, %35 ]
  %83 = getelementptr inbounds nuw i16, ptr %0, i64 %81
  %84 = load i16, ptr %83, align 2, !tbaa !35
  %85 = add i16 %84, %82
  %86 = add i16 %85, %15
  %87 = add nuw nsw i64 %81, 1
  %88 = icmp eq i64 %87, %19
  br i1 %88, label %89, label %80, !llvm.loop !298

89:                                               ; preds = %80, %70, %53
  %90 = phi i16 [ %55, %53 ], [ %71, %70 ], [ %86, %80 ]
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = fptoui double %91 to i16
  %93 = add i16 %15, %92
  %94 = mul i16 %93, 8000
  %95 = icmp eq i16 %90, %94
  br i1 %95, label %76, label %72

96:                                               ; preds = %16, %109
  %97 = phi i32 [ %110, %109 ], [ %9, %16 ]
  %98 = phi double [ %111, %109 ], [ %17, %16 ]
  %99 = phi i32 [ %112, %109 ], [ 0, %16 ]
  %100 = fptoui double %98 to i16
  %101 = add i16 %15, %100
  %102 = mul i16 %101, 8000
  %103 = icmp eq i16 %102, 0
  br i1 %103, label %109, label %104

104:                                              ; preds = %96
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %105)
  %107 = load double, ptr @init_value, align 8, !tbaa !33
  %108 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %109

109:                                              ; preds = %96, %104
  %110 = phi i32 [ %97, %96 ], [ %108, %104 ]
  %111 = phi double [ %98, %96 ], [ %107, %104 ]
  %112 = add nuw nsw i32 %99, 1
  %113 = icmp slt i32 %112, %110
  br i1 %113, label %96, label %114, !llvm.loop !297

114:                                              ; preds = %109, %76, %7
  %115 = tail call i64 @clock() #17
  store i64 %115, ptr @end_time, align 8, !tbaa !30
  %116 = load i64, ptr @start_time, align 8, !tbaa !30
  %117 = load ptr, ptr @results, align 8, !tbaa !6
  %118 = icmp ne ptr %117, null
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %120 = load i32, ptr @current_test, align 4
  %121 = icmp slt i32 %120, %119
  %122 = select i1 %118, i1 %121, i1 false
  br i1 %122, label %134, label %123

123:                                              ; preds = %114
  %124 = add nsw i32 %119, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !11
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %117, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !6
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %123
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %134

131:                                              ; preds = %123
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %114, %129
  %135 = phi i32 [ %130, %129 ], [ %120, %114 ]
  %136 = phi ptr [ %127, %129 ], [ %117, %114 ]
  %137 = sub nsw i64 %115, %116
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !13
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !17
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %118

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = zext i16 %3 to i32
  %14 = zext i16 %4 to i32
  %15 = mul nuw nsw i32 %14, %13
  %16 = zext i16 %5 to i32
  %17 = udiv i32 %15, %16
  %18 = trunc i32 %17 to i16
  %19 = sub i16 %2, %18
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %100

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 4
  %25 = icmp ult i32 %1, 16
  %26 = and i64 %23, 2147483632
  %27 = insertelement <8 x i16> poison, i16 %19, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = icmp eq i64 %26, %23
  %30 = and i64 %23, 12
  %31 = icmp eq i64 %30, 0
  %32 = and i64 %23, 2147483644
  %33 = insertelement <4 x i16> poison, i16 %19, i64 0
  %34 = shufflevector <4 x i16> %33, <4 x i16> poison, <4 x i32> zeroinitializer
  %35 = icmp eq i64 %32, %23
  br label %36

36:                                               ; preds = %80, %22
  %37 = phi i32 [ %9, %22 ], [ %81, %80 ]
  %38 = phi i32 [ 0, %22 ], [ %82, %80 ]
  br i1 %24, label %39, label %42

39:                                               ; preds = %60, %74, %36
  %40 = phi i64 [ 0, %36 ], [ %26, %60 ], [ %32, %74 ]
  %41 = phi i16 [ 0, %36 ], [ %59, %60 ], [ %75, %74 ]
  br label %84

42:                                               ; preds = %36
  br i1 %25, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <8 x i16> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <8 x i16> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds nuw i16, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <8 x i16>, ptr %47, align 2, !tbaa !35
  %50 = load <8 x i16>, ptr %48, align 2, !tbaa !35
  %51 = add <8 x i16> %28, %49
  %52 = add <8 x i16> %28, %50
  %53 = add <8 x i16> %51, %45
  %54 = add <8 x i16> %52, %46
  %55 = add nuw i64 %44, 16
  %56 = icmp eq i64 %55, %26
  br i1 %56, label %57, label %43, !llvm.loop !299

57:                                               ; preds = %43
  %58 = add <8 x i16> %54, %53
  %59 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %58)
  br i1 %29, label %93, label %60

60:                                               ; preds = %57
  br i1 %31, label %39, label %61

61:                                               ; preds = %60, %42
  %62 = phi i64 [ %26, %60 ], [ 0, %42 ]
  %63 = phi i16 [ %59, %60 ], [ 0, %42 ]
  %64 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %63, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %62, %61 ], [ %72, %65 ]
  %67 = phi <4 x i16> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds nuw i16, ptr %0, i64 %66
  %69 = load <4 x i16>, ptr %68, align 2, !tbaa !35
  %70 = add <4 x i16> %34, %69
  %71 = add <4 x i16> %70, %67
  %72 = add nuw i64 %66, 4
  %73 = icmp eq i64 %72, %32
  br i1 %73, label %74, label %65, !llvm.loop !300

74:                                               ; preds = %65
  %75 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %71)
  br i1 %35, label %93, label %39

76:                                               ; preds = %93
  %77 = load i32, ptr @current_test, align 4, !tbaa !11
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %80

80:                                               ; preds = %76, %93
  %81 = phi i32 [ %79, %76 ], [ %37, %93 ]
  %82 = add nuw nsw i32 %38, 1
  %83 = icmp slt i32 %82, %81
  br i1 %83, label %36, label %118, !llvm.loop !301

84:                                               ; preds = %39, %84
  %85 = phi i64 [ %91, %84 ], [ %40, %39 ]
  %86 = phi i16 [ %90, %84 ], [ %41, %39 ]
  %87 = getelementptr inbounds nuw i16, ptr %0, i64 %85
  %88 = load i16, ptr %87, align 2, !tbaa !35
  %89 = add i16 %19, %88
  %90 = add i16 %89, %86
  %91 = add nuw nsw i64 %85, 1
  %92 = icmp eq i64 %91, %23
  br i1 %92, label %93, label %84, !llvm.loop !302

93:                                               ; preds = %84, %74, %57
  %94 = phi i16 [ %59, %57 ], [ %75, %74 ], [ %90, %84 ]
  %95 = load double, ptr @init_value, align 8, !tbaa !33
  %96 = fptoui double %95 to i16
  %97 = add i16 %19, %96
  %98 = mul i16 %97, 8000
  %99 = icmp eq i16 %94, %98
  br i1 %99, label %80, label %76

100:                                              ; preds = %20, %113
  %101 = phi i32 [ %114, %113 ], [ %9, %20 ]
  %102 = phi double [ %115, %113 ], [ %21, %20 ]
  %103 = phi i32 [ %116, %113 ], [ 0, %20 ]
  %104 = fptoui double %102 to i16
  %105 = add i16 %19, %104
  %106 = mul i16 %105, 8000
  %107 = icmp eq i16 %106, 0
  br i1 %107, label %113, label %108

108:                                              ; preds = %100
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %109)
  %111 = load double, ptr @init_value, align 8, !tbaa !33
  %112 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %113

113:                                              ; preds = %100, %108
  %114 = phi i32 [ %101, %100 ], [ %112, %108 ]
  %115 = phi double [ %102, %100 ], [ %111, %108 ]
  %116 = add nuw nsw i32 %103, 1
  %117 = icmp slt i32 %116, %114
  br i1 %117, label %100, label %118, !llvm.loop !301

118:                                              ; preds = %113, %80, %7
  %119 = tail call i64 @clock() #17
  store i64 %119, ptr @end_time, align 8, !tbaa !30
  %120 = load i64, ptr @start_time, align 8, !tbaa !30
  %121 = load ptr, ptr @results, align 8, !tbaa !6
  %122 = icmp ne ptr %121, null
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = load i32, ptr @current_test, align 4
  %125 = icmp slt i32 %124, %123
  %126 = select i1 %122, i1 %125, i1 false
  br i1 %126, label %138, label %127

127:                                              ; preds = %118
  %128 = add nsw i32 %123, 10
  store i32 %128, ptr @allocated_results, align 4, !tbaa !11
  %129 = sext i32 %128 to i64
  %130 = shl nsw i64 %129, 4
  %131 = tail call ptr @realloc(ptr noundef %121, i64 noundef %130) #14
  store ptr %131, ptr @results, align 8, !tbaa !6
  %132 = icmp eq ptr %131, null
  br i1 %132, label %135, label %133

133:                                              ; preds = %127
  %134 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %138

135:                                              ; preds = %127
  %136 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %137 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %136)
  tail call void @exit(i32 noundef -1) #15
  unreachable

138:                                              ; preds = %118, %133
  %139 = phi i32 [ %134, %133 ], [ %124, %118 ]
  %140 = phi ptr [ %131, %133 ], [ %121, %118 ]
  %141 = sub nsw i64 %119, %120
  %142 = sitofp i64 %141 to double
  %143 = fdiv double %142, 1.000000e+06
  %144 = sext i32 %139 to i64
  %145 = getelementptr inbounds %struct.one_result, ptr %140, i64 %144
  store double %143, ptr %145, align 8, !tbaa !13
  %146 = getelementptr inbounds %struct.one_result, ptr %140, i64 %144, i32 1
  store ptr %6, ptr %146, align 8, !tbaa !17
  %147 = add nsw i32 %139, 1
  store i32 %147, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = and <8 x i16> %39, %18
  %42 = and <8 x i16> %40, %18
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !303

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = and <4 x i16> %59, %24
  %61 = add <4 x i16> %60, %57
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !304

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !305

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = and i16 %78, %2
  %80 = add i16 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !306

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i16
  %87 = and i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i16
  %95 = and i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !305

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = and i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i16 %2, %12
  %15 = and i16 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %4, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = insertelement <8 x i16> poison, i16 %5, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %2, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %3, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = and <8 x i16> %24, %26
  %32 = and <8 x i16> %24, %26
  %33 = and <8 x i16> %31, %28
  %34 = and <8 x i16> %32, %28
  %35 = and <8 x i16> %33, %30
  %36 = and <8 x i16> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 12
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483644
  %41 = and i16 %5, %4
  %42 = and i16 %2, %41
  %43 = and i16 %3, %42
  %44 = insertelement <4 x i16> poison, i16 %43, i64 0
  %45 = shufflevector <4 x i16> %44, <4 x i16> poison, <4 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = and i16 %4, %5
  %48 = and i16 %47, %2
  %49 = and i16 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i16 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <8 x i16> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <8 x i16> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <8 x i16>, ptr %61, align 2, !tbaa !35
  %64 = load <8 x i16>, ptr %62, align 2, !tbaa !35
  %65 = and <8 x i16> %63, %35
  %66 = and <8 x i16> %64, %36
  %67 = add <8 x i16> %65, %59
  %68 = add <8 x i16> %66, %60
  %69 = add nuw i64 %58, 16
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !307

71:                                               ; preds = %57
  %72 = add <8 x i16> %68, %67
  %73 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i16 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <4 x i16> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i16, ptr %0, i64 %80
  %83 = load <4 x i16>, ptr %82, align 2, !tbaa !35
  %84 = and <4 x i16> %45, %83
  %85 = add <4 x i16> %84, %81
  %86 = add nuw i64 %80, 4
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !308

88:                                               ; preds = %79
  %89 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !309

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i16 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i16, ptr %0, i64 %99
  %102 = load i16, ptr %101, align 2, !tbaa !35
  %103 = and i16 %102, %49
  %104 = add i16 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !310

107:                                              ; preds = %98, %88, %71
  %108 = phi i16 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptoui double %109 to i16
  %111 = and i16 %15, %110
  %112 = mul i16 %111, 8000
  %113 = icmp eq i16 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptoui double %116 to i16
  %119 = and i16 %15, %118
  %120 = mul i16 %119, 8000
  %121 = icmp eq i16 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !309

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = or <8 x i16> %39, %18
  %42 = or <8 x i16> %40, %18
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !311

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = or <4 x i16> %59, %24
  %61 = add <4 x i16> %60, %57
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !312

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !313

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = or i16 %78, %2
  %80 = add i16 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !314

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i16
  %87 = or i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i16
  %95 = or i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !313

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = or i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i16 %2, %12
  %15 = or i16 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %4, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = insertelement <8 x i16> poison, i16 %5, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %2, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %3, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = or <8 x i16> %24, %26
  %32 = or <8 x i16> %24, %26
  %33 = or <8 x i16> %31, %28
  %34 = or <8 x i16> %32, %28
  %35 = or <8 x i16> %33, %30
  %36 = or <8 x i16> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 12
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483644
  %41 = or i16 %5, %4
  %42 = or i16 %2, %41
  %43 = or i16 %3, %42
  %44 = insertelement <4 x i16> poison, i16 %43, i64 0
  %45 = shufflevector <4 x i16> %44, <4 x i16> poison, <4 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = or i16 %4, %5
  %48 = or i16 %47, %2
  %49 = or i16 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i16 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <8 x i16> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <8 x i16> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <8 x i16>, ptr %61, align 2, !tbaa !35
  %64 = load <8 x i16>, ptr %62, align 2, !tbaa !35
  %65 = or <8 x i16> %63, %35
  %66 = or <8 x i16> %64, %36
  %67 = add <8 x i16> %65, %59
  %68 = add <8 x i16> %66, %60
  %69 = add nuw i64 %58, 16
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !315

71:                                               ; preds = %57
  %72 = add <8 x i16> %68, %67
  %73 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i16 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <4 x i16> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i16, ptr %0, i64 %80
  %83 = load <4 x i16>, ptr %82, align 2, !tbaa !35
  %84 = or <4 x i16> %45, %83
  %85 = add <4 x i16> %84, %81
  %86 = add nuw i64 %80, 4
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !316

88:                                               ; preds = %79
  %89 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !317

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i16 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i16, ptr %0, i64 %99
  %102 = load i16, ptr %101, align 2, !tbaa !35
  %103 = or i16 %102, %49
  %104 = add i16 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !318

107:                                              ; preds = %98, %88, %71
  %108 = phi i16 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptoui double %109 to i16
  %111 = or i16 %15, %110
  %112 = mul i16 %111, 8000
  %113 = icmp eq i16 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptoui double %116 to i16
  %119 = or i16 %15, %118
  %120 = mul i16 %119, 8000
  %121 = icmp eq i16 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !317

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %108

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %90

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %13, 2147483632
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %13
  %20 = and i64 %13, 12
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %13, 2147483644
  %23 = insertelement <4 x i16> poison, i16 %2, i64 0
  %24 = shufflevector <4 x i16> %23, <4 x i16> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %22, %13
  br label %26

26:                                               ; preds = %12, %70
  %27 = phi i32 [ %71, %70 ], [ %6, %12 ]
  %28 = phi i32 [ %72, %70 ], [ 0, %12 ]
  br i1 %14, label %29, label %32

29:                                               ; preds = %50, %64, %26
  %30 = phi i64 [ 0, %26 ], [ %16, %50 ], [ %22, %64 ]
  %31 = phi i16 [ 0, %26 ], [ %49, %50 ], [ %65, %64 ]
  br label %74

32:                                               ; preds = %26
  br i1 %15, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds nuw i16, ptr %0, i64 %34
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 16
  %39 = load <8 x i16>, ptr %37, align 2, !tbaa !35
  %40 = load <8 x i16>, ptr %38, align 2, !tbaa !35
  %41 = xor <8 x i16> %39, %18
  %42 = xor <8 x i16> %40, %18
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %16
  br i1 %46, label %47, label %33, !llvm.loop !319

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %19, label %83, label %50

50:                                               ; preds = %47
  br i1 %21, label %29, label %51

51:                                               ; preds = %50, %32
  %52 = phi i64 [ %16, %50 ], [ 0, %32 ]
  %53 = phi i16 [ %49, %50 ], [ 0, %32 ]
  %54 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %53, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %52, %51 ], [ %62, %55 ]
  %57 = phi <4 x i16> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds nuw i16, ptr %0, i64 %56
  %59 = load <4 x i16>, ptr %58, align 2, !tbaa !35
  %60 = xor <4 x i16> %59, %24
  %61 = add <4 x i16> %60, %57
  %62 = add nuw i64 %56, 4
  %63 = icmp eq i64 %62, %22
  br i1 %63, label %64, label %55, !llvm.loop !320

64:                                               ; preds = %55
  %65 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %61)
  br i1 %25, label %83, label %29

66:                                               ; preds = %83
  %67 = load i32, ptr @current_test, align 4, !tbaa !11
  %68 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %67)
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %70

70:                                               ; preds = %66, %83
  %71 = phi i32 [ %69, %66 ], [ %27, %83 ]
  %72 = add nuw nsw i32 %28, 1
  %73 = icmp slt i32 %72, %71
  br i1 %73, label %26, label %108, !llvm.loop !321

74:                                               ; preds = %29, %74
  %75 = phi i64 [ %81, %74 ], [ %30, %29 ]
  %76 = phi i16 [ %80, %74 ], [ %31, %29 ]
  %77 = getelementptr inbounds nuw i16, ptr %0, i64 %75
  %78 = load i16, ptr %77, align 2, !tbaa !35
  %79 = xor i16 %78, %2
  %80 = add i16 %79, %76
  %81 = add nuw nsw i64 %75, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %74, !llvm.loop !322

83:                                               ; preds = %74, %64, %47
  %84 = phi i16 [ %49, %47 ], [ %65, %64 ], [ %80, %74 ]
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = fptoui double %85 to i16
  %87 = xor i16 %2, %86
  %88 = mul i16 %87, 8000
  %89 = icmp eq i16 %84, %88
  br i1 %89, label %70, label %66

90:                                               ; preds = %10, %103
  %91 = phi i32 [ %104, %103 ], [ %6, %10 ]
  %92 = phi double [ %105, %103 ], [ %11, %10 ]
  %93 = phi i32 [ %106, %103 ], [ 0, %10 ]
  %94 = fptoui double %92 to i16
  %95 = xor i16 %2, %94
  %96 = mul i16 %95, 8000
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %103, label %98

98:                                               ; preds = %90
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !33
  %102 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %103

103:                                              ; preds = %90, %98
  %104 = phi i32 [ %91, %90 ], [ %102, %98 ]
  %105 = phi double [ %92, %90 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %93, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %90, label %108, !llvm.loop !321

108:                                              ; preds = %103, %70, %4
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !30
  %110 = load i64, ptr @start_time, align 8, !tbaa !30
  %111 = load ptr, ptr @results, align 8, !tbaa !6
  %112 = icmp ne ptr %111, null
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = load i32, ptr @current_test, align 4
  %115 = icmp slt i32 %114, %113
  %116 = select i1 %112, i1 %115, i1 false
  br i1 %116, label %128, label %117

117:                                              ; preds = %108
  %118 = add nsw i32 %113, 10
  store i32 %118, ptr @allocated_results, align 4, !tbaa !11
  %119 = sext i32 %118 to i64
  %120 = shl nsw i64 %119, 4
  %121 = tail call ptr @realloc(ptr noundef %111, i64 noundef %120) #14
  store ptr %121, ptr @results, align 8, !tbaa !6
  %122 = icmp eq ptr %121, null
  br i1 %122, label %125, label %123

123:                                              ; preds = %117
  %124 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %128

125:                                              ; preds = %117
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %127 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %126)
  tail call void @exit(i32 noundef -1) #15
  unreachable

128:                                              ; preds = %108, %123
  %129 = phi i32 [ %124, %123 ], [ %114, %108 ]
  %130 = phi ptr [ %121, %123 ], [ %111, %108 ]
  %131 = sub nsw i64 %109, %110
  %132 = sitofp i64 %131 to double
  %133 = fdiv double %132, 1.000000e+06
  %134 = sext i32 %129 to i64
  %135 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134
  store double %133, ptr %135, align 8, !tbaa !13
  %136 = getelementptr inbounds %struct.one_result, ptr %130, i64 %134, i32 1
  store ptr %3, ptr %136, align 8, !tbaa !17
  %137 = add nsw i32 %129, 1
  store i32 %137, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef %2, i16 noundef %3, i16 noundef %4, i16 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %132

11:                                               ; preds = %7
  %12 = xor i16 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i16 %2, %12
  %15 = xor i16 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %114

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = icmp ult i32 %1, 16
  %22 = and i64 %19, 2147483632
  %23 = insertelement <8 x i16> poison, i16 %4, i64 0
  %24 = shufflevector <8 x i16> %23, <8 x i16> poison, <8 x i32> zeroinitializer
  %25 = insertelement <8 x i16> poison, i16 %5, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %2, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %3, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = xor <8 x i16> %24, %26
  %32 = xor <8 x i16> %24, %26
  %33 = xor <8 x i16> %31, %28
  %34 = xor <8 x i16> %32, %28
  %35 = xor <8 x i16> %33, %30
  %36 = xor <8 x i16> %34, %30
  %37 = icmp eq i64 %22, %19
  %38 = and i64 %19, 12
  %39 = icmp eq i64 %38, 0
  %40 = and i64 %19, 2147483644
  %41 = xor i16 %5, %4
  %42 = xor i16 %2, %41
  %43 = xor i16 %3, %42
  %44 = insertelement <4 x i16> poison, i16 %43, i64 0
  %45 = shufflevector <4 x i16> %44, <4 x i16> poison, <4 x i32> zeroinitializer
  %46 = icmp eq i64 %40, %19
  %47 = xor i16 %4, %5
  %48 = xor i16 %47, %2
  %49 = xor i16 %48, %3
  br label %50

50:                                               ; preds = %18, %94
  %51 = phi i32 [ %95, %94 ], [ %9, %18 ]
  %52 = phi i32 [ %96, %94 ], [ 0, %18 ]
  br i1 %20, label %53, label %56

53:                                               ; preds = %74, %88, %50
  %54 = phi i64 [ 0, %50 ], [ %22, %74 ], [ %40, %88 ]
  %55 = phi i16 [ 0, %50 ], [ %73, %74 ], [ %89, %88 ]
  br label %98

56:                                               ; preds = %50
  br i1 %21, label %75, label %57

57:                                               ; preds = %56, %57
  %58 = phi i64 [ %69, %57 ], [ 0, %56 ]
  %59 = phi <8 x i16> [ %67, %57 ], [ zeroinitializer, %56 ]
  %60 = phi <8 x i16> [ %68, %57 ], [ zeroinitializer, %56 ]
  %61 = getelementptr inbounds nuw i16, ptr %0, i64 %58
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 16
  %63 = load <8 x i16>, ptr %61, align 2, !tbaa !35
  %64 = load <8 x i16>, ptr %62, align 2, !tbaa !35
  %65 = xor <8 x i16> %63, %35
  %66 = xor <8 x i16> %64, %36
  %67 = add <8 x i16> %65, %59
  %68 = add <8 x i16> %66, %60
  %69 = add nuw i64 %58, 16
  %70 = icmp eq i64 %69, %22
  br i1 %70, label %71, label %57, !llvm.loop !323

71:                                               ; preds = %57
  %72 = add <8 x i16> %68, %67
  %73 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %72)
  br i1 %37, label %107, label %74

74:                                               ; preds = %71
  br i1 %39, label %53, label %75

75:                                               ; preds = %74, %56
  %76 = phi i64 [ %22, %74 ], [ 0, %56 ]
  %77 = phi i16 [ %73, %74 ], [ 0, %56 ]
  %78 = insertelement <4 x i16> <i16 poison, i16 0, i16 0, i16 0>, i16 %77, i64 0
  br label %79

79:                                               ; preds = %79, %75
  %80 = phi i64 [ %76, %75 ], [ %86, %79 ]
  %81 = phi <4 x i16> [ %78, %75 ], [ %85, %79 ]
  %82 = getelementptr inbounds nuw i16, ptr %0, i64 %80
  %83 = load <4 x i16>, ptr %82, align 2, !tbaa !35
  %84 = xor <4 x i16> %45, %83
  %85 = add <4 x i16> %84, %81
  %86 = add nuw i64 %80, 4
  %87 = icmp eq i64 %86, %40
  br i1 %87, label %88, label %79, !llvm.loop !324

88:                                               ; preds = %79
  %89 = tail call i16 @llvm.vector.reduce.add.v4i16(<4 x i16> %85)
  br i1 %46, label %107, label %53

90:                                               ; preds = %107
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %90, %107
  %95 = phi i32 [ %93, %90 ], [ %51, %107 ]
  %96 = add nuw nsw i32 %52, 1
  %97 = icmp slt i32 %96, %95
  br i1 %97, label %50, label %132, !llvm.loop !325

98:                                               ; preds = %53, %98
  %99 = phi i64 [ %105, %98 ], [ %54, %53 ]
  %100 = phi i16 [ %104, %98 ], [ %55, %53 ]
  %101 = getelementptr inbounds nuw i16, ptr %0, i64 %99
  %102 = load i16, ptr %101, align 2, !tbaa !35
  %103 = xor i16 %102, %49
  %104 = add i16 %103, %100
  %105 = add nuw nsw i64 %99, 1
  %106 = icmp eq i64 %105, %19
  br i1 %106, label %107, label %98, !llvm.loop !326

107:                                              ; preds = %98, %88, %71
  %108 = phi i16 [ %73, %71 ], [ %89, %88 ], [ %104, %98 ]
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = fptoui double %109 to i16
  %111 = xor i16 %15, %110
  %112 = mul i16 %111, 8000
  %113 = icmp eq i16 %108, %112
  br i1 %113, label %94, label %90

114:                                              ; preds = %16, %127
  %115 = phi i32 [ %128, %127 ], [ %9, %16 ]
  %116 = phi double [ %129, %127 ], [ %17, %16 ]
  %117 = phi i32 [ %130, %127 ], [ 0, %16 ]
  %118 = fptoui double %116 to i16
  %119 = xor i16 %15, %118
  %120 = mul i16 %119, 8000
  %121 = icmp eq i16 %120, 0
  br i1 %121, label %127, label %122

122:                                              ; preds = %114
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %123)
  %125 = load double, ptr @init_value, align 8, !tbaa !33
  %126 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %127

127:                                              ; preds = %114, %122
  %128 = phi i32 [ %115, %114 ], [ %126, %122 ]
  %129 = phi double [ %116, %114 ], [ %125, %122 ]
  %130 = add nuw nsw i32 %117, 1
  %131 = icmp slt i32 %130, %128
  br i1 %131, label %114, label %132, !llvm.loop !325

132:                                              ; preds = %127, %94, %7
  %133 = tail call i64 @clock() #17
  store i64 %133, ptr @end_time, align 8, !tbaa !30
  %134 = load i64, ptr @start_time, align 8, !tbaa !30
  %135 = load ptr, ptr @results, align 8, !tbaa !6
  %136 = icmp ne ptr %135, null
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %138 = load i32, ptr @current_test, align 4
  %139 = icmp slt i32 %138, %137
  %140 = select i1 %136, i1 %139, i1 false
  br i1 %140, label %152, label %141

141:                                              ; preds = %132
  %142 = add nsw i32 %137, 10
  store i32 %142, ptr @allocated_results, align 4, !tbaa !11
  %143 = sext i32 %142 to i64
  %144 = shl nsw i64 %143, 4
  %145 = tail call ptr @realloc(ptr noundef %135, i64 noundef %144) #14
  store ptr %145, ptr @results, align 8, !tbaa !6
  %146 = icmp eq ptr %145, null
  br i1 %146, label %149, label %147

147:                                              ; preds = %141
  %148 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %152

149:                                              ; preds = %141
  %150 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %151 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %150)
  tail call void @exit(i32 noundef -1) #15
  unreachable

152:                                              ; preds = %132, %147
  %153 = phi i32 [ %148, %147 ], [ %138, %132 ]
  %154 = phi ptr [ %145, %147 ], [ %135, %132 ]
  %155 = sub nsw i64 %133, %134
  %156 = sitofp i64 %155 to double
  %157 = fdiv double %156, 1.000000e+06
  %158 = sext i32 %153 to i64
  %159 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158
  store double %157, ptr %159, align 8, !tbaa !13
  %160 = getelementptr inbounds %struct.one_result, ptr %154, i64 %158, i32 1
  store ptr %6, ptr %160, align 8, !tbaa !17
  %161 = add nsw i32 %153, 1
  store i32 %161, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = add <4 x i32> %24, %17
  %31 = add <4 x i32> %25, %17
  %32 = add <4 x i32> %30, %28
  %33 = add <4 x i32> %31, %29
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !327

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %83, !llvm.loop !328

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = add i32 %52, %2
  %56 = add i32 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !329

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i32
  %63 = add nsw i32 %2, %62
  %64 = mul nsw i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %10 ]
  %68 = phi double [ %80, %78 ], [ %11, %10 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %10 ]
  %70 = fptosi double %68 to i32
  %71 = sub i32 0, %70
  %72 = icmp eq i32 %2, %71
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !328

83:                                               ; preds = %78, %46, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul nsw i32 %2, %1
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %63

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 2147483640
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %43
  %19 = phi i32 [ %44, %43 ], [ %6, %13 ]
  %20 = phi i32 [ %45, %43 ], [ 0, %13 ]
  br i1 %15, label %36, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %31, %21 ], [ 0, %18 ]
  %23 = phi <4 x i32> [ %29, %21 ], [ zeroinitializer, %18 ]
  %24 = phi <4 x i32> [ %30, %21 ], [ zeroinitializer, %18 ]
  %25 = getelementptr inbounds nuw i32, ptr %0, i64 %22
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <4 x i32>, ptr %25, align 4, !tbaa !11
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = add <4 x i32> %27, %23
  %30 = add <4 x i32> %28, %24
  %31 = add nuw i64 %22, 8
  %32 = icmp eq i64 %31, %16
  br i1 %32, label %33, label %21, !llvm.loop !330

33:                                               ; preds = %21
  %34 = add <4 x i32> %30, %29
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %34)
  br i1 %17, label %55, label %36

36:                                               ; preds = %18, %33
  %37 = phi i64 [ 0, %18 ], [ %16, %33 ]
  %38 = phi i32 [ 0, %18 ], [ %35, %33 ]
  br label %47

39:                                               ; preds = %55
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %55
  %44 = phi i32 [ %42, %39 ], [ %19, %55 ]
  %45 = add nuw nsw i32 %20, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %18, label %81, !llvm.loop !331

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %53, %47 ], [ %37, %36 ]
  %49 = phi i32 [ %52, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = add nsw i32 %51, %49
  %53 = add nuw nsw i64 %48, 1
  %54 = icmp eq i64 %53, %14
  br i1 %54, label %55, label %47, !llvm.loop !332

55:                                               ; preds = %47, %33
  %56 = phi i32 [ %35, %33 ], [ %52, %47 ]
  %57 = add nsw i32 %56, %10
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptosi double %58 to i32
  %60 = add nsw i32 %2, %59
  %61 = mul nsw i32 %60, 8000
  %62 = icmp eq i32 %57, %61
  br i1 %62, label %43, label %39

63:                                               ; preds = %11, %76
  %64 = phi i32 [ %77, %76 ], [ %6, %11 ]
  %65 = phi double [ %78, %76 ], [ %12, %11 ]
  %66 = phi i32 [ %79, %76 ], [ 0, %11 ]
  %67 = fptosi double %65 to i32
  %68 = add nsw i32 %2, %67
  %69 = mul nsw i32 %68, 8000
  %70 = icmp eq i32 %10, %69
  br i1 %70, label %76, label %71

71:                                               ; preds = %63
  %72 = load i32, ptr @current_test, align 4, !tbaa !11
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !33
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %63, %71
  %77 = phi i32 [ %64, %63 ], [ %75, %71 ]
  %78 = phi double [ %65, %63 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %66, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %63, label %81, !llvm.loop !331

81:                                               ; preds = %76, %43, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !30
  %83 = load i64, ptr @start_time, align 8, !tbaa !30
  %84 = load ptr, ptr @results, align 8, !tbaa !6
  %85 = icmp ne ptr %84, null
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %87 = load i32, ptr @current_test, align 4
  %88 = icmp slt i32 %87, %86
  %89 = select i1 %85, i1 %88, i1 false
  br i1 %89, label %101, label %90

90:                                               ; preds = %81
  %91 = add nsw i32 %86, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !11
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %84, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !6
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %90
  %97 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %101

98:                                               ; preds = %90
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %81, %96
  %102 = phi i32 [ %97, %96 ], [ %87, %81 ]
  %103 = phi ptr [ %94, %96 ], [ %84, %81 ]
  %104 = sub nsw i64 %82, %83
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !13
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !17
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %89

11:                                               ; preds = %7
  %12 = add i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i32 %3, %2
  %15 = add i32 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <4 x i32> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <4 x i32> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i32, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x i32>, ptr %32, align 4, !tbaa !11
  %35 = load <4 x i32>, ptr %33, align 4, !tbaa !11
  %36 = add <4 x i32> %23, %30
  %37 = add <4 x i32> %23, %31
  %38 = add <4 x i32> %36, %34
  %39 = add <4 x i32> %37, %35
  %40 = add nuw i64 %29, 8
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !333

42:                                               ; preds = %28
  %43 = add <4 x i32> %39, %38
  %44 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i32 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %89, !llvm.loop !334

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i32 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i32, ptr %0, i64 %57
  %60 = load i32, ptr %59, align 4, !tbaa !11
  %61 = add i32 %15, %58
  %62 = add i32 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !335

65:                                               ; preds = %56, %42
  %66 = phi i32 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptosi double %67 to i32
  %69 = add i32 %15, %68
  %70 = mul nsw i32 %69, 8000
  %71 = icmp eq i32 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %84
  %73 = phi i32 [ %85, %84 ], [ %9, %16 ]
  %74 = phi double [ %86, %84 ], [ %17, %16 ]
  %75 = phi i32 [ %87, %84 ], [ 0, %16 ]
  %76 = fptosi double %74 to i32
  %77 = sub i32 0, %76
  %78 = icmp eq i32 %15, %77
  br i1 %78, label %84, label %79

79:                                               ; preds = %72
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %80)
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %84

84:                                               ; preds = %72, %79
  %85 = phi i32 [ %73, %72 ], [ %83, %79 ]
  %86 = phi double [ %74, %72 ], [ %82, %79 ]
  %87 = add nuw nsw i32 %75, 1
  %88 = icmp slt i32 %87, %85
  br i1 %88, label %72, label %89, !llvm.loop !334

89:                                               ; preds = %84, %52, %7
  %90 = tail call i64 @clock() #17
  store i64 %90, ptr @end_time, align 8, !tbaa !30
  %91 = load i64, ptr @start_time, align 8, !tbaa !30
  %92 = load ptr, ptr @results, align 8, !tbaa !6
  %93 = icmp ne ptr %92, null
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %95 = load i32, ptr @current_test, align 4
  %96 = icmp slt i32 %95, %94
  %97 = select i1 %93, i1 %96, i1 false
  br i1 %97, label %109, label %98

98:                                               ; preds = %89
  %99 = add nsw i32 %94, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !11
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %92, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !6
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %98
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %109

106:                                              ; preds = %98
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %89, %104
  %110 = phi i32 [ %105, %104 ], [ %95, %89 ]
  %111 = phi ptr [ %102, %104 ], [ %92, %89 ]
  %112 = sub nsw i64 %90, %91
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !13
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %6, ptr %117, align 8, !tbaa !17
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = sub <4 x i32> %24, %17
  %31 = sub <4 x i32> %25, %17
  %32 = add <4 x i32> %30, %28
  %33 = add <4 x i32> %31, %29
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !336

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %82, !llvm.loop !337

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = sub i32 %52, %2
  %56 = add i32 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !338

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i32
  %63 = sub nsw i32 %62, %2
  %64 = mul nsw i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %77
  %67 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %68 = phi double [ %79, %77 ], [ %11, %10 ]
  %69 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %70 = fptosi double %68 to i32
  %71 = icmp eq i32 %2, %70
  br i1 %71, label %77, label %72

72:                                               ; preds = %66
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %66, %72
  %78 = phi i32 [ %67, %66 ], [ %76, %72 ]
  %79 = phi double [ %68, %66 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %69, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %66, label %82, !llvm.loop !337

82:                                               ; preds = %77, %46, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %88

11:                                               ; preds = %7
  %12 = add i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i32 %3, %2
  %15 = add i32 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <4 x i32> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <4 x i32> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i32, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x i32>, ptr %32, align 4, !tbaa !11
  %35 = load <4 x i32>, ptr %33, align 4, !tbaa !11
  %36 = sub <4 x i32> %30, %23
  %37 = sub <4 x i32> %31, %23
  %38 = add <4 x i32> %36, %34
  %39 = add <4 x i32> %37, %35
  %40 = add nuw i64 %29, 8
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !339

42:                                               ; preds = %28
  %43 = add <4 x i32> %39, %38
  %44 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i32 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %88, !llvm.loop !340

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i32 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i32, ptr %0, i64 %57
  %60 = load i32, ptr %59, align 4, !tbaa !11
  %61 = sub i32 %58, %15
  %62 = add i32 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !341

65:                                               ; preds = %56, %42
  %66 = phi i32 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptosi double %67 to i32
  %69 = sub i32 %68, %15
  %70 = mul nsw i32 %69, 8000
  %71 = icmp eq i32 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %83
  %73 = phi i32 [ %84, %83 ], [ %9, %16 ]
  %74 = phi double [ %85, %83 ], [ %17, %16 ]
  %75 = phi i32 [ %86, %83 ], [ 0, %16 ]
  %76 = fptosi double %74 to i32
  %77 = icmp eq i32 %15, %76
  br i1 %77, label %83, label %78

78:                                               ; preds = %72
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %79)
  %81 = load double, ptr @init_value, align 8, !tbaa !33
  %82 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %83

83:                                               ; preds = %72, %78
  %84 = phi i32 [ %73, %72 ], [ %82, %78 ]
  %85 = phi double [ %74, %72 ], [ %81, %78 ]
  %86 = add nuw nsw i32 %75, 1
  %87 = icmp slt i32 %86, %84
  br i1 %87, label %72, label %88, !llvm.loop !340

88:                                               ; preds = %83, %52, %7
  %89 = tail call i64 @clock() #17
  store i64 %89, ptr @end_time, align 8, !tbaa !30
  %90 = load i64, ptr @start_time, align 8, !tbaa !30
  %91 = load ptr, ptr @results, align 8, !tbaa !6
  %92 = icmp ne ptr %91, null
  %93 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %94 = load i32, ptr @current_test, align 4
  %95 = icmp slt i32 %94, %93
  %96 = select i1 %92, i1 %95, i1 false
  br i1 %96, label %108, label %97

97:                                               ; preds = %88
  %98 = add nsw i32 %93, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !11
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %91, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !6
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %97
  %104 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %108

105:                                              ; preds = %97
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %88, %103
  %109 = phi i32 [ %104, %103 ], [ %94, %88 ]
  %110 = phi ptr [ %101, %103 ], [ %91, %88 ]
  %111 = sub nsw i64 %89, %90
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !13
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %6, ptr %116, align 8, !tbaa !17
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i32 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 2147483640
  %17 = insertelement <4 x i32> poison, i32 %2, i64 0
  %18 = shufflevector <4 x i32> %17, <4 x i32> poison, <4 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %14
  br label %20

20:                                               ; preds = %13, %47
  %21 = phi i32 [ %48, %47 ], [ %6, %13 ]
  %22 = phi i32 [ %49, %47 ], [ 0, %13 ]
  br i1 %15, label %40, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %35, %23 ], [ 0, %20 ]
  %25 = phi <4 x i32> [ %33, %23 ], [ zeroinitializer, %20 ]
  %26 = phi <4 x i32> [ %34, %23 ], [ zeroinitializer, %20 ]
  %27 = getelementptr inbounds nuw i32, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i8, ptr %27, i64 16
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = load <4 x i32>, ptr %28, align 4, !tbaa !11
  %31 = mul nsw <4 x i32> %29, %18
  %32 = mul nsw <4 x i32> %30, %18
  %33 = add <4 x i32> %31, %25
  %34 = add <4 x i32> %32, %26
  %35 = add nuw i64 %24, 8
  %36 = icmp eq i64 %35, %16
  br i1 %36, label %37, label %23, !llvm.loop !342

37:                                               ; preds = %23
  %38 = add <4 x i32> %34, %33
  %39 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %38)
  br i1 %19, label %60, label %40

40:                                               ; preds = %20, %37
  %41 = phi i64 [ 0, %20 ], [ %16, %37 ]
  %42 = phi i32 [ 0, %20 ], [ %39, %37 ]
  br label %51

43:                                               ; preds = %60
  %44 = load i32, ptr @current_test, align 4, !tbaa !11
  %45 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %44)
  %46 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %47

47:                                               ; preds = %43, %60
  %48 = phi i32 [ %46, %43 ], [ %21, %60 ]
  %49 = add nuw nsw i32 %22, 1
  %50 = icmp slt i32 %49, %48
  br i1 %50, label %20, label %83, !llvm.loop !343

51:                                               ; preds = %40, %51
  %52 = phi i64 [ %58, %51 ], [ %41, %40 ]
  %53 = phi i32 [ %57, %51 ], [ %42, %40 ]
  %54 = getelementptr inbounds nuw i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul nsw i32 %55, %2
  %57 = add nsw i32 %56, %53
  %58 = add nuw nsw i64 %52, 1
  %59 = icmp eq i64 %58, %14
  br i1 %59, label %60, label %51, !llvm.loop !344

60:                                               ; preds = %51, %37
  %61 = phi i32 [ %39, %37 ], [ %57, %51 ]
  %62 = load double, ptr @init_value, align 8, !tbaa !33
  %63 = fptosi double %62 to i32
  %64 = mul i32 %10, %63
  %65 = icmp eq i32 %61, %64
  br i1 %65, label %47, label %43

66:                                               ; preds = %11, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %11 ]
  %68 = phi double [ %80, %78 ], [ %12, %11 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %11 ]
  %70 = fptosi double %68 to i32
  %71 = mul i32 %10, %70
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !343

83:                                               ; preds = %78, %47, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = mul i32 %3, 8000
  %13 = mul i32 %12, %4
  %14 = mul i32 %13, %5
  %15 = mul i32 %3, %5
  %16 = mul i32 %15, %2
  %17 = mul i32 %16, %4
  %18 = icmp sgt i32 %1, 0
  %19 = mul i32 %14, %2
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = and i64 %23, 2147483640
  %26 = insertelement <4 x i32> poison, i32 %17, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %23
  br label %29

29:                                               ; preds = %22, %56
  %30 = phi i32 [ %57, %56 ], [ %9, %22 ]
  %31 = phi i32 [ %58, %56 ], [ 0, %22 ]
  br i1 %24, label %49, label %32

32:                                               ; preds = %29, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %29 ]
  %34 = phi <4 x i32> [ %42, %32 ], [ zeroinitializer, %29 ]
  %35 = phi <4 x i32> [ %43, %32 ], [ zeroinitializer, %29 ]
  %36 = getelementptr inbounds nuw i32, ptr %0, i64 %33
  %37 = getelementptr inbounds nuw i8, ptr %36, i64 16
  %38 = load <4 x i32>, ptr %36, align 4, !tbaa !11
  %39 = load <4 x i32>, ptr %37, align 4, !tbaa !11
  %40 = mul <4 x i32> %27, %38
  %41 = mul <4 x i32> %27, %39
  %42 = add <4 x i32> %40, %34
  %43 = add <4 x i32> %41, %35
  %44 = add nuw i64 %33, 8
  %45 = icmp eq i64 %44, %25
  br i1 %45, label %46, label %32, !llvm.loop !345

46:                                               ; preds = %32
  %47 = add <4 x i32> %43, %42
  %48 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %47)
  br i1 %28, label %69, label %49

49:                                               ; preds = %29, %46
  %50 = phi i64 [ 0, %29 ], [ %25, %46 ]
  %51 = phi i32 [ 0, %29 ], [ %48, %46 ]
  br label %60

52:                                               ; preds = %69
  %53 = load i32, ptr @current_test, align 4, !tbaa !11
  %54 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %53)
  %55 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %56

56:                                               ; preds = %52, %69
  %57 = phi i32 [ %55, %52 ], [ %30, %69 ]
  %58 = add nuw nsw i32 %31, 1
  %59 = icmp slt i32 %58, %57
  br i1 %59, label %29, label %92, !llvm.loop !346

60:                                               ; preds = %49, %60
  %61 = phi i64 [ %67, %60 ], [ %50, %49 ]
  %62 = phi i32 [ %66, %60 ], [ %51, %49 ]
  %63 = getelementptr inbounds nuw i32, ptr %0, i64 %61
  %64 = load i32, ptr %63, align 4, !tbaa !11
  %65 = mul i32 %17, %64
  %66 = add nsw i32 %65, %62
  %67 = add nuw nsw i64 %61, 1
  %68 = icmp eq i64 %67, %23
  br i1 %68, label %69, label %60, !llvm.loop !347

69:                                               ; preds = %60, %46
  %70 = phi i32 [ %48, %46 ], [ %66, %60 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptosi double %71 to i32
  %73 = mul i32 %19, %72
  %74 = icmp eq i32 %70, %73
  br i1 %74, label %56, label %52

75:                                               ; preds = %20, %87
  %76 = phi i32 [ %88, %87 ], [ %9, %20 ]
  %77 = phi double [ %89, %87 ], [ %21, %20 ]
  %78 = phi i32 [ %90, %87 ], [ 0, %20 ]
  %79 = fptosi double %77 to i32
  %80 = mul i32 %19, %79
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %75
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %75, %82
  %88 = phi i32 [ %76, %75 ], [ %86, %82 ]
  %89 = phi double [ %77, %75 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %78, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %75, label %92, !llvm.loop !346

92:                                               ; preds = %87, %56, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %6, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = mul i32 %3, %4
  %13 = mul i32 %12, %5
  %14 = mul i32 %3, %5
  %15 = mul i32 %14, %2
  %16 = mul i32 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i32 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = and i64 %22, 2147483640
  %25 = insertelement <4 x i32> poison, i32 %16, i64 0
  %26 = shufflevector <4 x i32> %25, <4 x i32> poison, <4 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %22
  br label %28

28:                                               ; preds = %21, %55
  %29 = phi i32 [ %56, %55 ], [ %9, %21 ]
  %30 = phi i32 [ %57, %55 ], [ 0, %21 ]
  br i1 %23, label %48, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %43, %31 ], [ 0, %28 ]
  %33 = phi <4 x i32> [ %41, %31 ], [ zeroinitializer, %28 ]
  %34 = phi <4 x i32> [ %42, %31 ], [ zeroinitializer, %28 ]
  %35 = getelementptr inbounds nuw i32, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <4 x i32>, ptr %35, align 4, !tbaa !11
  %38 = load <4 x i32>, ptr %36, align 4, !tbaa !11
  %39 = add <4 x i32> %33, %26
  %40 = add <4 x i32> %34, %26
  %41 = add <4 x i32> %39, %37
  %42 = add <4 x i32> %40, %38
  %43 = add nuw i64 %32, 8
  %44 = icmp eq i64 %43, %24
  br i1 %44, label %45, label %31, !llvm.loop !348

45:                                               ; preds = %31
  %46 = add <4 x i32> %42, %41
  %47 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %46)
  br i1 %27, label %68, label %48

48:                                               ; preds = %28, %45
  %49 = phi i64 [ 0, %28 ], [ %24, %45 ]
  %50 = phi i32 [ 0, %28 ], [ %47, %45 ]
  br label %59

51:                                               ; preds = %68
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %52)
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %68
  %56 = phi i32 [ %54, %51 ], [ %29, %68 ]
  %57 = add nuw nsw i32 %30, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %28, label %92, !llvm.loop !349

59:                                               ; preds = %48, %59
  %60 = phi i64 [ %66, %59 ], [ %49, %48 ]
  %61 = phi i32 [ %65, %59 ], [ %50, %48 ]
  %62 = getelementptr inbounds nuw i32, ptr %0, i64 %60
  %63 = load i32, ptr %62, align 4, !tbaa !11
  %64 = add i32 %61, %16
  %65 = add i32 %64, %63
  %66 = add nuw nsw i64 %60, 1
  %67 = icmp eq i64 %66, %22
  br i1 %67, label %68, label %59, !llvm.loop !350

68:                                               ; preds = %59, %45
  %69 = phi i32 [ %47, %45 ], [ %65, %59 ]
  %70 = load double, ptr @init_value, align 8, !tbaa !33
  %71 = fptosi double %70 to i32
  %72 = add nsw i32 %18, %71
  %73 = mul nsw i32 %72, 8000
  %74 = icmp eq i32 %69, %73
  br i1 %74, label %55, label %51

75:                                               ; preds = %19, %87
  %76 = phi i32 [ %88, %87 ], [ %9, %19 ]
  %77 = phi double [ %89, %87 ], [ %20, %19 ]
  %78 = phi i32 [ %90, %87 ], [ 0, %19 ]
  %79 = fptosi double %77 to i32
  %80 = sub i32 0, %79
  %81 = icmp eq i32 %18, %80
  br i1 %81, label %87, label %82

82:                                               ; preds = %75
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %75, %82
  %88 = phi i32 [ %76, %75 ], [ %86, %82 ]
  %89 = phi double [ %77, %75 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %78, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %75, label %92, !llvm.loop !349

92:                                               ; preds = %87, %55, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %6, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp eq i32 %1, 1
  %15 = and i64 %13, 2147483646
  %16 = icmp eq i64 %15, %13
  br label %17

17:                                               ; preds = %12, %44
  %18 = phi i32 [ %45, %44 ], [ %6, %12 ]
  %19 = phi i32 [ %46, %44 ], [ 0, %12 ]
  br i1 %14, label %37, label %20

20:                                               ; preds = %17, %20
  %21 = phi i64 [ %33, %20 ], [ 0, %17 ]
  %22 = phi i32 [ %31, %20 ], [ 0, %17 ]
  %23 = phi i32 [ %32, %20 ], [ 0, %17 ]
  %24 = getelementptr inbounds nuw i32, ptr %0, i64 %21
  %25 = getelementptr inbounds nuw i32, ptr %0, i64 %21
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 4
  %27 = load i32, ptr %24, align 4, !tbaa !11
  %28 = load i32, ptr %26, align 4, !tbaa !11
  %29 = sdiv i32 %27, %2
  %30 = sdiv i32 %28, %2
  %31 = add i32 %29, %22
  %32 = add i32 %30, %23
  %33 = add nuw i64 %21, 2
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %20, !llvm.loop !351

35:                                               ; preds = %20
  %36 = add i32 %32, %31
  br i1 %16, label %57, label %37

37:                                               ; preds = %17, %35
  %38 = phi i64 [ 0, %17 ], [ %15, %35 ]
  %39 = phi i32 [ 0, %17 ], [ %36, %35 ]
  br label %48

40:                                               ; preds = %57
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %57
  %45 = phi i32 [ %43, %40 ], [ %18, %57 ]
  %46 = add nuw nsw i32 %19, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %17, label %81, !llvm.loop !352

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %55, %48 ], [ %38, %37 ]
  %50 = phi i32 [ %54, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i32, ptr %0, i64 %49
  %52 = load i32, ptr %51, align 4, !tbaa !11
  %53 = sdiv i32 %52, %2
  %54 = add nsw i32 %53, %50
  %55 = add nuw nsw i64 %49, 1
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %57, label %48, !llvm.loop !353

57:                                               ; preds = %48, %35
  %58 = phi i32 [ %36, %35 ], [ %54, %48 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptosi double %59 to i32
  %61 = sdiv i32 %60, %2
  %62 = mul nsw i32 %61, 8000
  %63 = icmp eq i32 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %10, %76
  %65 = phi i32 [ %77, %76 ], [ %6, %10 ]
  %66 = phi double [ %78, %76 ], [ %11, %10 ]
  %67 = phi i32 [ %79, %76 ], [ 0, %10 ]
  %68 = fptosi double %66 to i32
  %69 = sdiv i32 %68, %2
  %70 = icmp eq i32 %69, 0
  br i1 %70, label %76, label %71

71:                                               ; preds = %64
  %72 = load i32, ptr @current_test, align 4, !tbaa !11
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !33
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %64, %71
  %77 = phi i32 [ %65, %64 ], [ %75, %71 ]
  %78 = phi double [ %66, %64 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %67, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %64, label %81, !llvm.loop !352

81:                                               ; preds = %76, %44, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !30
  %83 = load i64, ptr @start_time, align 8, !tbaa !30
  %84 = load ptr, ptr @results, align 8, !tbaa !6
  %85 = icmp ne ptr %84, null
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %87 = load i32, ptr @current_test, align 4
  %88 = icmp slt i32 %87, %86
  %89 = select i1 %85, i1 %88, i1 false
  br i1 %89, label %101, label %90

90:                                               ; preds = %81
  %91 = add nsw i32 %86, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !11
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %84, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !6
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %90
  %97 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %101

98:                                               ; preds = %90
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %81, %96
  %102 = phi i32 [ %97, %96 ], [ %87, %81 ]
  %103 = phi ptr [ %94, %96 ], [ %84, %81 ]
  %104 = sub nsw i64 %82, %83
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !13
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !17
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %99

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp eq i32 %1, 1
  %18 = and i64 %16, 2147483646
  %19 = icmp eq i64 %18, %16
  br label %20

20:                                               ; preds = %15, %53
  %21 = phi i32 [ %54, %53 ], [ %9, %15 ]
  %22 = phi i32 [ %55, %53 ], [ 0, %15 ]
  br i1 %17, label %46, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %42, %23 ], [ 0, %20 ]
  %25 = phi i32 [ %40, %23 ], [ 0, %20 ]
  %26 = phi i32 [ %41, %23 ], [ 0, %20 ]
  %27 = getelementptr inbounds nuw i32, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i32, ptr %0, i64 %24
  %29 = getelementptr inbounds nuw i8, ptr %28, i64 4
  %30 = load i32, ptr %27, align 4, !tbaa !11
  %31 = load i32, ptr %29, align 4, !tbaa !11
  %32 = sdiv i32 %30, %2
  %33 = sdiv i32 %31, %2
  %34 = sdiv i32 %32, %3
  %35 = sdiv i32 %33, %3
  %36 = sdiv i32 %34, %4
  %37 = sdiv i32 %35, %4
  %38 = sdiv i32 %36, %5
  %39 = sdiv i32 %37, %5
  %40 = add i32 %38, %25
  %41 = add i32 %39, %26
  %42 = add nuw i64 %24, 2
  %43 = icmp eq i64 %42, %18
  br i1 %43, label %44, label %23, !llvm.loop !354

44:                                               ; preds = %23
  %45 = add i32 %41, %40
  br i1 %19, label %69, label %46

46:                                               ; preds = %20, %44
  %47 = phi i64 [ 0, %20 ], [ %18, %44 ]
  %48 = phi i32 [ 0, %20 ], [ %45, %44 ]
  br label %57

49:                                               ; preds = %69
  %50 = load i32, ptr @current_test, align 4, !tbaa !11
  %51 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %50)
  %52 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %53

53:                                               ; preds = %49, %69
  %54 = phi i32 [ %52, %49 ], [ %21, %69 ]
  %55 = add nuw nsw i32 %22, 1
  %56 = icmp slt i32 %55, %54
  br i1 %56, label %20, label %99, !llvm.loop !355

57:                                               ; preds = %46, %57
  %58 = phi i64 [ %67, %57 ], [ %47, %46 ]
  %59 = phi i32 [ %66, %57 ], [ %48, %46 ]
  %60 = getelementptr inbounds nuw i32, ptr %0, i64 %58
  %61 = load i32, ptr %60, align 4, !tbaa !11
  %62 = sdiv i32 %61, %2
  %63 = sdiv i32 %62, %3
  %64 = sdiv i32 %63, %4
  %65 = sdiv i32 %64, %5
  %66 = add nsw i32 %65, %59
  %67 = add nuw nsw i64 %58, 1
  %68 = icmp eq i64 %67, %16
  br i1 %68, label %69, label %57, !llvm.loop !356

69:                                               ; preds = %57, %44
  %70 = phi i32 [ %45, %44 ], [ %66, %57 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptosi double %71 to i32
  %73 = sdiv i32 %72, %2
  %74 = sdiv i32 %73, %3
  %75 = sdiv i32 %74, %4
  %76 = sdiv i32 %75, %5
  %77 = mul nsw i32 %76, 8000
  %78 = icmp eq i32 %70, %77
  br i1 %78, label %53, label %49

79:                                               ; preds = %13, %94
  %80 = phi i32 [ %95, %94 ], [ %9, %13 ]
  %81 = phi double [ %96, %94 ], [ %14, %13 ]
  %82 = phi i32 [ %97, %94 ], [ 0, %13 ]
  %83 = fptosi double %81 to i32
  %84 = sdiv i32 %83, %2
  %85 = sdiv i32 %84, %3
  %86 = sdiv i32 %85, %4
  %87 = sdiv i32 %86, %5
  %88 = icmp eq i32 %87, 0
  br i1 %88, label %94, label %89

89:                                               ; preds = %79
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %90)
  %92 = load double, ptr @init_value, align 8, !tbaa !33
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %79, %89
  %95 = phi i32 [ %80, %79 ], [ %93, %89 ]
  %96 = phi double [ %81, %79 ], [ %92, %89 ]
  %97 = add nuw nsw i32 %82, 1
  %98 = icmp slt i32 %97, %95
  br i1 %98, label %79, label %99, !llvm.loop !355

99:                                               ; preds = %94, %53, %7
  %100 = tail call i64 @clock() #17
  store i64 %100, ptr @end_time, align 8, !tbaa !30
  %101 = load i64, ptr @start_time, align 8, !tbaa !30
  %102 = load ptr, ptr @results, align 8, !tbaa !6
  %103 = icmp ne ptr %102, null
  %104 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %105 = load i32, ptr @current_test, align 4
  %106 = icmp slt i32 %105, %104
  %107 = select i1 %103, i1 %106, i1 false
  br i1 %107, label %119, label %108

108:                                              ; preds = %99
  %109 = add nsw i32 %104, 10
  store i32 %109, ptr @allocated_results, align 4, !tbaa !11
  %110 = sext i32 %109 to i64
  %111 = shl nsw i64 %110, 4
  %112 = tail call ptr @realloc(ptr noundef %102, i64 noundef %111) #14
  store ptr %112, ptr @results, align 8, !tbaa !6
  %113 = icmp eq ptr %112, null
  br i1 %113, label %116, label %114

114:                                              ; preds = %108
  %115 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %119

116:                                              ; preds = %108
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %118 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %117)
  tail call void @exit(i32 noundef -1) #15
  unreachable

119:                                              ; preds = %99, %114
  %120 = phi i32 [ %115, %114 ], [ %105, %99 ]
  %121 = phi ptr [ %112, %114 ], [ %102, %99 ]
  %122 = sub nsw i64 %100, %101
  %123 = sitofp i64 %122 to double
  %124 = fdiv double %123, 1.000000e+06
  %125 = sext i32 %120 to i64
  %126 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125
  store double %124, ptr %126, align 8, !tbaa !13
  %127 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125, i32 1
  store ptr %6, ptr %127, align 8, !tbaa !17
  %128 = add nsw i32 %120, 1
  store i32 %128, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %89

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sdiv i32 %2, %3
  %14 = sdiv i32 %13, %4
  %15 = sdiv i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %52, %18
  %26 = phi i32 [ %9, %18 ], [ %53, %52 ]
  %27 = phi i32 [ 0, %18 ], [ %54, %52 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <4 x i32> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <4 x i32> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i32, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x i32>, ptr %32, align 4, !tbaa !11
  %35 = load <4 x i32>, ptr %33, align 4, !tbaa !11
  %36 = add <4 x i32> %34, %30
  %37 = add <4 x i32> %35, %31
  %38 = add <4 x i32> %36, %23
  %39 = add <4 x i32> %37, %23
  %40 = add nuw i64 %29, 8
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !357

42:                                               ; preds = %28
  %43 = add <4 x i32> %39, %38
  %44 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i32 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %89, !llvm.loop !358

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i32 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i32, ptr %0, i64 %57
  %60 = load i32, ptr %59, align 4, !tbaa !11
  %61 = add i32 %60, %58
  %62 = add i32 %61, %15
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !359

65:                                               ; preds = %56, %42
  %66 = phi i32 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptosi double %67 to i32
  %69 = add nsw i32 %15, %68
  %70 = mul nsw i32 %69, 8000
  %71 = icmp eq i32 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %84
  %73 = phi i32 [ %85, %84 ], [ %9, %16 ]
  %74 = phi double [ %86, %84 ], [ %17, %16 ]
  %75 = phi i32 [ %87, %84 ], [ 0, %16 ]
  %76 = fptosi double %74 to i32
  %77 = sub i32 0, %76
  %78 = icmp eq i32 %15, %77
  br i1 %78, label %84, label %79

79:                                               ; preds = %72
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %80)
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %84

84:                                               ; preds = %72, %79
  %85 = phi i32 [ %73, %72 ], [ %83, %79 ]
  %86 = phi double [ %74, %72 ], [ %82, %79 ]
  %87 = add nuw nsw i32 %75, 1
  %88 = icmp slt i32 %87, %85
  br i1 %88, label %72, label %89, !llvm.loop !358

89:                                               ; preds = %84, %52, %7
  %90 = tail call i64 @clock() #17
  store i64 %90, ptr @end_time, align 8, !tbaa !30
  %91 = load i64, ptr @start_time, align 8, !tbaa !30
  %92 = load ptr, ptr @results, align 8, !tbaa !6
  %93 = icmp ne ptr %92, null
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %95 = load i32, ptr @current_test, align 4
  %96 = icmp slt i32 %95, %94
  %97 = select i1 %93, i1 %96, i1 false
  br i1 %97, label %109, label %98

98:                                               ; preds = %89
  %99 = add nsw i32 %94, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !11
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %92, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !6
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %98
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %109

106:                                              ; preds = %98
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %89, %104
  %110 = phi i32 [ %105, %104 ], [ %95, %89 ]
  %111 = phi ptr [ %102, %104 ], [ %92, %89 ]
  %112 = sub nsw i64 %90, %91
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !13
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %6, ptr %117, align 8, !tbaa !17
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %94

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul nsw i32 %4, %3
  %14 = sdiv i32 %13, %5
  %15 = sub i32 %2, %14
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %77

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %2, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %14, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %56, %18
  %28 = phi i32 [ %9, %18 ], [ %57, %56 ]
  %29 = phi i32 [ 0, %18 ], [ %58, %56 ]
  br i1 %20, label %49, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %44, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %42, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %43, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds nuw i32, ptr %0, i64 %31
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <4 x i32>, ptr %34, align 4, !tbaa !11
  %37 = load <4 x i32>, ptr %35, align 4, !tbaa !11
  %38 = add <4 x i32> %32, %23
  %39 = add <4 x i32> %33, %23
  %40 = add <4 x i32> %38, %36
  %41 = add <4 x i32> %39, %37
  %42 = sub <4 x i32> %40, %25
  %43 = sub <4 x i32> %41, %25
  %44 = add nuw i64 %31, 8
  %45 = icmp eq i64 %44, %21
  br i1 %45, label %46, label %30, !llvm.loop !360

46:                                               ; preds = %30
  %47 = add <4 x i32> %43, %42
  %48 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %47)
  br i1 %26, label %70, label %49

49:                                               ; preds = %27, %46
  %50 = phi i64 [ 0, %27 ], [ %21, %46 ]
  %51 = phi i32 [ 0, %27 ], [ %48, %46 ]
  br label %60

52:                                               ; preds = %70
  %53 = load i32, ptr @current_test, align 4, !tbaa !11
  %54 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %53)
  %55 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %56

56:                                               ; preds = %52, %70
  %57 = phi i32 [ %55, %52 ], [ %28, %70 ]
  %58 = add nuw nsw i32 %29, 1
  %59 = icmp slt i32 %58, %57
  br i1 %59, label %27, label %94, !llvm.loop !361

60:                                               ; preds = %49, %60
  %61 = phi i64 [ %68, %60 ], [ %50, %49 ]
  %62 = phi i32 [ %67, %60 ], [ %51, %49 ]
  %63 = getelementptr inbounds nuw i32, ptr %0, i64 %61
  %64 = load i32, ptr %63, align 4, !tbaa !11
  %65 = add i32 %62, %2
  %66 = add i32 %65, %64
  %67 = sub i32 %66, %14
  %68 = add nuw nsw i64 %61, 1
  %69 = icmp eq i64 %68, %19
  br i1 %69, label %70, label %60, !llvm.loop !362

70:                                               ; preds = %60, %46
  %71 = phi i32 [ %48, %46 ], [ %67, %60 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !33
  %73 = fptosi double %72 to i32
  %74 = add i32 %15, %73
  %75 = mul nsw i32 %74, 8000
  %76 = icmp eq i32 %71, %75
  br i1 %76, label %56, label %52

77:                                               ; preds = %16, %89
  %78 = phi i32 [ %90, %89 ], [ %9, %16 ]
  %79 = phi double [ %91, %89 ], [ %17, %16 ]
  %80 = phi i32 [ %92, %89 ], [ 0, %16 ]
  %81 = fptosi double %79 to i32
  %82 = sub i32 0, %81
  %83 = icmp eq i32 %15, %82
  br i1 %83, label %89, label %84

84:                                               ; preds = %77
  %85 = load i32, ptr @current_test, align 4, !tbaa !11
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %85)
  %87 = load double, ptr @init_value, align 8, !tbaa !33
  %88 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %89

89:                                               ; preds = %77, %84
  %90 = phi i32 [ %78, %77 ], [ %88, %84 ]
  %91 = phi double [ %79, %77 ], [ %87, %84 ]
  %92 = add nuw nsw i32 %80, 1
  %93 = icmp slt i32 %92, %90
  br i1 %93, label %77, label %94, !llvm.loop !361

94:                                               ; preds = %89, %56, %7
  %95 = tail call i64 @clock() #17
  store i64 %95, ptr @end_time, align 8, !tbaa !30
  %96 = load i64, ptr @start_time, align 8, !tbaa !30
  %97 = load ptr, ptr @results, align 8, !tbaa !6
  %98 = icmp ne ptr %97, null
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = load i32, ptr @current_test, align 4
  %101 = icmp slt i32 %100, %99
  %102 = select i1 %98, i1 %101, i1 false
  br i1 %102, label %114, label %103

103:                                              ; preds = %94
  %104 = add nsw i32 %99, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !11
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %97, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !6
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %103
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %114

111:                                              ; preds = %103
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %94, %109
  %115 = phi i32 [ %110, %109 ], [ %100, %94 ]
  %116 = phi ptr [ %107, %109 ], [ %97, %94 ]
  %117 = sub nsw i64 %95, %96
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !13
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !17
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = and <4 x i32> %28, %17
  %31 = and <4 x i32> %29, %17
  %32 = add <4 x i32> %30, %24
  %33 = add <4 x i32> %31, %25
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !363

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %83, !llvm.loop !364

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = and i32 %54, %2
  %56 = add nsw i32 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !365

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i32
  %63 = and i32 %2, %62
  %64 = mul nsw i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %10 ]
  %68 = phi double [ %80, %78 ], [ %11, %10 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %10 ]
  %70 = fptosi double %68 to i32
  %71 = and i32 %2, %70
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !364

83:                                               ; preds = %78, %46, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %104

11:                                               ; preds = %7
  %12 = and i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i32 %2, %12
  %15 = and i32 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %4, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %5, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = insertelement <4 x i32> poison, i32 %2, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = insertelement <4 x i32> poison, i32 %3, i64 0
  %29 = shufflevector <4 x i32> %28, <4 x i32> poison, <4 x i32> zeroinitializer
  %30 = and <4 x i32> %23, %25
  %31 = and <4 x i32> %23, %25
  %32 = and <4 x i32> %30, %27
  %33 = and <4 x i32> %31, %27
  %34 = and <4 x i32> %32, %29
  %35 = and <4 x i32> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = and i32 %4, %5
  %38 = and i32 %37, %2
  %39 = and i32 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <4 x i32> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <4 x i32> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i32, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <4 x i32>, ptr %47, align 4, !tbaa !11
  %50 = load <4 x i32>, ptr %48, align 4, !tbaa !11
  %51 = and <4 x i32> %49, %34
  %52 = and <4 x i32> %50, %35
  %53 = add <4 x i32> %51, %45
  %54 = add <4 x i32> %52, %46
  %55 = add nuw i64 %44, 8
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !366

57:                                               ; preds = %43
  %58 = add <4 x i32> %54, %53
  %59 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i32 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %104, !llvm.loop !367

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i32 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i32, ptr %0, i64 %72
  %75 = load i32, ptr %74, align 4, !tbaa !11
  %76 = and i32 %75, %39
  %77 = add nsw i32 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !368

80:                                               ; preds = %71, %57
  %81 = phi i32 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptosi double %82 to i32
  %84 = and i32 %15, %83
  %85 = mul nsw i32 %84, 8000
  %86 = icmp eq i32 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %99
  %88 = phi i32 [ %100, %99 ], [ %9, %16 ]
  %89 = phi double [ %101, %99 ], [ %17, %16 ]
  %90 = phi i32 [ %102, %99 ], [ 0, %16 ]
  %91 = fptosi double %89 to i32
  %92 = and i32 %15, %91
  %93 = icmp eq i32 %92, 0
  br i1 %93, label %99, label %94

94:                                               ; preds = %87
  %95 = load i32, ptr @current_test, align 4, !tbaa !11
  %96 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %95)
  %97 = load double, ptr @init_value, align 8, !tbaa !33
  %98 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %99

99:                                               ; preds = %87, %94
  %100 = phi i32 [ %88, %87 ], [ %98, %94 ]
  %101 = phi double [ %89, %87 ], [ %97, %94 ]
  %102 = add nuw nsw i32 %90, 1
  %103 = icmp slt i32 %102, %100
  br i1 %103, label %87, label %104, !llvm.loop !367

104:                                              ; preds = %99, %67, %7
  %105 = tail call i64 @clock() #17
  store i64 %105, ptr @end_time, align 8, !tbaa !30
  %106 = load i64, ptr @start_time, align 8, !tbaa !30
  %107 = load ptr, ptr @results, align 8, !tbaa !6
  %108 = icmp ne ptr %107, null
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %110 = load i32, ptr @current_test, align 4
  %111 = icmp slt i32 %110, %109
  %112 = select i1 %108, i1 %111, i1 false
  br i1 %112, label %124, label %113

113:                                              ; preds = %104
  %114 = add nsw i32 %109, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !11
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %107, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !6
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %113
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %124

121:                                              ; preds = %113
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %104, %119
  %125 = phi i32 [ %120, %119 ], [ %110, %104 ]
  %126 = phi ptr [ %117, %119 ], [ %107, %104 ]
  %127 = sub nsw i64 %105, %106
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !13
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !17
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = or <4 x i32> %28, %17
  %31 = or <4 x i32> %29, %17
  %32 = add <4 x i32> %30, %24
  %33 = add <4 x i32> %31, %25
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !369

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %83, !llvm.loop !370

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = or i32 %54, %2
  %56 = add nsw i32 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !371

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i32
  %63 = or i32 %2, %62
  %64 = mul nsw i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %10 ]
  %68 = phi double [ %80, %78 ], [ %11, %10 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %10 ]
  %70 = fptosi double %68 to i32
  %71 = or i32 %2, %70
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !370

83:                                               ; preds = %78, %46, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %104

11:                                               ; preds = %7
  %12 = or i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i32 %2, %12
  %15 = or i32 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %4, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %5, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = insertelement <4 x i32> poison, i32 %2, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = insertelement <4 x i32> poison, i32 %3, i64 0
  %29 = shufflevector <4 x i32> %28, <4 x i32> poison, <4 x i32> zeroinitializer
  %30 = or <4 x i32> %23, %25
  %31 = or <4 x i32> %23, %25
  %32 = or <4 x i32> %30, %27
  %33 = or <4 x i32> %31, %27
  %34 = or <4 x i32> %32, %29
  %35 = or <4 x i32> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = or i32 %4, %5
  %38 = or i32 %37, %2
  %39 = or i32 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <4 x i32> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <4 x i32> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i32, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <4 x i32>, ptr %47, align 4, !tbaa !11
  %50 = load <4 x i32>, ptr %48, align 4, !tbaa !11
  %51 = or <4 x i32> %49, %34
  %52 = or <4 x i32> %50, %35
  %53 = add <4 x i32> %51, %45
  %54 = add <4 x i32> %52, %46
  %55 = add nuw i64 %44, 8
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !372

57:                                               ; preds = %43
  %58 = add <4 x i32> %54, %53
  %59 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i32 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %104, !llvm.loop !373

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i32 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i32, ptr %0, i64 %72
  %75 = load i32, ptr %74, align 4, !tbaa !11
  %76 = or i32 %75, %39
  %77 = add nsw i32 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !374

80:                                               ; preds = %71, %57
  %81 = phi i32 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptosi double %82 to i32
  %84 = or i32 %15, %83
  %85 = mul nsw i32 %84, 8000
  %86 = icmp eq i32 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %99
  %88 = phi i32 [ %100, %99 ], [ %9, %16 ]
  %89 = phi double [ %101, %99 ], [ %17, %16 ]
  %90 = phi i32 [ %102, %99 ], [ 0, %16 ]
  %91 = fptosi double %89 to i32
  %92 = or i32 %15, %91
  %93 = icmp eq i32 %92, 0
  br i1 %93, label %99, label %94

94:                                               ; preds = %87
  %95 = load i32, ptr @current_test, align 4, !tbaa !11
  %96 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %95)
  %97 = load double, ptr @init_value, align 8, !tbaa !33
  %98 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %99

99:                                               ; preds = %87, %94
  %100 = phi i32 [ %88, %87 ], [ %98, %94 ]
  %101 = phi double [ %89, %87 ], [ %97, %94 ]
  %102 = add nuw nsw i32 %90, 1
  %103 = icmp slt i32 %102, %100
  br i1 %103, label %87, label %104, !llvm.loop !373

104:                                              ; preds = %99, %67, %7
  %105 = tail call i64 @clock() #17
  store i64 %105, ptr @end_time, align 8, !tbaa !30
  %106 = load i64, ptr @start_time, align 8, !tbaa !30
  %107 = load ptr, ptr @results, align 8, !tbaa !6
  %108 = icmp ne ptr %107, null
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %110 = load i32, ptr @current_test, align 4
  %111 = icmp slt i32 %110, %109
  %112 = select i1 %108, i1 %111, i1 false
  br i1 %112, label %124, label %113

113:                                              ; preds = %104
  %114 = add nsw i32 %109, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !11
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %107, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !6
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %113
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %124

121:                                              ; preds = %113
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %104, %119
  %125 = phi i32 [ %120, %119 ], [ %110, %104 ]
  %126 = phi ptr [ %117, %119 ], [ %107, %104 ]
  %127 = sub nsw i64 %105, %106
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !13
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !17
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = xor <4 x i32> %28, %17
  %31 = xor <4 x i32> %29, %17
  %32 = add <4 x i32> %30, %24
  %33 = add <4 x i32> %31, %25
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !375

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %82, !llvm.loop !376

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = xor i32 %54, %2
  %56 = add nsw i32 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !377

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i32
  %63 = xor i32 %2, %62
  %64 = mul nsw i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %77
  %67 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %68 = phi double [ %79, %77 ], [ %11, %10 ]
  %69 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %70 = fptosi double %68 to i32
  %71 = icmp eq i32 %2, %70
  br i1 %71, label %77, label %72

72:                                               ; preds = %66
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %66, %72
  %78 = phi i32 [ %67, %66 ], [ %76, %72 ]
  %79 = phi double [ %68, %66 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %69, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %66, label %82, !llvm.loop !376

82:                                               ; preds = %77, %46, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %103

11:                                               ; preds = %7
  %12 = xor i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i32 %2, %12
  %15 = xor i32 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %4, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %5, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = insertelement <4 x i32> poison, i32 %2, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = insertelement <4 x i32> poison, i32 %3, i64 0
  %29 = shufflevector <4 x i32> %28, <4 x i32> poison, <4 x i32> zeroinitializer
  %30 = xor <4 x i32> %23, %25
  %31 = xor <4 x i32> %23, %25
  %32 = xor <4 x i32> %30, %27
  %33 = xor <4 x i32> %31, %27
  %34 = xor <4 x i32> %32, %29
  %35 = xor <4 x i32> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = xor i32 %4, %5
  %38 = xor i32 %37, %2
  %39 = xor i32 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <4 x i32> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <4 x i32> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i32, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <4 x i32>, ptr %47, align 4, !tbaa !11
  %50 = load <4 x i32>, ptr %48, align 4, !tbaa !11
  %51 = xor <4 x i32> %49, %34
  %52 = xor <4 x i32> %50, %35
  %53 = add <4 x i32> %51, %45
  %54 = add <4 x i32> %52, %46
  %55 = add nuw i64 %44, 8
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !378

57:                                               ; preds = %43
  %58 = add <4 x i32> %54, %53
  %59 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i32 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %103, !llvm.loop !379

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i32 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i32, ptr %0, i64 %72
  %75 = load i32, ptr %74, align 4, !tbaa !11
  %76 = xor i32 %75, %39
  %77 = add nsw i32 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !380

80:                                               ; preds = %71, %57
  %81 = phi i32 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptosi double %82 to i32
  %84 = xor i32 %15, %83
  %85 = mul nsw i32 %84, 8000
  %86 = icmp eq i32 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %98
  %88 = phi i32 [ %99, %98 ], [ %9, %16 ]
  %89 = phi double [ %100, %98 ], [ %17, %16 ]
  %90 = phi i32 [ %101, %98 ], [ 0, %16 ]
  %91 = fptosi double %89 to i32
  %92 = icmp eq i32 %15, %91
  br i1 %92, label %98, label %93

93:                                               ; preds = %87
  %94 = load i32, ptr @current_test, align 4, !tbaa !11
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %98

98:                                               ; preds = %87, %93
  %99 = phi i32 [ %88, %87 ], [ %97, %93 ]
  %100 = phi double [ %89, %87 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %90, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %87, label %103, !llvm.loop !379

103:                                              ; preds = %98, %67, %7
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !30
  %105 = load i64, ptr @start_time, align 8, !tbaa !30
  %106 = load ptr, ptr @results, align 8, !tbaa !6
  %107 = icmp ne ptr %106, null
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = load i32, ptr @current_test, align 4
  %110 = icmp slt i32 %109, %108
  %111 = select i1 %107, i1 %110, i1 false
  br i1 %111, label %123, label %112

112:                                              ; preds = %103
  %113 = add nsw i32 %108, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !11
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %106, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !6
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %112
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %123

120:                                              ; preds = %112
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %103, %118
  %124 = phi i32 [ %119, %118 ], [ %109, %103 ]
  %125 = phi ptr [ %116, %118 ], [ %106, %103 ]
  %126 = sub nsw i64 %104, %105
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !13
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !17
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = add <4 x i32> %24, %17
  %31 = add <4 x i32> %25, %17
  %32 = add <4 x i32> %30, %28
  %33 = add <4 x i32> %31, %29
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !381

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !382

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = add i32 %52, %2
  %56 = add i32 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !383

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i32
  %63 = add i32 %2, %62
  %64 = mul i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i32
  %71 = add i32 %2, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !382

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i32 %2, %1
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %63

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 2147483640
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %43
  %19 = phi i32 [ %44, %43 ], [ %6, %13 ]
  %20 = phi i32 [ %45, %43 ], [ 0, %13 ]
  br i1 %15, label %36, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %31, %21 ], [ 0, %18 ]
  %23 = phi <4 x i32> [ %29, %21 ], [ zeroinitializer, %18 ]
  %24 = phi <4 x i32> [ %30, %21 ], [ zeroinitializer, %18 ]
  %25 = getelementptr inbounds nuw i32, ptr %0, i64 %22
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <4 x i32>, ptr %25, align 4, !tbaa !11
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = add <4 x i32> %27, %23
  %30 = add <4 x i32> %28, %24
  %31 = add nuw i64 %22, 8
  %32 = icmp eq i64 %31, %16
  br i1 %32, label %33, label %21, !llvm.loop !384

33:                                               ; preds = %21
  %34 = add <4 x i32> %30, %29
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %34)
  br i1 %17, label %55, label %36

36:                                               ; preds = %18, %33
  %37 = phi i64 [ 0, %18 ], [ %16, %33 ]
  %38 = phi i32 [ 0, %18 ], [ %35, %33 ]
  br label %47

39:                                               ; preds = %55
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %55
  %44 = phi i32 [ %42, %39 ], [ %19, %55 ]
  %45 = add nuw nsw i32 %20, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %18, label %81, !llvm.loop !385

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %53, %47 ], [ %37, %36 ]
  %49 = phi i32 [ %52, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = add i32 %51, %49
  %53 = add nuw nsw i64 %48, 1
  %54 = icmp eq i64 %53, %14
  br i1 %54, label %55, label %47, !llvm.loop !386

55:                                               ; preds = %47, %33
  %56 = phi i32 [ %35, %33 ], [ %52, %47 ]
  %57 = add i32 %56, %10
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptoui double %58 to i32
  %60 = add i32 %2, %59
  %61 = mul i32 %60, 8000
  %62 = icmp eq i32 %57, %61
  br i1 %62, label %43, label %39

63:                                               ; preds = %11, %76
  %64 = phi i32 [ %77, %76 ], [ %6, %11 ]
  %65 = phi double [ %78, %76 ], [ %12, %11 ]
  %66 = phi i32 [ %79, %76 ], [ 0, %11 ]
  %67 = fptoui double %65 to i32
  %68 = add i32 %2, %67
  %69 = mul i32 %68, 8000
  %70 = icmp eq i32 %10, %69
  br i1 %70, label %76, label %71

71:                                               ; preds = %63
  %72 = load i32, ptr @current_test, align 4, !tbaa !11
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !33
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %63, %71
  %77 = phi i32 [ %64, %63 ], [ %75, %71 ]
  %78 = phi double [ %65, %63 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %66, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %63, label %81, !llvm.loop !385

81:                                               ; preds = %76, %43, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !30
  %83 = load i64, ptr @start_time, align 8, !tbaa !30
  %84 = load ptr, ptr @results, align 8, !tbaa !6
  %85 = icmp ne ptr %84, null
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %87 = load i32, ptr @current_test, align 4
  %88 = icmp slt i32 %87, %86
  %89 = select i1 %85, i1 %88, i1 false
  br i1 %89, label %101, label %90

90:                                               ; preds = %81
  %91 = add nsw i32 %86, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !11
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %84, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !6
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %90
  %97 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %101

98:                                               ; preds = %90
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %81, %96
  %102 = phi i32 [ %97, %96 ], [ %87, %81 ]
  %103 = phi ptr [ %94, %96 ], [ %84, %81 ]
  %104 = sub nsw i64 %82, %83
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !13
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !17
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = add i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i32 %3, %2
  %15 = add i32 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <4 x i32> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <4 x i32> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i32, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x i32>, ptr %32, align 4, !tbaa !11
  %35 = load <4 x i32>, ptr %33, align 4, !tbaa !11
  %36 = add <4 x i32> %23, %30
  %37 = add <4 x i32> %23, %31
  %38 = add <4 x i32> %36, %34
  %39 = add <4 x i32> %37, %35
  %40 = add nuw i64 %29, 8
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !387

42:                                               ; preds = %28
  %43 = add <4 x i32> %39, %38
  %44 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i32 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %90, !llvm.loop !388

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i32 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i32, ptr %0, i64 %57
  %60 = load i32, ptr %59, align 4, !tbaa !11
  %61 = add i32 %15, %58
  %62 = add i32 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !389

65:                                               ; preds = %56, %42
  %66 = phi i32 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptoui double %67 to i32
  %69 = add i32 %15, %68
  %70 = mul i32 %69, 8000
  %71 = icmp eq i32 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %85
  %73 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %74 = phi double [ %87, %85 ], [ %17, %16 ]
  %75 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %76 = fptoui double %74 to i32
  %77 = add i32 %15, %76
  %78 = mul i32 %77, 8000
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %72
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %72, %80
  %86 = phi i32 [ %73, %72 ], [ %84, %80 ]
  %87 = phi double [ %74, %72 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %75, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %72, label %90, !llvm.loop !388

90:                                               ; preds = %85, %52, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = sub <4 x i32> %24, %17
  %31 = sub <4 x i32> %25, %17
  %32 = add <4 x i32> %30, %28
  %33 = add <4 x i32> %31, %29
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !390

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !391

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = sub i32 %52, %2
  %56 = add i32 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !392

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i32
  %63 = sub i32 %62, %2
  %64 = mul i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i32
  %71 = sub i32 %70, %2
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !391

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = add i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i32 %3, %2
  %15 = add i32 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <4 x i32> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <4 x i32> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i32, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x i32>, ptr %32, align 4, !tbaa !11
  %35 = load <4 x i32>, ptr %33, align 4, !tbaa !11
  %36 = sub <4 x i32> %30, %23
  %37 = sub <4 x i32> %31, %23
  %38 = add <4 x i32> %36, %34
  %39 = add <4 x i32> %37, %35
  %40 = add nuw i64 %29, 8
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !393

42:                                               ; preds = %28
  %43 = add <4 x i32> %39, %38
  %44 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i32 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %90, !llvm.loop !394

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i32 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i32, ptr %0, i64 %57
  %60 = load i32, ptr %59, align 4, !tbaa !11
  %61 = sub i32 %58, %15
  %62 = add i32 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !395

65:                                               ; preds = %56, %42
  %66 = phi i32 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptoui double %67 to i32
  %69 = sub i32 %68, %15
  %70 = mul i32 %69, 8000
  %71 = icmp eq i32 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %85
  %73 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %74 = phi double [ %87, %85 ], [ %17, %16 ]
  %75 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %76 = fptoui double %74 to i32
  %77 = sub i32 %76, %15
  %78 = mul i32 %77, 8000
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %72
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %72, %80
  %86 = phi i32 [ %73, %72 ], [ %84, %80 ]
  %87 = phi double [ %74, %72 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %75, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %72, label %90, !llvm.loop !394

90:                                               ; preds = %85, %52, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i32 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 2147483640
  %17 = insertelement <4 x i32> poison, i32 %2, i64 0
  %18 = shufflevector <4 x i32> %17, <4 x i32> poison, <4 x i32> zeroinitializer
  %19 = icmp eq i64 %16, %14
  br label %20

20:                                               ; preds = %13, %47
  %21 = phi i32 [ %48, %47 ], [ %6, %13 ]
  %22 = phi i32 [ %49, %47 ], [ 0, %13 ]
  br i1 %15, label %40, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %35, %23 ], [ 0, %20 ]
  %25 = phi <4 x i32> [ %33, %23 ], [ zeroinitializer, %20 ]
  %26 = phi <4 x i32> [ %34, %23 ], [ zeroinitializer, %20 ]
  %27 = getelementptr inbounds nuw i32, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i8, ptr %27, i64 16
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = load <4 x i32>, ptr %28, align 4, !tbaa !11
  %31 = mul <4 x i32> %29, %18
  %32 = mul <4 x i32> %30, %18
  %33 = add <4 x i32> %31, %25
  %34 = add <4 x i32> %32, %26
  %35 = add nuw i64 %24, 8
  %36 = icmp eq i64 %35, %16
  br i1 %36, label %37, label %23, !llvm.loop !396

37:                                               ; preds = %23
  %38 = add <4 x i32> %34, %33
  %39 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %38)
  br i1 %19, label %60, label %40

40:                                               ; preds = %20, %37
  %41 = phi i64 [ 0, %20 ], [ %16, %37 ]
  %42 = phi i32 [ 0, %20 ], [ %39, %37 ]
  br label %51

43:                                               ; preds = %60
  %44 = load i32, ptr @current_test, align 4, !tbaa !11
  %45 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %44)
  %46 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %47

47:                                               ; preds = %43, %60
  %48 = phi i32 [ %46, %43 ], [ %21, %60 ]
  %49 = add nuw nsw i32 %22, 1
  %50 = icmp slt i32 %49, %48
  br i1 %50, label %20, label %83, !llvm.loop !397

51:                                               ; preds = %40, %51
  %52 = phi i64 [ %58, %51 ], [ %41, %40 ]
  %53 = phi i32 [ %57, %51 ], [ %42, %40 ]
  %54 = getelementptr inbounds nuw i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, %2
  %57 = add i32 %56, %53
  %58 = add nuw nsw i64 %52, 1
  %59 = icmp eq i64 %58, %14
  br i1 %59, label %60, label %51, !llvm.loop !398

60:                                               ; preds = %51, %37
  %61 = phi i32 [ %39, %37 ], [ %57, %51 ]
  %62 = load double, ptr @init_value, align 8, !tbaa !33
  %63 = fptoui double %62 to i32
  %64 = mul i32 %10, %63
  %65 = icmp eq i32 %61, %64
  br i1 %65, label %47, label %43

66:                                               ; preds = %11, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %11 ]
  %68 = phi double [ %80, %78 ], [ %12, %11 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %11 ]
  %70 = fptoui double %68 to i32
  %71 = mul i32 %10, %70
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !397

83:                                               ; preds = %78, %47, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = mul i32 %3, 8000
  %13 = mul i32 %12, %4
  %14 = mul i32 %13, %5
  %15 = mul i32 %3, %5
  %16 = mul i32 %15, %2
  %17 = mul i32 %16, %4
  %18 = icmp sgt i32 %1, 0
  %19 = mul i32 %14, %2
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = and i64 %23, 2147483640
  %26 = insertelement <4 x i32> poison, i32 %17, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %23
  br label %29

29:                                               ; preds = %22, %56
  %30 = phi i32 [ %57, %56 ], [ %9, %22 ]
  %31 = phi i32 [ %58, %56 ], [ 0, %22 ]
  br i1 %24, label %49, label %32

32:                                               ; preds = %29, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %29 ]
  %34 = phi <4 x i32> [ %42, %32 ], [ zeroinitializer, %29 ]
  %35 = phi <4 x i32> [ %43, %32 ], [ zeroinitializer, %29 ]
  %36 = getelementptr inbounds nuw i32, ptr %0, i64 %33
  %37 = getelementptr inbounds nuw i8, ptr %36, i64 16
  %38 = load <4 x i32>, ptr %36, align 4, !tbaa !11
  %39 = load <4 x i32>, ptr %37, align 4, !tbaa !11
  %40 = mul <4 x i32> %27, %38
  %41 = mul <4 x i32> %27, %39
  %42 = add <4 x i32> %40, %34
  %43 = add <4 x i32> %41, %35
  %44 = add nuw i64 %33, 8
  %45 = icmp eq i64 %44, %25
  br i1 %45, label %46, label %32, !llvm.loop !399

46:                                               ; preds = %32
  %47 = add <4 x i32> %43, %42
  %48 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %47)
  br i1 %28, label %69, label %49

49:                                               ; preds = %29, %46
  %50 = phi i64 [ 0, %29 ], [ %25, %46 ]
  %51 = phi i32 [ 0, %29 ], [ %48, %46 ]
  br label %60

52:                                               ; preds = %69
  %53 = load i32, ptr @current_test, align 4, !tbaa !11
  %54 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %53)
  %55 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %56

56:                                               ; preds = %52, %69
  %57 = phi i32 [ %55, %52 ], [ %30, %69 ]
  %58 = add nuw nsw i32 %31, 1
  %59 = icmp slt i32 %58, %57
  br i1 %59, label %29, label %92, !llvm.loop !400

60:                                               ; preds = %49, %60
  %61 = phi i64 [ %67, %60 ], [ %50, %49 ]
  %62 = phi i32 [ %66, %60 ], [ %51, %49 ]
  %63 = getelementptr inbounds nuw i32, ptr %0, i64 %61
  %64 = load i32, ptr %63, align 4, !tbaa !11
  %65 = mul i32 %17, %64
  %66 = add i32 %65, %62
  %67 = add nuw nsw i64 %61, 1
  %68 = icmp eq i64 %67, %23
  br i1 %68, label %69, label %60, !llvm.loop !401

69:                                               ; preds = %60, %46
  %70 = phi i32 [ %48, %46 ], [ %66, %60 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptoui double %71 to i32
  %73 = mul i32 %19, %72
  %74 = icmp eq i32 %70, %73
  br i1 %74, label %56, label %52

75:                                               ; preds = %20, %87
  %76 = phi i32 [ %88, %87 ], [ %9, %20 ]
  %77 = phi double [ %89, %87 ], [ %21, %20 ]
  %78 = phi i32 [ %90, %87 ], [ 0, %20 ]
  %79 = fptoui double %77 to i32
  %80 = mul i32 %19, %79
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %75
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %75, %82
  %88 = phi i32 [ %76, %75 ], [ %86, %82 ]
  %89 = phi double [ %77, %75 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %78, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %75, label %92, !llvm.loop !400

92:                                               ; preds = %87, %56, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %6, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = mul i32 %3, %4
  %13 = mul i32 %12, %5
  %14 = mul i32 %3, %5
  %15 = mul i32 %14, %2
  %16 = mul i32 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i32 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = and i64 %22, 2147483640
  %25 = insertelement <4 x i32> poison, i32 %16, i64 0
  %26 = shufflevector <4 x i32> %25, <4 x i32> poison, <4 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %22
  br label %28

28:                                               ; preds = %21, %55
  %29 = phi i32 [ %56, %55 ], [ %9, %21 ]
  %30 = phi i32 [ %57, %55 ], [ 0, %21 ]
  br i1 %23, label %48, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %43, %31 ], [ 0, %28 ]
  %33 = phi <4 x i32> [ %41, %31 ], [ zeroinitializer, %28 ]
  %34 = phi <4 x i32> [ %42, %31 ], [ zeroinitializer, %28 ]
  %35 = getelementptr inbounds nuw i32, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <4 x i32>, ptr %35, align 4, !tbaa !11
  %38 = load <4 x i32>, ptr %36, align 4, !tbaa !11
  %39 = add <4 x i32> %33, %26
  %40 = add <4 x i32> %34, %26
  %41 = add <4 x i32> %39, %37
  %42 = add <4 x i32> %40, %38
  %43 = add nuw i64 %32, 8
  %44 = icmp eq i64 %43, %24
  br i1 %44, label %45, label %31, !llvm.loop !402

45:                                               ; preds = %31
  %46 = add <4 x i32> %42, %41
  %47 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %46)
  br i1 %27, label %68, label %48

48:                                               ; preds = %28, %45
  %49 = phi i64 [ 0, %28 ], [ %24, %45 ]
  %50 = phi i32 [ 0, %28 ], [ %47, %45 ]
  br label %59

51:                                               ; preds = %68
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %52)
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %68
  %56 = phi i32 [ %54, %51 ], [ %29, %68 ]
  %57 = add nuw nsw i32 %30, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %28, label %93, !llvm.loop !403

59:                                               ; preds = %48, %59
  %60 = phi i64 [ %66, %59 ], [ %49, %48 ]
  %61 = phi i32 [ %65, %59 ], [ %50, %48 ]
  %62 = getelementptr inbounds nuw i32, ptr %0, i64 %60
  %63 = load i32, ptr %62, align 4, !tbaa !11
  %64 = add i32 %61, %16
  %65 = add i32 %64, %63
  %66 = add nuw nsw i64 %60, 1
  %67 = icmp eq i64 %66, %22
  br i1 %67, label %68, label %59, !llvm.loop !404

68:                                               ; preds = %59, %45
  %69 = phi i32 [ %47, %45 ], [ %65, %59 ]
  %70 = load double, ptr @init_value, align 8, !tbaa !33
  %71 = fptoui double %70 to i32
  %72 = add i32 %18, %71
  %73 = mul i32 %72, 8000
  %74 = icmp eq i32 %69, %73
  br i1 %74, label %55, label %51

75:                                               ; preds = %19, %88
  %76 = phi i32 [ %89, %88 ], [ %9, %19 ]
  %77 = phi double [ %90, %88 ], [ %20, %19 ]
  %78 = phi i32 [ %91, %88 ], [ 0, %19 ]
  %79 = fptoui double %77 to i32
  %80 = add i32 %18, %79
  %81 = mul i32 %80, 8000
  %82 = icmp eq i32 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %75
  %84 = load i32, ptr @current_test, align 4, !tbaa !11
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %88

88:                                               ; preds = %75, %83
  %89 = phi i32 [ %76, %75 ], [ %87, %83 ]
  %90 = phi double [ %77, %75 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %78, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %75, label %93, !llvm.loop !403

93:                                               ; preds = %88, %55, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !30
  %95 = load i64, ptr @start_time, align 8, !tbaa !30
  %96 = load ptr, ptr @results, align 8, !tbaa !6
  %97 = icmp ne ptr %96, null
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %99 = load i32, ptr @current_test, align 4
  %100 = icmp slt i32 %99, %98
  %101 = select i1 %97, i1 %100, i1 false
  br i1 %101, label %113, label %102

102:                                              ; preds = %93
  %103 = add nsw i32 %98, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !11
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %96, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !6
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %102
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %113

110:                                              ; preds = %102
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %93, %108
  %114 = phi i32 [ %109, %108 ], [ %99, %93 ]
  %115 = phi ptr [ %106, %108 ], [ %96, %93 ]
  %116 = sub nsw i64 %94, %95
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !13
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %6, ptr %121, align 8, !tbaa !17
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp eq i32 %1, 1
  %15 = and i64 %13, 2147483646
  %16 = icmp eq i64 %15, %13
  br label %17

17:                                               ; preds = %12, %44
  %18 = phi i32 [ %45, %44 ], [ %6, %12 ]
  %19 = phi i32 [ %46, %44 ], [ 0, %12 ]
  br i1 %14, label %37, label %20

20:                                               ; preds = %17, %20
  %21 = phi i64 [ %33, %20 ], [ 0, %17 ]
  %22 = phi i32 [ %31, %20 ], [ 0, %17 ]
  %23 = phi i32 [ %32, %20 ], [ 0, %17 ]
  %24 = getelementptr inbounds nuw i32, ptr %0, i64 %21
  %25 = getelementptr inbounds nuw i32, ptr %0, i64 %21
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 4
  %27 = load i32, ptr %24, align 4, !tbaa !11
  %28 = load i32, ptr %26, align 4, !tbaa !11
  %29 = udiv i32 %27, %2
  %30 = udiv i32 %28, %2
  %31 = add i32 %29, %22
  %32 = add i32 %30, %23
  %33 = add nuw i64 %21, 2
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %20, !llvm.loop !405

35:                                               ; preds = %20
  %36 = add i32 %32, %31
  br i1 %16, label %57, label %37

37:                                               ; preds = %17, %35
  %38 = phi i64 [ 0, %17 ], [ %15, %35 ]
  %39 = phi i32 [ 0, %17 ], [ %36, %35 ]
  br label %48

40:                                               ; preds = %57
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %57
  %45 = phi i32 [ %43, %40 ], [ %18, %57 ]
  %46 = add nuw nsw i32 %19, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %17, label %82, !llvm.loop !406

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %55, %48 ], [ %38, %37 ]
  %50 = phi i32 [ %54, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i32, ptr %0, i64 %49
  %52 = load i32, ptr %51, align 4, !tbaa !11
  %53 = udiv i32 %52, %2
  %54 = add i32 %53, %50
  %55 = add nuw nsw i64 %49, 1
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %57, label %48, !llvm.loop !407

57:                                               ; preds = %48, %35
  %58 = phi i32 [ %36, %35 ], [ %54, %48 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptoui double %59 to i32
  %61 = udiv i32 %60, %2
  %62 = mul i32 %61, 8000
  %63 = icmp eq i32 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %10, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %66 = phi double [ %79, %77 ], [ %11, %10 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %68 = fptoui double %66 to i32
  %69 = udiv i32 %68, %2
  %70 = mul i32 %69, 8000
  %71 = icmp eq i32 %70, 0
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !406

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp eq i32 %1, 1
  %18 = and i64 %16, 2147483646
  %19 = icmp eq i64 %18, %16
  br label %20

20:                                               ; preds = %15, %53
  %21 = phi i32 [ %54, %53 ], [ %9, %15 ]
  %22 = phi i32 [ %55, %53 ], [ 0, %15 ]
  br i1 %17, label %46, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %42, %23 ], [ 0, %20 ]
  %25 = phi i32 [ %40, %23 ], [ 0, %20 ]
  %26 = phi i32 [ %41, %23 ], [ 0, %20 ]
  %27 = getelementptr inbounds nuw i32, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i32, ptr %0, i64 %24
  %29 = getelementptr inbounds nuw i8, ptr %28, i64 4
  %30 = load i32, ptr %27, align 4, !tbaa !11
  %31 = load i32, ptr %29, align 4, !tbaa !11
  %32 = udiv i32 %30, %2
  %33 = udiv i32 %31, %2
  %34 = udiv i32 %32, %3
  %35 = udiv i32 %33, %3
  %36 = udiv i32 %34, %4
  %37 = udiv i32 %35, %4
  %38 = udiv i32 %36, %5
  %39 = udiv i32 %37, %5
  %40 = add i32 %38, %25
  %41 = add i32 %39, %26
  %42 = add nuw i64 %24, 2
  %43 = icmp eq i64 %42, %18
  br i1 %43, label %44, label %23, !llvm.loop !408

44:                                               ; preds = %23
  %45 = add i32 %41, %40
  br i1 %19, label %69, label %46

46:                                               ; preds = %20, %44
  %47 = phi i64 [ 0, %20 ], [ %18, %44 ]
  %48 = phi i32 [ 0, %20 ], [ %45, %44 ]
  br label %57

49:                                               ; preds = %69
  %50 = load i32, ptr @current_test, align 4, !tbaa !11
  %51 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %50)
  %52 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %53

53:                                               ; preds = %49, %69
  %54 = phi i32 [ %52, %49 ], [ %21, %69 ]
  %55 = add nuw nsw i32 %22, 1
  %56 = icmp slt i32 %55, %54
  br i1 %56, label %20, label %100, !llvm.loop !409

57:                                               ; preds = %46, %57
  %58 = phi i64 [ %67, %57 ], [ %47, %46 ]
  %59 = phi i32 [ %66, %57 ], [ %48, %46 ]
  %60 = getelementptr inbounds nuw i32, ptr %0, i64 %58
  %61 = load i32, ptr %60, align 4, !tbaa !11
  %62 = udiv i32 %61, %2
  %63 = udiv i32 %62, %3
  %64 = udiv i32 %63, %4
  %65 = udiv i32 %64, %5
  %66 = add i32 %65, %59
  %67 = add nuw nsw i64 %58, 1
  %68 = icmp eq i64 %67, %16
  br i1 %68, label %69, label %57, !llvm.loop !410

69:                                               ; preds = %57, %44
  %70 = phi i32 [ %45, %44 ], [ %66, %57 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptoui double %71 to i32
  %73 = udiv i32 %72, %2
  %74 = udiv i32 %73, %3
  %75 = udiv i32 %74, %4
  %76 = udiv i32 %75, %5
  %77 = mul i32 %76, 8000
  %78 = icmp eq i32 %70, %77
  br i1 %78, label %53, label %49

79:                                               ; preds = %13, %95
  %80 = phi i32 [ %96, %95 ], [ %9, %13 ]
  %81 = phi double [ %97, %95 ], [ %14, %13 ]
  %82 = phi i32 [ %98, %95 ], [ 0, %13 ]
  %83 = fptoui double %81 to i32
  %84 = udiv i32 %83, %2
  %85 = udiv i32 %84, %3
  %86 = udiv i32 %85, %4
  %87 = udiv i32 %86, %5
  %88 = mul i32 %87, 8000
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %79
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !33
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %95

95:                                               ; preds = %79, %90
  %96 = phi i32 [ %80, %79 ], [ %94, %90 ]
  %97 = phi double [ %81, %79 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %82, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %79, label %100, !llvm.loop !409

100:                                              ; preds = %95, %53, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !30
  %102 = load i64, ptr @start_time, align 8, !tbaa !30
  %103 = load ptr, ptr @results, align 8, !tbaa !6
  %104 = icmp ne ptr %103, null
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = load i32, ptr @current_test, align 4
  %107 = icmp slt i32 %106, %105
  %108 = select i1 %104, i1 %107, i1 false
  br i1 %108, label %120, label %109

109:                                              ; preds = %100
  %110 = add nsw i32 %105, 10
  store i32 %110, ptr @allocated_results, align 4, !tbaa !11
  %111 = sext i32 %110 to i64
  %112 = shl nsw i64 %111, 4
  %113 = tail call ptr @realloc(ptr noundef %103, i64 noundef %112) #14
  store ptr %113, ptr @results, align 8, !tbaa !6
  %114 = icmp eq ptr %113, null
  br i1 %114, label %117, label %115

115:                                              ; preds = %109
  %116 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %120

117:                                              ; preds = %109
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %119 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %118)
  tail call void @exit(i32 noundef -1) #15
  unreachable

120:                                              ; preds = %100, %115
  %121 = phi i32 [ %116, %115 ], [ %106, %100 ]
  %122 = phi ptr [ %113, %115 ], [ %103, %100 ]
  %123 = sub nsw i64 %101, %102
  %124 = sitofp i64 %123 to double
  %125 = fdiv double %124, 1.000000e+06
  %126 = sext i32 %121 to i64
  %127 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126
  store double %125, ptr %127, align 8, !tbaa !13
  %128 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126, i32 1
  store ptr %6, ptr %128, align 8, !tbaa !17
  %129 = add nsw i32 %121, 1
  store i32 %129, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i32 %2, %3
  %14 = udiv i32 %13, %4
  %15 = udiv i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %52, %18
  %26 = phi i32 [ %9, %18 ], [ %53, %52 ]
  %27 = phi i32 [ 0, %18 ], [ %54, %52 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <4 x i32> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <4 x i32> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i32, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x i32>, ptr %32, align 4, !tbaa !11
  %35 = load <4 x i32>, ptr %33, align 4, !tbaa !11
  %36 = add <4 x i32> %34, %30
  %37 = add <4 x i32> %35, %31
  %38 = add <4 x i32> %36, %23
  %39 = add <4 x i32> %37, %23
  %40 = add nuw i64 %29, 8
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !411

42:                                               ; preds = %28
  %43 = add <4 x i32> %39, %38
  %44 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i32 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %90, !llvm.loop !412

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i32 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i32, ptr %0, i64 %57
  %60 = load i32, ptr %59, align 4, !tbaa !11
  %61 = add i32 %60, %58
  %62 = add i32 %61, %15
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !413

65:                                               ; preds = %56, %42
  %66 = phi i32 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptoui double %67 to i32
  %69 = add i32 %15, %68
  %70 = mul i32 %69, 8000
  %71 = icmp eq i32 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %85
  %73 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %74 = phi double [ %87, %85 ], [ %17, %16 ]
  %75 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %76 = fptoui double %74 to i32
  %77 = add i32 %15, %76
  %78 = mul i32 %77, 8000
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %72
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %72, %80
  %86 = phi i32 [ %73, %72 ], [ %84, %80 ]
  %87 = phi double [ %74, %72 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %75, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %72, label %90, !llvm.loop !412

90:                                               ; preds = %85, %52, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %95

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i32 %4, %3
  %14 = udiv i32 %13, %5
  %15 = sub i32 %2, %14
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %77

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %2, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %14, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %56, %18
  %28 = phi i32 [ %9, %18 ], [ %57, %56 ]
  %29 = phi i32 [ 0, %18 ], [ %58, %56 ]
  br i1 %20, label %49, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %44, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %42, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %43, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds nuw i32, ptr %0, i64 %31
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <4 x i32>, ptr %34, align 4, !tbaa !11
  %37 = load <4 x i32>, ptr %35, align 4, !tbaa !11
  %38 = add <4 x i32> %32, %23
  %39 = add <4 x i32> %33, %23
  %40 = add <4 x i32> %38, %36
  %41 = add <4 x i32> %39, %37
  %42 = sub <4 x i32> %40, %25
  %43 = sub <4 x i32> %41, %25
  %44 = add nuw i64 %31, 8
  %45 = icmp eq i64 %44, %21
  br i1 %45, label %46, label %30, !llvm.loop !414

46:                                               ; preds = %30
  %47 = add <4 x i32> %43, %42
  %48 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %47)
  br i1 %26, label %70, label %49

49:                                               ; preds = %27, %46
  %50 = phi i64 [ 0, %27 ], [ %21, %46 ]
  %51 = phi i32 [ 0, %27 ], [ %48, %46 ]
  br label %60

52:                                               ; preds = %70
  %53 = load i32, ptr @current_test, align 4, !tbaa !11
  %54 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %53)
  %55 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %56

56:                                               ; preds = %52, %70
  %57 = phi i32 [ %55, %52 ], [ %28, %70 ]
  %58 = add nuw nsw i32 %29, 1
  %59 = icmp slt i32 %58, %57
  br i1 %59, label %27, label %95, !llvm.loop !415

60:                                               ; preds = %49, %60
  %61 = phi i64 [ %68, %60 ], [ %50, %49 ]
  %62 = phi i32 [ %67, %60 ], [ %51, %49 ]
  %63 = getelementptr inbounds nuw i32, ptr %0, i64 %61
  %64 = load i32, ptr %63, align 4, !tbaa !11
  %65 = add i32 %62, %2
  %66 = add i32 %65, %64
  %67 = sub i32 %66, %14
  %68 = add nuw nsw i64 %61, 1
  %69 = icmp eq i64 %68, %19
  br i1 %69, label %70, label %60, !llvm.loop !416

70:                                               ; preds = %60, %46
  %71 = phi i32 [ %48, %46 ], [ %67, %60 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !33
  %73 = fptoui double %72 to i32
  %74 = add i32 %15, %73
  %75 = mul i32 %74, 8000
  %76 = icmp eq i32 %71, %75
  br i1 %76, label %56, label %52

77:                                               ; preds = %16, %90
  %78 = phi i32 [ %91, %90 ], [ %9, %16 ]
  %79 = phi double [ %92, %90 ], [ %17, %16 ]
  %80 = phi i32 [ %93, %90 ], [ 0, %16 ]
  %81 = fptoui double %79 to i32
  %82 = add i32 %15, %81
  %83 = mul i32 %82, 8000
  %84 = icmp eq i32 %83, 0
  br i1 %84, label %90, label %85

85:                                               ; preds = %77
  %86 = load i32, ptr @current_test, align 4, !tbaa !11
  %87 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %86)
  %88 = load double, ptr @init_value, align 8, !tbaa !33
  %89 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %90

90:                                               ; preds = %77, %85
  %91 = phi i32 [ %78, %77 ], [ %89, %85 ]
  %92 = phi double [ %79, %77 ], [ %88, %85 ]
  %93 = add nuw nsw i32 %80, 1
  %94 = icmp slt i32 %93, %91
  br i1 %94, label %77, label %95, !llvm.loop !415

95:                                               ; preds = %90, %56, %7
  %96 = tail call i64 @clock() #17
  store i64 %96, ptr @end_time, align 8, !tbaa !30
  %97 = load i64, ptr @start_time, align 8, !tbaa !30
  %98 = load ptr, ptr @results, align 8, !tbaa !6
  %99 = icmp ne ptr %98, null
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = load i32, ptr @current_test, align 4
  %102 = icmp slt i32 %101, %100
  %103 = select i1 %99, i1 %102, i1 false
  br i1 %103, label %115, label %104

104:                                              ; preds = %95
  %105 = add nsw i32 %100, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !11
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %98, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !6
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %104
  %111 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %115

112:                                              ; preds = %104
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %95, %110
  %116 = phi i32 [ %111, %110 ], [ %101, %95 ]
  %117 = phi ptr [ %108, %110 ], [ %98, %95 ]
  %118 = sub nsw i64 %96, %97
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !13
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !17
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = and <4 x i32> %28, %17
  %31 = and <4 x i32> %29, %17
  %32 = add <4 x i32> %30, %24
  %33 = add <4 x i32> %31, %25
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !417

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !418

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = and i32 %54, %2
  %56 = add i32 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !419

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i32
  %63 = and i32 %2, %62
  %64 = mul i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i32
  %71 = and i32 %2, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !418

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %105

11:                                               ; preds = %7
  %12 = and i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i32 %2, %12
  %15 = and i32 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %4, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %5, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = insertelement <4 x i32> poison, i32 %2, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = insertelement <4 x i32> poison, i32 %3, i64 0
  %29 = shufflevector <4 x i32> %28, <4 x i32> poison, <4 x i32> zeroinitializer
  %30 = and <4 x i32> %23, %25
  %31 = and <4 x i32> %23, %25
  %32 = and <4 x i32> %30, %27
  %33 = and <4 x i32> %31, %27
  %34 = and <4 x i32> %32, %29
  %35 = and <4 x i32> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = and i32 %4, %5
  %38 = and i32 %37, %2
  %39 = and i32 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <4 x i32> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <4 x i32> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i32, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <4 x i32>, ptr %47, align 4, !tbaa !11
  %50 = load <4 x i32>, ptr %48, align 4, !tbaa !11
  %51 = and <4 x i32> %49, %34
  %52 = and <4 x i32> %50, %35
  %53 = add <4 x i32> %51, %45
  %54 = add <4 x i32> %52, %46
  %55 = add nuw i64 %44, 8
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !420

57:                                               ; preds = %43
  %58 = add <4 x i32> %54, %53
  %59 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i32 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %105, !llvm.loop !421

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i32 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i32, ptr %0, i64 %72
  %75 = load i32, ptr %74, align 4, !tbaa !11
  %76 = and i32 %75, %39
  %77 = add i32 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !422

80:                                               ; preds = %71, %57
  %81 = phi i32 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptoui double %82 to i32
  %84 = and i32 %15, %83
  %85 = mul i32 %84, 8000
  %86 = icmp eq i32 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %100
  %88 = phi i32 [ %101, %100 ], [ %9, %16 ]
  %89 = phi double [ %102, %100 ], [ %17, %16 ]
  %90 = phi i32 [ %103, %100 ], [ 0, %16 ]
  %91 = fptoui double %89 to i32
  %92 = and i32 %15, %91
  %93 = mul i32 %92, 8000
  %94 = icmp eq i32 %93, 0
  br i1 %94, label %100, label %95

95:                                               ; preds = %87
  %96 = load i32, ptr @current_test, align 4, !tbaa !11
  %97 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %96)
  %98 = load double, ptr @init_value, align 8, !tbaa !33
  %99 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %100

100:                                              ; preds = %87, %95
  %101 = phi i32 [ %88, %87 ], [ %99, %95 ]
  %102 = phi double [ %89, %87 ], [ %98, %95 ]
  %103 = add nuw nsw i32 %90, 1
  %104 = icmp slt i32 %103, %101
  br i1 %104, label %87, label %105, !llvm.loop !421

105:                                              ; preds = %100, %67, %7
  %106 = tail call i64 @clock() #17
  store i64 %106, ptr @end_time, align 8, !tbaa !30
  %107 = load i64, ptr @start_time, align 8, !tbaa !30
  %108 = load ptr, ptr @results, align 8, !tbaa !6
  %109 = icmp ne ptr %108, null
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = load i32, ptr @current_test, align 4
  %112 = icmp slt i32 %111, %110
  %113 = select i1 %109, i1 %112, i1 false
  br i1 %113, label %125, label %114

114:                                              ; preds = %105
  %115 = add nsw i32 %110, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !11
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %108, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !6
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %114
  %121 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %125

122:                                              ; preds = %114
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %105, %120
  %126 = phi i32 [ %121, %120 ], [ %111, %105 ]
  %127 = phi ptr [ %118, %120 ], [ %108, %105 ]
  %128 = sub nsw i64 %106, %107
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !13
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !17
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = or <4 x i32> %28, %17
  %31 = or <4 x i32> %29, %17
  %32 = add <4 x i32> %30, %24
  %33 = add <4 x i32> %31, %25
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !423

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !424

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = or i32 %54, %2
  %56 = add i32 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !425

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i32
  %63 = or i32 %2, %62
  %64 = mul i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i32
  %71 = or i32 %2, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !424

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %105

11:                                               ; preds = %7
  %12 = or i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i32 %2, %12
  %15 = or i32 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %4, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %5, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = insertelement <4 x i32> poison, i32 %2, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = insertelement <4 x i32> poison, i32 %3, i64 0
  %29 = shufflevector <4 x i32> %28, <4 x i32> poison, <4 x i32> zeroinitializer
  %30 = or <4 x i32> %23, %25
  %31 = or <4 x i32> %23, %25
  %32 = or <4 x i32> %30, %27
  %33 = or <4 x i32> %31, %27
  %34 = or <4 x i32> %32, %29
  %35 = or <4 x i32> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = or i32 %4, %5
  %38 = or i32 %37, %2
  %39 = or i32 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <4 x i32> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <4 x i32> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i32, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <4 x i32>, ptr %47, align 4, !tbaa !11
  %50 = load <4 x i32>, ptr %48, align 4, !tbaa !11
  %51 = or <4 x i32> %49, %34
  %52 = or <4 x i32> %50, %35
  %53 = add <4 x i32> %51, %45
  %54 = add <4 x i32> %52, %46
  %55 = add nuw i64 %44, 8
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !426

57:                                               ; preds = %43
  %58 = add <4 x i32> %54, %53
  %59 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i32 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %105, !llvm.loop !427

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i32 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i32, ptr %0, i64 %72
  %75 = load i32, ptr %74, align 4, !tbaa !11
  %76 = or i32 %75, %39
  %77 = add i32 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !428

80:                                               ; preds = %71, %57
  %81 = phi i32 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptoui double %82 to i32
  %84 = or i32 %15, %83
  %85 = mul i32 %84, 8000
  %86 = icmp eq i32 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %100
  %88 = phi i32 [ %101, %100 ], [ %9, %16 ]
  %89 = phi double [ %102, %100 ], [ %17, %16 ]
  %90 = phi i32 [ %103, %100 ], [ 0, %16 ]
  %91 = fptoui double %89 to i32
  %92 = or i32 %15, %91
  %93 = mul i32 %92, 8000
  %94 = icmp eq i32 %93, 0
  br i1 %94, label %100, label %95

95:                                               ; preds = %87
  %96 = load i32, ptr @current_test, align 4, !tbaa !11
  %97 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %96)
  %98 = load double, ptr @init_value, align 8, !tbaa !33
  %99 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %100

100:                                              ; preds = %87, %95
  %101 = phi i32 [ %88, %87 ], [ %99, %95 ]
  %102 = phi double [ %89, %87 ], [ %98, %95 ]
  %103 = add nuw nsw i32 %90, 1
  %104 = icmp slt i32 %103, %101
  br i1 %104, label %87, label %105, !llvm.loop !427

105:                                              ; preds = %100, %67, %7
  %106 = tail call i64 @clock() #17
  store i64 %106, ptr @end_time, align 8, !tbaa !30
  %107 = load i64, ptr @start_time, align 8, !tbaa !30
  %108 = load ptr, ptr @results, align 8, !tbaa !6
  %109 = icmp ne ptr %108, null
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = load i32, ptr @current_test, align 4
  %112 = icmp slt i32 %111, %110
  %113 = select i1 %109, i1 %112, i1 false
  br i1 %113, label %125, label %114

114:                                              ; preds = %105
  %115 = add nsw i32 %110, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !11
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %108, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !6
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %114
  %121 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %125

122:                                              ; preds = %114
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %105, %120
  %126 = phi i32 [ %121, %120 ], [ %111, %105 ]
  %127 = phi ptr [ %118, %120 ], [ %108, %105 ]
  %128 = sub nsw i64 %106, %107
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !13
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !17
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <4 x i32> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <4 x i32> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i32, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %29 = load <4 x i32>, ptr %27, align 4, !tbaa !11
  %30 = xor <4 x i32> %28, %17
  %31 = xor <4 x i32> %29, %17
  %32 = add <4 x i32> %30, %24
  %33 = add <4 x i32> %31, %25
  %34 = add nuw i64 %23, 8
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !429

36:                                               ; preds = %22
  %37 = add <4 x i32> %33, %32
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i32 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !430

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i32 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = xor i32 %54, %2
  %56 = add i32 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !431

59:                                               ; preds = %50, %36
  %60 = phi i32 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i32
  %63 = xor i32 %2, %62
  %64 = mul i32 %63, 8000
  %65 = icmp eq i32 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i32
  %71 = xor i32 %2, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !430

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %105

11:                                               ; preds = %7
  %12 = xor i32 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i32 %2, %12
  %15 = xor i32 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x i32> poison, i32 %4, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %5, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = insertelement <4 x i32> poison, i32 %2, i64 0
  %27 = shufflevector <4 x i32> %26, <4 x i32> poison, <4 x i32> zeroinitializer
  %28 = insertelement <4 x i32> poison, i32 %3, i64 0
  %29 = shufflevector <4 x i32> %28, <4 x i32> poison, <4 x i32> zeroinitializer
  %30 = xor <4 x i32> %23, %25
  %31 = xor <4 x i32> %23, %25
  %32 = xor <4 x i32> %30, %27
  %33 = xor <4 x i32> %31, %27
  %34 = xor <4 x i32> %32, %29
  %35 = xor <4 x i32> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = xor i32 %4, %5
  %38 = xor i32 %37, %2
  %39 = xor i32 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <4 x i32> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <4 x i32> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i32, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <4 x i32>, ptr %47, align 4, !tbaa !11
  %50 = load <4 x i32>, ptr %48, align 4, !tbaa !11
  %51 = xor <4 x i32> %49, %34
  %52 = xor <4 x i32> %50, %35
  %53 = add <4 x i32> %51, %45
  %54 = add <4 x i32> %52, %46
  %55 = add nuw i64 %44, 8
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !432

57:                                               ; preds = %43
  %58 = add <4 x i32> %54, %53
  %59 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i32 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %105, !llvm.loop !433

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i32 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i32, ptr %0, i64 %72
  %75 = load i32, ptr %74, align 4, !tbaa !11
  %76 = xor i32 %75, %39
  %77 = add i32 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !434

80:                                               ; preds = %71, %57
  %81 = phi i32 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptoui double %82 to i32
  %84 = xor i32 %15, %83
  %85 = mul i32 %84, 8000
  %86 = icmp eq i32 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %100
  %88 = phi i32 [ %101, %100 ], [ %9, %16 ]
  %89 = phi double [ %102, %100 ], [ %17, %16 ]
  %90 = phi i32 [ %103, %100 ], [ 0, %16 ]
  %91 = fptoui double %89 to i32
  %92 = xor i32 %15, %91
  %93 = mul i32 %92, 8000
  %94 = icmp eq i32 %93, 0
  br i1 %94, label %100, label %95

95:                                               ; preds = %87
  %96 = load i32, ptr @current_test, align 4, !tbaa !11
  %97 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %96)
  %98 = load double, ptr @init_value, align 8, !tbaa !33
  %99 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %100

100:                                              ; preds = %87, %95
  %101 = phi i32 [ %88, %87 ], [ %99, %95 ]
  %102 = phi double [ %89, %87 ], [ %98, %95 ]
  %103 = add nuw nsw i32 %90, 1
  %104 = icmp slt i32 %103, %101
  br i1 %104, label %87, label %105, !llvm.loop !433

105:                                              ; preds = %100, %67, %7
  %106 = tail call i64 @clock() #17
  store i64 %106, ptr @end_time, align 8, !tbaa !30
  %107 = load i64, ptr @start_time, align 8, !tbaa !30
  %108 = load ptr, ptr @results, align 8, !tbaa !6
  %109 = icmp ne ptr %108, null
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = load i32, ptr @current_test, align 4
  %112 = icmp slt i32 %111, %110
  %113 = select i1 %109, i1 %112, i1 false
  br i1 %113, label %125, label %114

114:                                              ; preds = %105
  %115 = add nsw i32 %110, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !11
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %108, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !6
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %114
  %121 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %125

122:                                              ; preds = %114
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %105, %120
  %126 = phi i32 [ %121, %120 ], [ %111, %105 ]
  %127 = phi ptr [ %118, %120 ], [ %108, %105 ]
  %128 = sub nsw i64 %106, %107
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !13
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !17
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = add <2 x i64> %24, %17
  %31 = add <2 x i64> %25, %17
  %32 = add <2 x i64> %30, %28
  %33 = add <2 x i64> %31, %29
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !435

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %83, !llvm.loop !436

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = add i64 %52, %2
  %56 = add i64 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !437

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i64
  %63 = add nsw i64 %2, %62
  %64 = mul nsw i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %10 ]
  %68 = phi double [ %80, %78 ], [ %11, %10 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %10 ]
  %70 = fptosi double %68 to i64
  %71 = sub i64 0, %70
  %72 = icmp eq i64 %2, %71
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !436

83:                                               ; preds = %78, %46, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i32 %1 to i64
  %11 = mul nsw i64 %2, %10
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

14:                                               ; preds = %8
  %15 = zext nneg i32 %1 to i64
  %16 = icmp ult i32 %1, 4
  %17 = and i64 %15, 2147483644
  %18 = icmp eq i64 %17, %15
  br label %19

19:                                               ; preds = %14, %44
  %20 = phi i32 [ %45, %44 ], [ %6, %14 ]
  %21 = phi i32 [ %46, %44 ], [ 0, %14 ]
  br i1 %16, label %37, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %32, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %30, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %31, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = add <2 x i64> %28, %24
  %31 = add <2 x i64> %29, %25
  %32 = add nuw i64 %23, 4
  %33 = icmp eq i64 %32, %17
  br i1 %33, label %34, label %22, !llvm.loop !438

34:                                               ; preds = %22
  %35 = add <2 x i64> %31, %30
  %36 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %35)
  br i1 %18, label %56, label %37

37:                                               ; preds = %19, %34
  %38 = phi i64 [ 0, %19 ], [ %17, %34 ]
  %39 = phi i64 [ 0, %19 ], [ %36, %34 ]
  br label %48

40:                                               ; preds = %56
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %56
  %45 = phi i32 [ %43, %40 ], [ %20, %56 ]
  %46 = add nuw nsw i32 %21, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %19, label %82, !llvm.loop !439

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %54, %48 ], [ %38, %37 ]
  %50 = phi i64 [ %53, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i64, ptr %0, i64 %49
  %52 = load i64, ptr %51, align 8, !tbaa !30
  %53 = add nsw i64 %52, %50
  %54 = add nuw nsw i64 %49, 1
  %55 = icmp eq i64 %54, %15
  br i1 %55, label %56, label %48, !llvm.loop !440

56:                                               ; preds = %48, %34
  %57 = phi i64 [ %36, %34 ], [ %53, %48 ]
  %58 = add nsw i64 %57, %11
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptosi double %59 to i64
  %61 = add nsw i64 %2, %60
  %62 = mul nsw i64 %61, 8000
  %63 = icmp eq i64 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %12, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %12 ]
  %66 = phi double [ %79, %77 ], [ %13, %12 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %12 ]
  %68 = fptosi double %66 to i64
  %69 = add nsw i64 %2, %68
  %70 = mul nsw i64 %69, 8000
  %71 = icmp eq i64 %11, %70
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !439

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %89

11:                                               ; preds = %7
  %12 = add i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i64 %3, %2
  %15 = add i64 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <2 x i64> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <2 x i64> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i64, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x i64>, ptr %32, align 8, !tbaa !30
  %35 = load <2 x i64>, ptr %33, align 8, !tbaa !30
  %36 = add <2 x i64> %23, %30
  %37 = add <2 x i64> %23, %31
  %38 = add <2 x i64> %36, %34
  %39 = add <2 x i64> %37, %35
  %40 = add nuw i64 %29, 4
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !441

42:                                               ; preds = %28
  %43 = add <2 x i64> %39, %38
  %44 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i64 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %89, !llvm.loop !442

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i64 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i64, ptr %0, i64 %57
  %60 = load i64, ptr %59, align 8, !tbaa !30
  %61 = add i64 %15, %58
  %62 = add i64 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !443

65:                                               ; preds = %56, %42
  %66 = phi i64 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptosi double %67 to i64
  %69 = add i64 %15, %68
  %70 = mul nsw i64 %69, 8000
  %71 = icmp eq i64 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %84
  %73 = phi i32 [ %85, %84 ], [ %9, %16 ]
  %74 = phi double [ %86, %84 ], [ %17, %16 ]
  %75 = phi i32 [ %87, %84 ], [ 0, %16 ]
  %76 = fptosi double %74 to i64
  %77 = sub i64 0, %76
  %78 = icmp eq i64 %15, %77
  br i1 %78, label %84, label %79

79:                                               ; preds = %72
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %80)
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %84

84:                                               ; preds = %72, %79
  %85 = phi i32 [ %73, %72 ], [ %83, %79 ]
  %86 = phi double [ %74, %72 ], [ %82, %79 ]
  %87 = add nuw nsw i32 %75, 1
  %88 = icmp slt i32 %87, %85
  br i1 %88, label %72, label %89, !llvm.loop !442

89:                                               ; preds = %84, %52, %7
  %90 = tail call i64 @clock() #17
  store i64 %90, ptr @end_time, align 8, !tbaa !30
  %91 = load i64, ptr @start_time, align 8, !tbaa !30
  %92 = load ptr, ptr @results, align 8, !tbaa !6
  %93 = icmp ne ptr %92, null
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %95 = load i32, ptr @current_test, align 4
  %96 = icmp slt i32 %95, %94
  %97 = select i1 %93, i1 %96, i1 false
  br i1 %97, label %109, label %98

98:                                               ; preds = %89
  %99 = add nsw i32 %94, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !11
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %92, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !6
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %98
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %109

106:                                              ; preds = %98
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %89, %104
  %110 = phi i32 [ %105, %104 ], [ %95, %89 ]
  %111 = phi ptr [ %102, %104 ], [ %92, %89 ]
  %112 = sub nsw i64 %90, %91
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !13
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %6, ptr %117, align 8, !tbaa !17
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = sub <2 x i64> %24, %17
  %31 = sub <2 x i64> %25, %17
  %32 = add <2 x i64> %30, %28
  %33 = add <2 x i64> %31, %29
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !444

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %82, !llvm.loop !445

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = sub i64 %52, %2
  %56 = add i64 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !446

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i64
  %63 = sub nsw i64 %62, %2
  %64 = mul nsw i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %77
  %67 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %68 = phi double [ %79, %77 ], [ %11, %10 ]
  %69 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %70 = fptosi double %68 to i64
  %71 = icmp eq i64 %2, %70
  br i1 %71, label %77, label %72

72:                                               ; preds = %66
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %66, %72
  %78 = phi i32 [ %67, %66 ], [ %76, %72 ]
  %79 = phi double [ %68, %66 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %69, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %66, label %82, !llvm.loop !445

82:                                               ; preds = %77, %46, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %88

11:                                               ; preds = %7
  %12 = add i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i64 %3, %2
  %15 = add i64 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <2 x i64> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <2 x i64> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i64, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x i64>, ptr %32, align 8, !tbaa !30
  %35 = load <2 x i64>, ptr %33, align 8, !tbaa !30
  %36 = sub <2 x i64> %30, %23
  %37 = sub <2 x i64> %31, %23
  %38 = add <2 x i64> %36, %34
  %39 = add <2 x i64> %37, %35
  %40 = add nuw i64 %29, 4
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !447

42:                                               ; preds = %28
  %43 = add <2 x i64> %39, %38
  %44 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i64 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %88, !llvm.loop !448

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i64 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i64, ptr %0, i64 %57
  %60 = load i64, ptr %59, align 8, !tbaa !30
  %61 = sub i64 %58, %15
  %62 = add i64 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !449

65:                                               ; preds = %56, %42
  %66 = phi i64 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptosi double %67 to i64
  %69 = sub i64 %68, %15
  %70 = mul nsw i64 %69, 8000
  %71 = icmp eq i64 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %83
  %73 = phi i32 [ %84, %83 ], [ %9, %16 ]
  %74 = phi double [ %85, %83 ], [ %17, %16 ]
  %75 = phi i32 [ %86, %83 ], [ 0, %16 ]
  %76 = fptosi double %74 to i64
  %77 = icmp eq i64 %15, %76
  br i1 %77, label %83, label %78

78:                                               ; preds = %72
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %79)
  %81 = load double, ptr @init_value, align 8, !tbaa !33
  %82 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %83

83:                                               ; preds = %72, %78
  %84 = phi i32 [ %73, %72 ], [ %82, %78 ]
  %85 = phi double [ %74, %72 ], [ %81, %78 ]
  %86 = add nuw nsw i32 %75, 1
  %87 = icmp slt i32 %86, %84
  br i1 %87, label %72, label %88, !llvm.loop !448

88:                                               ; preds = %83, %52, %7
  %89 = tail call i64 @clock() #17
  store i64 %89, ptr @end_time, align 8, !tbaa !30
  %90 = load i64, ptr @start_time, align 8, !tbaa !30
  %91 = load ptr, ptr @results, align 8, !tbaa !6
  %92 = icmp ne ptr %91, null
  %93 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %94 = load i32, ptr @current_test, align 4
  %95 = icmp slt i32 %94, %93
  %96 = select i1 %92, i1 %95, i1 false
  br i1 %96, label %108, label %97

97:                                               ; preds = %88
  %98 = add nsw i32 %93, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !11
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %91, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !6
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %97
  %104 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %108

105:                                              ; preds = %97
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %88, %103
  %109 = phi i32 [ %104, %103 ], [ %94, %88 ]
  %110 = phi ptr [ %101, %103 ], [ %91, %88 ]
  %111 = sub nsw i64 %89, %90
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !13
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %6, ptr %116, align 8, !tbaa !17
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i64 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %14, 2147483646
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %45
  %19 = phi i32 [ %46, %45 ], [ %6, %13 ]
  %20 = phi i32 [ %47, %45 ], [ 0, %13 ]
  br i1 %15, label %38, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %34, %21 ], [ 0, %18 ]
  %23 = phi i64 [ %32, %21 ], [ 0, %18 ]
  %24 = phi i64 [ %33, %21 ], [ 0, %18 ]
  %25 = getelementptr inbounds nuw i64, ptr %0, i64 %22
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %22
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 8
  %28 = load i64, ptr %25, align 8, !tbaa !30
  %29 = load i64, ptr %27, align 8, !tbaa !30
  %30 = mul nsw i64 %28, %2
  %31 = mul nsw i64 %29, %2
  %32 = add i64 %30, %23
  %33 = add i64 %31, %24
  %34 = add nuw i64 %22, 2
  %35 = icmp eq i64 %34, %16
  br i1 %35, label %36, label %21, !llvm.loop !450

36:                                               ; preds = %21
  %37 = add i64 %33, %32
  br i1 %17, label %58, label %38

38:                                               ; preds = %18, %36
  %39 = phi i64 [ 0, %18 ], [ %16, %36 ]
  %40 = phi i64 [ 0, %18 ], [ %37, %36 ]
  br label %49

41:                                               ; preds = %58
  %42 = load i32, ptr @current_test, align 4, !tbaa !11
  %43 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %42)
  %44 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %45

45:                                               ; preds = %41, %58
  %46 = phi i32 [ %44, %41 ], [ %19, %58 ]
  %47 = add nuw nsw i32 %20, 1
  %48 = icmp slt i32 %47, %46
  br i1 %48, label %18, label %81, !llvm.loop !451

49:                                               ; preds = %38, %49
  %50 = phi i64 [ %56, %49 ], [ %39, %38 ]
  %51 = phi i64 [ %55, %49 ], [ %40, %38 ]
  %52 = getelementptr inbounds nuw i64, ptr %0, i64 %50
  %53 = load i64, ptr %52, align 8, !tbaa !30
  %54 = mul nsw i64 %53, %2
  %55 = add nsw i64 %54, %51
  %56 = add nuw nsw i64 %50, 1
  %57 = icmp eq i64 %56, %14
  br i1 %57, label %58, label %49, !llvm.loop !452

58:                                               ; preds = %49, %36
  %59 = phi i64 [ %37, %36 ], [ %55, %49 ]
  %60 = load double, ptr @init_value, align 8, !tbaa !33
  %61 = fptosi double %60 to i64
  %62 = mul i64 %10, %61
  %63 = icmp eq i64 %59, %62
  br i1 %63, label %45, label %41

64:                                               ; preds = %11, %76
  %65 = phi i32 [ %77, %76 ], [ %6, %11 ]
  %66 = phi double [ %78, %76 ], [ %12, %11 ]
  %67 = phi i32 [ %79, %76 ], [ 0, %11 ]
  %68 = fptosi double %66 to i64
  %69 = mul i64 %10, %68
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %76, label %71

71:                                               ; preds = %64
  %72 = load i32, ptr @current_test, align 4, !tbaa !11
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !33
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %64, %71
  %77 = phi i32 [ %65, %64 ], [ %75, %71 ]
  %78 = phi double [ %66, %64 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %67, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %64, label %81, !llvm.loop !451

81:                                               ; preds = %76, %45, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !30
  %83 = load i64, ptr @start_time, align 8, !tbaa !30
  %84 = load ptr, ptr @results, align 8, !tbaa !6
  %85 = icmp ne ptr %84, null
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %87 = load i32, ptr @current_test, align 4
  %88 = icmp slt i32 %87, %86
  %89 = select i1 %85, i1 %88, i1 false
  br i1 %89, label %101, label %90

90:                                               ; preds = %81
  %91 = add nsw i32 %86, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !11
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %84, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !6
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %90
  %97 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %101

98:                                               ; preds = %90
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %81, %96
  %102 = phi i32 [ %97, %96 ], [ %87, %81 ]
  %103 = phi ptr [ %94, %96 ], [ %84, %81 ]
  %104 = sub nsw i64 %82, %83
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !13
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !17
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = mul i64 %3, 8000
  %13 = mul i64 %12, %4
  %14 = mul i64 %13, %5
  %15 = mul i64 %3, %5
  %16 = mul i64 %15, %2
  %17 = mul i64 %16, %4
  %18 = icmp sgt i32 %1, 0
  %19 = mul i64 %14, %2
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %73

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp eq i32 %1, 1
  %25 = and i64 %23, 2147483646
  %26 = icmp eq i64 %25, %23
  br label %27

27:                                               ; preds = %22, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %22 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %22 ]
  br i1 %24, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %43, %30 ], [ 0, %27 ]
  %32 = phi i64 [ %41, %30 ], [ 0, %27 ]
  %33 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %34 = getelementptr inbounds nuw i64, ptr %0, i64 %31
  %35 = getelementptr inbounds nuw i64, ptr %0, i64 %31
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 8
  %37 = load i64, ptr %34, align 8, !tbaa !30
  %38 = load i64, ptr %36, align 8, !tbaa !30
  %39 = mul i64 %17, %37
  %40 = mul i64 %17, %38
  %41 = add i64 %39, %32
  %42 = add i64 %40, %33
  %43 = add nuw i64 %31, 2
  %44 = icmp eq i64 %43, %25
  br i1 %44, label %45, label %30, !llvm.loop !453

45:                                               ; preds = %30
  %46 = add i64 %42, %41
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %45
  %48 = phi i64 [ 0, %27 ], [ %25, %45 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %45 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !11
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %90, !llvm.loop !454

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds nuw i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !30
  %63 = mul i64 %17, %62
  %64 = add nsw i64 %63, %60
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %23
  br i1 %66, label %67, label %58, !llvm.loop !455

67:                                               ; preds = %58, %45
  %68 = phi i64 [ %46, %45 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !33
  %70 = fptosi double %69 to i64
  %71 = mul i64 %19, %70
  %72 = icmp eq i64 %68, %71
  br i1 %72, label %54, label %50

73:                                               ; preds = %20, %85
  %74 = phi i32 [ %86, %85 ], [ %9, %20 ]
  %75 = phi double [ %87, %85 ], [ %21, %20 ]
  %76 = phi i32 [ %88, %85 ], [ 0, %20 ]
  %77 = fptosi double %75 to i64
  %78 = mul i64 %19, %77
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %73
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %73, %80
  %86 = phi i32 [ %74, %73 ], [ %84, %80 ]
  %87 = phi double [ %75, %73 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %76, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %73, label %90, !llvm.loop !454

90:                                               ; preds = %85, %54, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = mul i64 %3, %4
  %13 = mul i64 %12, %5
  %14 = mul i64 %3, %5
  %15 = mul i64 %14, %2
  %16 = mul i64 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i64 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 4
  %24 = and i64 %22, 2147483644
  %25 = insertelement <2 x i64> poison, i64 %16, i64 0
  %26 = shufflevector <2 x i64> %25, <2 x i64> poison, <2 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %22
  br label %28

28:                                               ; preds = %21, %55
  %29 = phi i32 [ %56, %55 ], [ %9, %21 ]
  %30 = phi i32 [ %57, %55 ], [ 0, %21 ]
  br i1 %23, label %48, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %43, %31 ], [ 0, %28 ]
  %33 = phi <2 x i64> [ %41, %31 ], [ zeroinitializer, %28 ]
  %34 = phi <2 x i64> [ %42, %31 ], [ zeroinitializer, %28 ]
  %35 = getelementptr inbounds nuw i64, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <2 x i64>, ptr %35, align 8, !tbaa !30
  %38 = load <2 x i64>, ptr %36, align 8, !tbaa !30
  %39 = add <2 x i64> %33, %26
  %40 = add <2 x i64> %34, %26
  %41 = add <2 x i64> %39, %37
  %42 = add <2 x i64> %40, %38
  %43 = add nuw i64 %32, 4
  %44 = icmp eq i64 %43, %24
  br i1 %44, label %45, label %31, !llvm.loop !456

45:                                               ; preds = %31
  %46 = add <2 x i64> %42, %41
  %47 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %46)
  br i1 %27, label %68, label %48

48:                                               ; preds = %28, %45
  %49 = phi i64 [ 0, %28 ], [ %24, %45 ]
  %50 = phi i64 [ 0, %28 ], [ %47, %45 ]
  br label %59

51:                                               ; preds = %68
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %52)
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %68
  %56 = phi i32 [ %54, %51 ], [ %29, %68 ]
  %57 = add nuw nsw i32 %30, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %28, label %92, !llvm.loop !457

59:                                               ; preds = %48, %59
  %60 = phi i64 [ %66, %59 ], [ %49, %48 ]
  %61 = phi i64 [ %65, %59 ], [ %50, %48 ]
  %62 = getelementptr inbounds nuw i64, ptr %0, i64 %60
  %63 = load i64, ptr %62, align 8, !tbaa !30
  %64 = add i64 %61, %16
  %65 = add i64 %64, %63
  %66 = add nuw nsw i64 %60, 1
  %67 = icmp eq i64 %66, %22
  br i1 %67, label %68, label %59, !llvm.loop !458

68:                                               ; preds = %59, %45
  %69 = phi i64 [ %47, %45 ], [ %65, %59 ]
  %70 = load double, ptr @init_value, align 8, !tbaa !33
  %71 = fptosi double %70 to i64
  %72 = add nsw i64 %18, %71
  %73 = mul nsw i64 %72, 8000
  %74 = icmp eq i64 %69, %73
  br i1 %74, label %55, label %51

75:                                               ; preds = %19, %87
  %76 = phi i32 [ %88, %87 ], [ %9, %19 ]
  %77 = phi double [ %89, %87 ], [ %20, %19 ]
  %78 = phi i32 [ %90, %87 ], [ 0, %19 ]
  %79 = fptosi double %77 to i64
  %80 = sub i64 0, %79
  %81 = icmp eq i64 %18, %80
  br i1 %81, label %87, label %82

82:                                               ; preds = %75
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %75, %82
  %88 = phi i32 [ %76, %75 ], [ %86, %82 ]
  %89 = phi double [ %77, %75 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %78, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %75, label %92, !llvm.loop !457

92:                                               ; preds = %87, %55, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %6, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp eq i32 %1, 1
  %15 = and i64 %13, 2147483646
  %16 = icmp eq i64 %15, %13
  br label %17

17:                                               ; preds = %12, %44
  %18 = phi i32 [ %45, %44 ], [ %6, %12 ]
  %19 = phi i32 [ %46, %44 ], [ 0, %12 ]
  br i1 %14, label %37, label %20

20:                                               ; preds = %17, %20
  %21 = phi i64 [ %33, %20 ], [ 0, %17 ]
  %22 = phi i64 [ %31, %20 ], [ 0, %17 ]
  %23 = phi i64 [ %32, %20 ], [ 0, %17 ]
  %24 = getelementptr inbounds nuw i64, ptr %0, i64 %21
  %25 = getelementptr inbounds nuw i64, ptr %0, i64 %21
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 8
  %27 = load i64, ptr %24, align 8, !tbaa !30
  %28 = load i64, ptr %26, align 8, !tbaa !30
  %29 = sdiv i64 %27, %2
  %30 = sdiv i64 %28, %2
  %31 = add i64 %29, %22
  %32 = add i64 %30, %23
  %33 = add nuw i64 %21, 2
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %20, !llvm.loop !459

35:                                               ; preds = %20
  %36 = add i64 %32, %31
  br i1 %16, label %57, label %37

37:                                               ; preds = %17, %35
  %38 = phi i64 [ 0, %17 ], [ %15, %35 ]
  %39 = phi i64 [ 0, %17 ], [ %36, %35 ]
  br label %48

40:                                               ; preds = %57
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %57
  %45 = phi i32 [ %43, %40 ], [ %18, %57 ]
  %46 = add nuw nsw i32 %19, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %17, label %81, !llvm.loop !460

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %55, %48 ], [ %38, %37 ]
  %50 = phi i64 [ %54, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i64, ptr %0, i64 %49
  %52 = load i64, ptr %51, align 8, !tbaa !30
  %53 = sdiv i64 %52, %2
  %54 = add nsw i64 %53, %50
  %55 = add nuw nsw i64 %49, 1
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %57, label %48, !llvm.loop !461

57:                                               ; preds = %48, %35
  %58 = phi i64 [ %36, %35 ], [ %54, %48 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptosi double %59 to i64
  %61 = sdiv i64 %60, %2
  %62 = mul nsw i64 %61, 8000
  %63 = icmp eq i64 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %10, %76
  %65 = phi i32 [ %77, %76 ], [ %6, %10 ]
  %66 = phi double [ %78, %76 ], [ %11, %10 ]
  %67 = phi i32 [ %79, %76 ], [ 0, %10 ]
  %68 = fptosi double %66 to i64
  %69 = sdiv i64 %68, %2
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %76, label %71

71:                                               ; preds = %64
  %72 = load i32, ptr @current_test, align 4, !tbaa !11
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !33
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %64, %71
  %77 = phi i32 [ %65, %64 ], [ %75, %71 ]
  %78 = phi double [ %66, %64 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %67, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %64, label %81, !llvm.loop !460

81:                                               ; preds = %76, %44, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !30
  %83 = load i64, ptr @start_time, align 8, !tbaa !30
  %84 = load ptr, ptr @results, align 8, !tbaa !6
  %85 = icmp ne ptr %84, null
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %87 = load i32, ptr @current_test, align 4
  %88 = icmp slt i32 %87, %86
  %89 = select i1 %85, i1 %88, i1 false
  br i1 %89, label %101, label %90

90:                                               ; preds = %81
  %91 = add nsw i32 %86, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !11
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %84, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !6
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %90
  %97 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %101

98:                                               ; preds = %90
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %81, %96
  %102 = phi i32 [ %97, %96 ], [ %87, %81 ]
  %103 = phi ptr [ %94, %96 ], [ %84, %81 ]
  %104 = sub nsw i64 %82, %83
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !13
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !17
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %99

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp eq i32 %1, 1
  %18 = and i64 %16, 2147483646
  %19 = icmp eq i64 %18, %16
  br label %20

20:                                               ; preds = %15, %53
  %21 = phi i32 [ %54, %53 ], [ %9, %15 ]
  %22 = phi i32 [ %55, %53 ], [ 0, %15 ]
  br i1 %17, label %46, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %42, %23 ], [ 0, %20 ]
  %25 = phi i64 [ %40, %23 ], [ 0, %20 ]
  %26 = phi i64 [ %41, %23 ], [ 0, %20 ]
  %27 = getelementptr inbounds nuw i64, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i64, ptr %0, i64 %24
  %29 = getelementptr inbounds nuw i8, ptr %28, i64 8
  %30 = load i64, ptr %27, align 8, !tbaa !30
  %31 = load i64, ptr %29, align 8, !tbaa !30
  %32 = sdiv i64 %30, %2
  %33 = sdiv i64 %31, %2
  %34 = sdiv i64 %32, %3
  %35 = sdiv i64 %33, %3
  %36 = sdiv i64 %34, %4
  %37 = sdiv i64 %35, %4
  %38 = sdiv i64 %36, %5
  %39 = sdiv i64 %37, %5
  %40 = add i64 %38, %25
  %41 = add i64 %39, %26
  %42 = add nuw i64 %24, 2
  %43 = icmp eq i64 %42, %18
  br i1 %43, label %44, label %23, !llvm.loop !462

44:                                               ; preds = %23
  %45 = add i64 %41, %40
  br i1 %19, label %69, label %46

46:                                               ; preds = %20, %44
  %47 = phi i64 [ 0, %20 ], [ %18, %44 ]
  %48 = phi i64 [ 0, %20 ], [ %45, %44 ]
  br label %57

49:                                               ; preds = %69
  %50 = load i32, ptr @current_test, align 4, !tbaa !11
  %51 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %50)
  %52 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %53

53:                                               ; preds = %49, %69
  %54 = phi i32 [ %52, %49 ], [ %21, %69 ]
  %55 = add nuw nsw i32 %22, 1
  %56 = icmp slt i32 %55, %54
  br i1 %56, label %20, label %99, !llvm.loop !463

57:                                               ; preds = %46, %57
  %58 = phi i64 [ %67, %57 ], [ %47, %46 ]
  %59 = phi i64 [ %66, %57 ], [ %48, %46 ]
  %60 = getelementptr inbounds nuw i64, ptr %0, i64 %58
  %61 = load i64, ptr %60, align 8, !tbaa !30
  %62 = sdiv i64 %61, %2
  %63 = sdiv i64 %62, %3
  %64 = sdiv i64 %63, %4
  %65 = sdiv i64 %64, %5
  %66 = add nsw i64 %65, %59
  %67 = add nuw nsw i64 %58, 1
  %68 = icmp eq i64 %67, %16
  br i1 %68, label %69, label %57, !llvm.loop !464

69:                                               ; preds = %57, %44
  %70 = phi i64 [ %45, %44 ], [ %66, %57 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptosi double %71 to i64
  %73 = sdiv i64 %72, %2
  %74 = sdiv i64 %73, %3
  %75 = sdiv i64 %74, %4
  %76 = sdiv i64 %75, %5
  %77 = mul nsw i64 %76, 8000
  %78 = icmp eq i64 %70, %77
  br i1 %78, label %53, label %49

79:                                               ; preds = %13, %94
  %80 = phi i32 [ %95, %94 ], [ %9, %13 ]
  %81 = phi double [ %96, %94 ], [ %14, %13 ]
  %82 = phi i32 [ %97, %94 ], [ 0, %13 ]
  %83 = fptosi double %81 to i64
  %84 = sdiv i64 %83, %2
  %85 = sdiv i64 %84, %3
  %86 = sdiv i64 %85, %4
  %87 = sdiv i64 %86, %5
  %88 = icmp eq i64 %87, 0
  br i1 %88, label %94, label %89

89:                                               ; preds = %79
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %90)
  %92 = load double, ptr @init_value, align 8, !tbaa !33
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %79, %89
  %95 = phi i32 [ %80, %79 ], [ %93, %89 ]
  %96 = phi double [ %81, %79 ], [ %92, %89 ]
  %97 = add nuw nsw i32 %82, 1
  %98 = icmp slt i32 %97, %95
  br i1 %98, label %79, label %99, !llvm.loop !463

99:                                               ; preds = %94, %53, %7
  %100 = tail call i64 @clock() #17
  store i64 %100, ptr @end_time, align 8, !tbaa !30
  %101 = load i64, ptr @start_time, align 8, !tbaa !30
  %102 = load ptr, ptr @results, align 8, !tbaa !6
  %103 = icmp ne ptr %102, null
  %104 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %105 = load i32, ptr @current_test, align 4
  %106 = icmp slt i32 %105, %104
  %107 = select i1 %103, i1 %106, i1 false
  br i1 %107, label %119, label %108

108:                                              ; preds = %99
  %109 = add nsw i32 %104, 10
  store i32 %109, ptr @allocated_results, align 4, !tbaa !11
  %110 = sext i32 %109 to i64
  %111 = shl nsw i64 %110, 4
  %112 = tail call ptr @realloc(ptr noundef %102, i64 noundef %111) #14
  store ptr %112, ptr @results, align 8, !tbaa !6
  %113 = icmp eq ptr %112, null
  br i1 %113, label %116, label %114

114:                                              ; preds = %108
  %115 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %119

116:                                              ; preds = %108
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %118 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %117)
  tail call void @exit(i32 noundef -1) #15
  unreachable

119:                                              ; preds = %99, %114
  %120 = phi i32 [ %115, %114 ], [ %105, %99 ]
  %121 = phi ptr [ %112, %114 ], [ %102, %99 ]
  %122 = sub nsw i64 %100, %101
  %123 = sitofp i64 %122 to double
  %124 = fdiv double %123, 1.000000e+06
  %125 = sext i32 %120 to i64
  %126 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125
  store double %124, ptr %126, align 8, !tbaa !13
  %127 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125, i32 1
  store ptr %6, ptr %127, align 8, !tbaa !17
  %128 = add nsw i32 %120, 1
  store i32 %128, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %89

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sdiv i64 %2, %3
  %14 = sdiv i64 %13, %4
  %15 = sdiv i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %52, %18
  %26 = phi i32 [ %9, %18 ], [ %53, %52 ]
  %27 = phi i32 [ 0, %18 ], [ %54, %52 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <2 x i64> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <2 x i64> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i64, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x i64>, ptr %32, align 8, !tbaa !30
  %35 = load <2 x i64>, ptr %33, align 8, !tbaa !30
  %36 = add <2 x i64> %34, %30
  %37 = add <2 x i64> %35, %31
  %38 = add <2 x i64> %36, %23
  %39 = add <2 x i64> %37, %23
  %40 = add nuw i64 %29, 4
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !465

42:                                               ; preds = %28
  %43 = add <2 x i64> %39, %38
  %44 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i64 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %89, !llvm.loop !466

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i64 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i64, ptr %0, i64 %57
  %60 = load i64, ptr %59, align 8, !tbaa !30
  %61 = add i64 %60, %58
  %62 = add i64 %61, %15
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !467

65:                                               ; preds = %56, %42
  %66 = phi i64 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptosi double %67 to i64
  %69 = add nsw i64 %15, %68
  %70 = mul nsw i64 %69, 8000
  %71 = icmp eq i64 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %84
  %73 = phi i32 [ %85, %84 ], [ %9, %16 ]
  %74 = phi double [ %86, %84 ], [ %17, %16 ]
  %75 = phi i32 [ %87, %84 ], [ 0, %16 ]
  %76 = fptosi double %74 to i64
  %77 = sub i64 0, %76
  %78 = icmp eq i64 %15, %77
  br i1 %78, label %84, label %79

79:                                               ; preds = %72
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %80)
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %84

84:                                               ; preds = %72, %79
  %85 = phi i32 [ %73, %72 ], [ %83, %79 ]
  %86 = phi double [ %74, %72 ], [ %82, %79 ]
  %87 = add nuw nsw i32 %75, 1
  %88 = icmp slt i32 %87, %85
  br i1 %88, label %72, label %89, !llvm.loop !466

89:                                               ; preds = %84, %52, %7
  %90 = tail call i64 @clock() #17
  store i64 %90, ptr @end_time, align 8, !tbaa !30
  %91 = load i64, ptr @start_time, align 8, !tbaa !30
  %92 = load ptr, ptr @results, align 8, !tbaa !6
  %93 = icmp ne ptr %92, null
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %95 = load i32, ptr @current_test, align 4
  %96 = icmp slt i32 %95, %94
  %97 = select i1 %93, i1 %96, i1 false
  br i1 %97, label %109, label %98

98:                                               ; preds = %89
  %99 = add nsw i32 %94, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !11
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %92, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !6
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %98
  %105 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %109

106:                                              ; preds = %98
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %89, %104
  %110 = phi i32 [ %105, %104 ], [ %95, %89 ]
  %111 = phi ptr [ %102, %104 ], [ %92, %89 ]
  %112 = sub nsw i64 %90, %91
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !13
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %6, ptr %117, align 8, !tbaa !17
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %94

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul nsw i64 %4, %3
  %14 = sdiv i64 %13, %5
  %15 = sub i64 %2, %14
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %77

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %2, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %14, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %56, %18
  %28 = phi i32 [ %9, %18 ], [ %57, %56 ]
  %29 = phi i32 [ 0, %18 ], [ %58, %56 ]
  br i1 %20, label %49, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %44, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %42, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %43, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds nuw i64, ptr %0, i64 %31
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <2 x i64>, ptr %34, align 8, !tbaa !30
  %37 = load <2 x i64>, ptr %35, align 8, !tbaa !30
  %38 = add <2 x i64> %32, %23
  %39 = add <2 x i64> %33, %23
  %40 = add <2 x i64> %38, %36
  %41 = add <2 x i64> %39, %37
  %42 = sub <2 x i64> %40, %25
  %43 = sub <2 x i64> %41, %25
  %44 = add nuw i64 %31, 4
  %45 = icmp eq i64 %44, %21
  br i1 %45, label %46, label %30, !llvm.loop !468

46:                                               ; preds = %30
  %47 = add <2 x i64> %43, %42
  %48 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %47)
  br i1 %26, label %70, label %49

49:                                               ; preds = %27, %46
  %50 = phi i64 [ 0, %27 ], [ %21, %46 ]
  %51 = phi i64 [ 0, %27 ], [ %48, %46 ]
  br label %60

52:                                               ; preds = %70
  %53 = load i32, ptr @current_test, align 4, !tbaa !11
  %54 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %53)
  %55 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %56

56:                                               ; preds = %52, %70
  %57 = phi i32 [ %55, %52 ], [ %28, %70 ]
  %58 = add nuw nsw i32 %29, 1
  %59 = icmp slt i32 %58, %57
  br i1 %59, label %27, label %94, !llvm.loop !469

60:                                               ; preds = %49, %60
  %61 = phi i64 [ %68, %60 ], [ %50, %49 ]
  %62 = phi i64 [ %67, %60 ], [ %51, %49 ]
  %63 = getelementptr inbounds nuw i64, ptr %0, i64 %61
  %64 = load i64, ptr %63, align 8, !tbaa !30
  %65 = add i64 %62, %2
  %66 = add i64 %65, %64
  %67 = sub i64 %66, %14
  %68 = add nuw nsw i64 %61, 1
  %69 = icmp eq i64 %68, %19
  br i1 %69, label %70, label %60, !llvm.loop !470

70:                                               ; preds = %60, %46
  %71 = phi i64 [ %48, %46 ], [ %67, %60 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !33
  %73 = fptosi double %72 to i64
  %74 = add i64 %15, %73
  %75 = mul nsw i64 %74, 8000
  %76 = icmp eq i64 %71, %75
  br i1 %76, label %56, label %52

77:                                               ; preds = %16, %89
  %78 = phi i32 [ %90, %89 ], [ %9, %16 ]
  %79 = phi double [ %91, %89 ], [ %17, %16 ]
  %80 = phi i32 [ %92, %89 ], [ 0, %16 ]
  %81 = fptosi double %79 to i64
  %82 = sub i64 0, %81
  %83 = icmp eq i64 %15, %82
  br i1 %83, label %89, label %84

84:                                               ; preds = %77
  %85 = load i32, ptr @current_test, align 4, !tbaa !11
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %85)
  %87 = load double, ptr @init_value, align 8, !tbaa !33
  %88 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %89

89:                                               ; preds = %77, %84
  %90 = phi i32 [ %78, %77 ], [ %88, %84 ]
  %91 = phi double [ %79, %77 ], [ %87, %84 ]
  %92 = add nuw nsw i32 %80, 1
  %93 = icmp slt i32 %92, %90
  br i1 %93, label %77, label %94, !llvm.loop !469

94:                                               ; preds = %89, %56, %7
  %95 = tail call i64 @clock() #17
  store i64 %95, ptr @end_time, align 8, !tbaa !30
  %96 = load i64, ptr @start_time, align 8, !tbaa !30
  %97 = load ptr, ptr @results, align 8, !tbaa !6
  %98 = icmp ne ptr %97, null
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = load i32, ptr @current_test, align 4
  %101 = icmp slt i32 %100, %99
  %102 = select i1 %98, i1 %101, i1 false
  br i1 %102, label %114, label %103

103:                                              ; preds = %94
  %104 = add nsw i32 %99, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !11
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %97, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !6
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %103
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %114

111:                                              ; preds = %103
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %94, %109
  %115 = phi i32 [ %110, %109 ], [ %100, %94 ]
  %116 = phi ptr [ %107, %109 ], [ %97, %94 ]
  %117 = sub nsw i64 %95, %96
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !13
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !17
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = and <2 x i64> %28, %17
  %31 = and <2 x i64> %29, %17
  %32 = add <2 x i64> %30, %24
  %33 = add <2 x i64> %31, %25
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !471

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %83, !llvm.loop !472

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = and i64 %54, %2
  %56 = add nsw i64 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !473

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i64
  %63 = and i64 %2, %62
  %64 = mul nsw i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %10 ]
  %68 = phi double [ %80, %78 ], [ %11, %10 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %10 ]
  %70 = fptosi double %68 to i64
  %71 = and i64 %2, %70
  %72 = icmp eq i64 %71, 0
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !472

83:                                               ; preds = %78, %46, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %104

11:                                               ; preds = %7
  %12 = and i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i64 %2, %12
  %15 = and i64 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %4, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %5, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = insertelement <2 x i64> poison, i64 %2, i64 0
  %27 = shufflevector <2 x i64> %26, <2 x i64> poison, <2 x i32> zeroinitializer
  %28 = insertelement <2 x i64> poison, i64 %3, i64 0
  %29 = shufflevector <2 x i64> %28, <2 x i64> poison, <2 x i32> zeroinitializer
  %30 = and <2 x i64> %23, %25
  %31 = and <2 x i64> %23, %25
  %32 = and <2 x i64> %30, %27
  %33 = and <2 x i64> %31, %27
  %34 = and <2 x i64> %32, %29
  %35 = and <2 x i64> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = and i64 %4, %5
  %38 = and i64 %37, %2
  %39 = and i64 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <2 x i64> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <2 x i64> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i64, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <2 x i64>, ptr %47, align 8, !tbaa !30
  %50 = load <2 x i64>, ptr %48, align 8, !tbaa !30
  %51 = and <2 x i64> %49, %34
  %52 = and <2 x i64> %50, %35
  %53 = add <2 x i64> %51, %45
  %54 = add <2 x i64> %52, %46
  %55 = add nuw i64 %44, 4
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !474

57:                                               ; preds = %43
  %58 = add <2 x i64> %54, %53
  %59 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i64 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %104, !llvm.loop !475

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i64 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i64, ptr %0, i64 %72
  %75 = load i64, ptr %74, align 8, !tbaa !30
  %76 = and i64 %75, %39
  %77 = add nsw i64 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !476

80:                                               ; preds = %71, %57
  %81 = phi i64 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptosi double %82 to i64
  %84 = and i64 %15, %83
  %85 = mul nsw i64 %84, 8000
  %86 = icmp eq i64 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %99
  %88 = phi i32 [ %100, %99 ], [ %9, %16 ]
  %89 = phi double [ %101, %99 ], [ %17, %16 ]
  %90 = phi i32 [ %102, %99 ], [ 0, %16 ]
  %91 = fptosi double %89 to i64
  %92 = and i64 %15, %91
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %99, label %94

94:                                               ; preds = %87
  %95 = load i32, ptr @current_test, align 4, !tbaa !11
  %96 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %95)
  %97 = load double, ptr @init_value, align 8, !tbaa !33
  %98 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %99

99:                                               ; preds = %87, %94
  %100 = phi i32 [ %88, %87 ], [ %98, %94 ]
  %101 = phi double [ %89, %87 ], [ %97, %94 ]
  %102 = add nuw nsw i32 %90, 1
  %103 = icmp slt i32 %102, %100
  br i1 %103, label %87, label %104, !llvm.loop !475

104:                                              ; preds = %99, %67, %7
  %105 = tail call i64 @clock() #17
  store i64 %105, ptr @end_time, align 8, !tbaa !30
  %106 = load i64, ptr @start_time, align 8, !tbaa !30
  %107 = load ptr, ptr @results, align 8, !tbaa !6
  %108 = icmp ne ptr %107, null
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %110 = load i32, ptr @current_test, align 4
  %111 = icmp slt i32 %110, %109
  %112 = select i1 %108, i1 %111, i1 false
  br i1 %112, label %124, label %113

113:                                              ; preds = %104
  %114 = add nsw i32 %109, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !11
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %107, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !6
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %113
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %124

121:                                              ; preds = %113
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %104, %119
  %125 = phi i32 [ %120, %119 ], [ %110, %104 ]
  %126 = phi ptr [ %117, %119 ], [ %107, %104 ]
  %127 = sub nsw i64 %105, %106
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !13
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !17
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %83

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = or <2 x i64> %28, %17
  %31 = or <2 x i64> %29, %17
  %32 = add <2 x i64> %30, %24
  %33 = add <2 x i64> %31, %25
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !477

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %83, !llvm.loop !478

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = or i64 %54, %2
  %56 = add nsw i64 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !479

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i64
  %63 = or i64 %2, %62
  %64 = mul nsw i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %78
  %67 = phi i32 [ %79, %78 ], [ %6, %10 ]
  %68 = phi double [ %80, %78 ], [ %11, %10 ]
  %69 = phi i32 [ %81, %78 ], [ 0, %10 ]
  %70 = fptosi double %68 to i64
  %71 = or i64 %2, %70
  %72 = icmp eq i64 %71, 0
  br i1 %72, label %78, label %73

73:                                               ; preds = %66
  %74 = load i32, ptr @current_test, align 4, !tbaa !11
  %75 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %74)
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %78

78:                                               ; preds = %66, %73
  %79 = phi i32 [ %67, %66 ], [ %77, %73 ]
  %80 = phi double [ %68, %66 ], [ %76, %73 ]
  %81 = add nuw nsw i32 %69, 1
  %82 = icmp slt i32 %81, %79
  br i1 %82, label %66, label %83, !llvm.loop !478

83:                                               ; preds = %78, %46, %4
  %84 = tail call i64 @clock() #17
  store i64 %84, ptr @end_time, align 8, !tbaa !30
  %85 = load i64, ptr @start_time, align 8, !tbaa !30
  %86 = load ptr, ptr @results, align 8, !tbaa !6
  %87 = icmp ne ptr %86, null
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %89 = load i32, ptr @current_test, align 4
  %90 = icmp slt i32 %89, %88
  %91 = select i1 %87, i1 %90, i1 false
  br i1 %91, label %103, label %92

92:                                               ; preds = %83
  %93 = add nsw i32 %88, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !11
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %86, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !6
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %92
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %103

100:                                              ; preds = %92
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %83, %98
  %104 = phi i32 [ %99, %98 ], [ %89, %83 ]
  %105 = phi ptr [ %96, %98 ], [ %86, %83 ]
  %106 = sub nsw i64 %84, %85
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !13
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %3, ptr %111, align 8, !tbaa !17
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %104

11:                                               ; preds = %7
  %12 = or i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i64 %2, %12
  %15 = or i64 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %4, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %5, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = insertelement <2 x i64> poison, i64 %2, i64 0
  %27 = shufflevector <2 x i64> %26, <2 x i64> poison, <2 x i32> zeroinitializer
  %28 = insertelement <2 x i64> poison, i64 %3, i64 0
  %29 = shufflevector <2 x i64> %28, <2 x i64> poison, <2 x i32> zeroinitializer
  %30 = or <2 x i64> %23, %25
  %31 = or <2 x i64> %23, %25
  %32 = or <2 x i64> %30, %27
  %33 = or <2 x i64> %31, %27
  %34 = or <2 x i64> %32, %29
  %35 = or <2 x i64> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = or i64 %4, %5
  %38 = or i64 %37, %2
  %39 = or i64 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <2 x i64> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <2 x i64> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i64, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <2 x i64>, ptr %47, align 8, !tbaa !30
  %50 = load <2 x i64>, ptr %48, align 8, !tbaa !30
  %51 = or <2 x i64> %49, %34
  %52 = or <2 x i64> %50, %35
  %53 = add <2 x i64> %51, %45
  %54 = add <2 x i64> %52, %46
  %55 = add nuw i64 %44, 4
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !480

57:                                               ; preds = %43
  %58 = add <2 x i64> %54, %53
  %59 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i64 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %104, !llvm.loop !481

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i64 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i64, ptr %0, i64 %72
  %75 = load i64, ptr %74, align 8, !tbaa !30
  %76 = or i64 %75, %39
  %77 = add nsw i64 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !482

80:                                               ; preds = %71, %57
  %81 = phi i64 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptosi double %82 to i64
  %84 = or i64 %15, %83
  %85 = mul nsw i64 %84, 8000
  %86 = icmp eq i64 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %99
  %88 = phi i32 [ %100, %99 ], [ %9, %16 ]
  %89 = phi double [ %101, %99 ], [ %17, %16 ]
  %90 = phi i32 [ %102, %99 ], [ 0, %16 ]
  %91 = fptosi double %89 to i64
  %92 = or i64 %15, %91
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %99, label %94

94:                                               ; preds = %87
  %95 = load i32, ptr @current_test, align 4, !tbaa !11
  %96 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %95)
  %97 = load double, ptr @init_value, align 8, !tbaa !33
  %98 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %99

99:                                               ; preds = %87, %94
  %100 = phi i32 [ %88, %87 ], [ %98, %94 ]
  %101 = phi double [ %89, %87 ], [ %97, %94 ]
  %102 = add nuw nsw i32 %90, 1
  %103 = icmp slt i32 %102, %100
  br i1 %103, label %87, label %104, !llvm.loop !481

104:                                              ; preds = %99, %67, %7
  %105 = tail call i64 @clock() #17
  store i64 %105, ptr @end_time, align 8, !tbaa !30
  %106 = load i64, ptr @start_time, align 8, !tbaa !30
  %107 = load ptr, ptr @results, align 8, !tbaa !6
  %108 = icmp ne ptr %107, null
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %110 = load i32, ptr @current_test, align 4
  %111 = icmp slt i32 %110, %109
  %112 = select i1 %108, i1 %111, i1 false
  br i1 %112, label %124, label %113

113:                                              ; preds = %104
  %114 = add nsw i32 %109, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !11
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %107, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !6
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %113
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %124

121:                                              ; preds = %113
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %104, %119
  %125 = phi i32 [ %120, %119 ], [ %110, %104 ]
  %126 = phi ptr [ %117, %119 ], [ %107, %104 ]
  %127 = sub nsw i64 %105, %106
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !13
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !17
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = xor <2 x i64> %28, %17
  %31 = xor <2 x i64> %29, %17
  %32 = add <2 x i64> %30, %24
  %33 = add <2 x i64> %31, %25
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !483

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %82, !llvm.loop !484

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = xor i64 %54, %2
  %56 = add nsw i64 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !485

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptosi double %61 to i64
  %63 = xor i64 %2, %62
  %64 = mul nsw i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %77
  %67 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %68 = phi double [ %79, %77 ], [ %11, %10 ]
  %69 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %70 = fptosi double %68 to i64
  %71 = icmp eq i64 %2, %70
  br i1 %71, label %77, label %72

72:                                               ; preds = %66
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %66, %72
  %78 = phi i32 [ %67, %66 ], [ %76, %72 ]
  %79 = phi double [ %68, %66 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %69, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %66, label %82, !llvm.loop !484

82:                                               ; preds = %77, %46, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %103

11:                                               ; preds = %7
  %12 = xor i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i64 %2, %12
  %15 = xor i64 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %4, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %5, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = insertelement <2 x i64> poison, i64 %2, i64 0
  %27 = shufflevector <2 x i64> %26, <2 x i64> poison, <2 x i32> zeroinitializer
  %28 = insertelement <2 x i64> poison, i64 %3, i64 0
  %29 = shufflevector <2 x i64> %28, <2 x i64> poison, <2 x i32> zeroinitializer
  %30 = xor <2 x i64> %23, %25
  %31 = xor <2 x i64> %23, %25
  %32 = xor <2 x i64> %30, %27
  %33 = xor <2 x i64> %31, %27
  %34 = xor <2 x i64> %32, %29
  %35 = xor <2 x i64> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = xor i64 %4, %5
  %38 = xor i64 %37, %2
  %39 = xor i64 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <2 x i64> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <2 x i64> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i64, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <2 x i64>, ptr %47, align 8, !tbaa !30
  %50 = load <2 x i64>, ptr %48, align 8, !tbaa !30
  %51 = xor <2 x i64> %49, %34
  %52 = xor <2 x i64> %50, %35
  %53 = add <2 x i64> %51, %45
  %54 = add <2 x i64> %52, %46
  %55 = add nuw i64 %44, 4
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !486

57:                                               ; preds = %43
  %58 = add <2 x i64> %54, %53
  %59 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i64 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %103, !llvm.loop !487

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i64 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i64, ptr %0, i64 %72
  %75 = load i64, ptr %74, align 8, !tbaa !30
  %76 = xor i64 %75, %39
  %77 = add nsw i64 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !488

80:                                               ; preds = %71, %57
  %81 = phi i64 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptosi double %82 to i64
  %84 = xor i64 %15, %83
  %85 = mul nsw i64 %84, 8000
  %86 = icmp eq i64 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %98
  %88 = phi i32 [ %99, %98 ], [ %9, %16 ]
  %89 = phi double [ %100, %98 ], [ %17, %16 ]
  %90 = phi i32 [ %101, %98 ], [ 0, %16 ]
  %91 = fptosi double %89 to i64
  %92 = icmp eq i64 %15, %91
  br i1 %92, label %98, label %93

93:                                               ; preds = %87
  %94 = load i32, ptr @current_test, align 4, !tbaa !11
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !33
  %97 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %98

98:                                               ; preds = %87, %93
  %99 = phi i32 [ %88, %87 ], [ %97, %93 ]
  %100 = phi double [ %89, %87 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %90, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %87, label %103, !llvm.loop !487

103:                                              ; preds = %98, %67, %7
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !30
  %105 = load i64, ptr @start_time, align 8, !tbaa !30
  %106 = load ptr, ptr @results, align 8, !tbaa !6
  %107 = icmp ne ptr %106, null
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = load i32, ptr @current_test, align 4
  %110 = icmp slt i32 %109, %108
  %111 = select i1 %107, i1 %110, i1 false
  br i1 %111, label %123, label %112

112:                                              ; preds = %103
  %113 = add nsw i32 %108, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !11
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %106, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !6
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %112
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %123

120:                                              ; preds = %112
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %103, %118
  %124 = phi i32 [ %119, %118 ], [ %109, %103 ]
  %125 = phi ptr [ %116, %118 ], [ %106, %103 ]
  %126 = sub nsw i64 %104, %105
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !13
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !17
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = add <2 x i64> %24, %17
  %31 = add <2 x i64> %25, %17
  %32 = add <2 x i64> %30, %28
  %33 = add <2 x i64> %31, %29
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !489

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !490

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = add i64 %52, %2
  %56 = add i64 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !491

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i64
  %63 = add i64 %2, %62
  %64 = mul i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i64
  %71 = add i64 %2, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !490

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i32 %1 to i64
  %11 = mul i64 %2, %10
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

14:                                               ; preds = %8
  %15 = zext nneg i32 %1 to i64
  %16 = icmp ult i32 %1, 4
  %17 = and i64 %15, 2147483644
  %18 = icmp eq i64 %17, %15
  br label %19

19:                                               ; preds = %14, %44
  %20 = phi i32 [ %45, %44 ], [ %6, %14 ]
  %21 = phi i32 [ %46, %44 ], [ 0, %14 ]
  br i1 %16, label %37, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %32, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %30, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %31, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = add <2 x i64> %28, %24
  %31 = add <2 x i64> %29, %25
  %32 = add nuw i64 %23, 4
  %33 = icmp eq i64 %32, %17
  br i1 %33, label %34, label %22, !llvm.loop !492

34:                                               ; preds = %22
  %35 = add <2 x i64> %31, %30
  %36 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %35)
  br i1 %18, label %56, label %37

37:                                               ; preds = %19, %34
  %38 = phi i64 [ 0, %19 ], [ %17, %34 ]
  %39 = phi i64 [ 0, %19 ], [ %36, %34 ]
  br label %48

40:                                               ; preds = %56
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %56
  %45 = phi i32 [ %43, %40 ], [ %20, %56 ]
  %46 = add nuw nsw i32 %21, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %19, label %82, !llvm.loop !493

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %54, %48 ], [ %38, %37 ]
  %50 = phi i64 [ %53, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i64, ptr %0, i64 %49
  %52 = load i64, ptr %51, align 8, !tbaa !30
  %53 = add i64 %52, %50
  %54 = add nuw nsw i64 %49, 1
  %55 = icmp eq i64 %54, %15
  br i1 %55, label %56, label %48, !llvm.loop !494

56:                                               ; preds = %48, %34
  %57 = phi i64 [ %36, %34 ], [ %53, %48 ]
  %58 = add i64 %57, %11
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptoui double %59 to i64
  %61 = add i64 %2, %60
  %62 = mul i64 %61, 8000
  %63 = icmp eq i64 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %12, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %12 ]
  %66 = phi double [ %79, %77 ], [ %13, %12 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %12 ]
  %68 = fptoui double %66 to i64
  %69 = add i64 %2, %68
  %70 = mul i64 %69, 8000
  %71 = icmp eq i64 %11, %70
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !493

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = add i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i64 %3, %2
  %15 = add i64 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <2 x i64> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <2 x i64> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i64, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x i64>, ptr %32, align 8, !tbaa !30
  %35 = load <2 x i64>, ptr %33, align 8, !tbaa !30
  %36 = add <2 x i64> %23, %30
  %37 = add <2 x i64> %23, %31
  %38 = add <2 x i64> %36, %34
  %39 = add <2 x i64> %37, %35
  %40 = add nuw i64 %29, 4
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !495

42:                                               ; preds = %28
  %43 = add <2 x i64> %39, %38
  %44 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i64 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %90, !llvm.loop !496

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i64 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i64, ptr %0, i64 %57
  %60 = load i64, ptr %59, align 8, !tbaa !30
  %61 = add i64 %15, %58
  %62 = add i64 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !497

65:                                               ; preds = %56, %42
  %66 = phi i64 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptoui double %67 to i64
  %69 = add i64 %15, %68
  %70 = mul i64 %69, 8000
  %71 = icmp eq i64 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %85
  %73 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %74 = phi double [ %87, %85 ], [ %17, %16 ]
  %75 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %76 = fptoui double %74 to i64
  %77 = add i64 %15, %76
  %78 = mul i64 %77, 8000
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %72
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %72, %80
  %86 = phi i32 [ %73, %72 ], [ %84, %80 ]
  %87 = phi double [ %74, %72 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %75, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %72, label %90, !llvm.loop !496

90:                                               ; preds = %85, %52, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = sub <2 x i64> %24, %17
  %31 = sub <2 x i64> %25, %17
  %32 = add <2 x i64> %30, %28
  %33 = add <2 x i64> %31, %29
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !498

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !499

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = sub i64 %52, %2
  %56 = add i64 %55, %54
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !500

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i64
  %63 = sub i64 %62, %2
  %64 = mul i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i64
  %71 = sub i64 %70, %2
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !499

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = add i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = add i64 %3, %2
  %15 = add i64 %14, %12
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %52
  %26 = phi i32 [ %53, %52 ], [ %9, %18 ]
  %27 = phi i32 [ %54, %52 ], [ 0, %18 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <2 x i64> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <2 x i64> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i64, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x i64>, ptr %32, align 8, !tbaa !30
  %35 = load <2 x i64>, ptr %33, align 8, !tbaa !30
  %36 = sub <2 x i64> %30, %23
  %37 = sub <2 x i64> %31, %23
  %38 = add <2 x i64> %36, %34
  %39 = add <2 x i64> %37, %35
  %40 = add nuw i64 %29, 4
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !501

42:                                               ; preds = %28
  %43 = add <2 x i64> %39, %38
  %44 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i64 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %90, !llvm.loop !502

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i64 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i64, ptr %0, i64 %57
  %60 = load i64, ptr %59, align 8, !tbaa !30
  %61 = sub i64 %58, %15
  %62 = add i64 %61, %60
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !503

65:                                               ; preds = %56, %42
  %66 = phi i64 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptoui double %67 to i64
  %69 = sub i64 %68, %15
  %70 = mul i64 %69, 8000
  %71 = icmp eq i64 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %85
  %73 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %74 = phi double [ %87, %85 ], [ %17, %16 ]
  %75 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %76 = fptoui double %74 to i64
  %77 = sub i64 %76, %15
  %78 = mul i64 %77, 8000
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %72
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %72, %80
  %86 = phi i32 [ %73, %72 ], [ %84, %80 ]
  %87 = phi double [ %74, %72 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %75, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %72, label %90, !llvm.loop !502

90:                                               ; preds = %85, %52, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i64 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

13:                                               ; preds = %8
  %14 = zext nneg i32 %1 to i64
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %14, 2147483646
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %45
  %19 = phi i32 [ %46, %45 ], [ %6, %13 ]
  %20 = phi i32 [ %47, %45 ], [ 0, %13 ]
  br i1 %15, label %38, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %34, %21 ], [ 0, %18 ]
  %23 = phi i64 [ %32, %21 ], [ 0, %18 ]
  %24 = phi i64 [ %33, %21 ], [ 0, %18 ]
  %25 = getelementptr inbounds nuw i64, ptr %0, i64 %22
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %22
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 8
  %28 = load i64, ptr %25, align 8, !tbaa !30
  %29 = load i64, ptr %27, align 8, !tbaa !30
  %30 = mul i64 %28, %2
  %31 = mul i64 %29, %2
  %32 = add i64 %30, %23
  %33 = add i64 %31, %24
  %34 = add nuw i64 %22, 2
  %35 = icmp eq i64 %34, %16
  br i1 %35, label %36, label %21, !llvm.loop !504

36:                                               ; preds = %21
  %37 = add i64 %33, %32
  br i1 %17, label %58, label %38

38:                                               ; preds = %18, %36
  %39 = phi i64 [ 0, %18 ], [ %16, %36 ]
  %40 = phi i64 [ 0, %18 ], [ %37, %36 ]
  br label %49

41:                                               ; preds = %58
  %42 = load i32, ptr @current_test, align 4, !tbaa !11
  %43 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %42)
  %44 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %45

45:                                               ; preds = %41, %58
  %46 = phi i32 [ %44, %41 ], [ %19, %58 ]
  %47 = add nuw nsw i32 %20, 1
  %48 = icmp slt i32 %47, %46
  br i1 %48, label %18, label %81, !llvm.loop !505

49:                                               ; preds = %38, %49
  %50 = phi i64 [ %56, %49 ], [ %39, %38 ]
  %51 = phi i64 [ %55, %49 ], [ %40, %38 ]
  %52 = getelementptr inbounds nuw i64, ptr %0, i64 %50
  %53 = load i64, ptr %52, align 8, !tbaa !30
  %54 = mul i64 %53, %2
  %55 = add i64 %54, %51
  %56 = add nuw nsw i64 %50, 1
  %57 = icmp eq i64 %56, %14
  br i1 %57, label %58, label %49, !llvm.loop !506

58:                                               ; preds = %49, %36
  %59 = phi i64 [ %37, %36 ], [ %55, %49 ]
  %60 = load double, ptr @init_value, align 8, !tbaa !33
  %61 = fptoui double %60 to i64
  %62 = mul i64 %10, %61
  %63 = icmp eq i64 %59, %62
  br i1 %63, label %45, label %41

64:                                               ; preds = %11, %76
  %65 = phi i32 [ %77, %76 ], [ %6, %11 ]
  %66 = phi double [ %78, %76 ], [ %12, %11 ]
  %67 = phi i32 [ %79, %76 ], [ 0, %11 ]
  %68 = fptoui double %66 to i64
  %69 = mul i64 %10, %68
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %76, label %71

71:                                               ; preds = %64
  %72 = load i32, ptr @current_test, align 4, !tbaa !11
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !33
  %75 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %76

76:                                               ; preds = %64, %71
  %77 = phi i32 [ %65, %64 ], [ %75, %71 ]
  %78 = phi double [ %66, %64 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %67, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %64, label %81, !llvm.loop !505

81:                                               ; preds = %76, %45, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !30
  %83 = load i64, ptr @start_time, align 8, !tbaa !30
  %84 = load ptr, ptr @results, align 8, !tbaa !6
  %85 = icmp ne ptr %84, null
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %87 = load i32, ptr @current_test, align 4
  %88 = icmp slt i32 %87, %86
  %89 = select i1 %85, i1 %88, i1 false
  br i1 %89, label %101, label %90

90:                                               ; preds = %81
  %91 = add nsw i32 %86, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !11
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %84, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !6
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %90
  %97 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %101

98:                                               ; preds = %90
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %81, %96
  %102 = phi i32 [ %97, %96 ], [ %87, %81 ]
  %103 = phi ptr [ %94, %96 ], [ %84, %81 ]
  %104 = sub nsw i64 %82, %83
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !13
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !17
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = mul i64 %3, 8000
  %13 = mul i64 %12, %4
  %14 = mul i64 %13, %5
  %15 = mul i64 %3, %5
  %16 = mul i64 %15, %2
  %17 = mul i64 %16, %4
  %18 = icmp sgt i32 %1, 0
  %19 = mul i64 %14, %2
  br i1 %18, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !33
  br label %73

22:                                               ; preds = %11
  %23 = zext nneg i32 %1 to i64
  %24 = icmp eq i32 %1, 1
  %25 = and i64 %23, 2147483646
  %26 = icmp eq i64 %25, %23
  br label %27

27:                                               ; preds = %22, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %22 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %22 ]
  br i1 %24, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %43, %30 ], [ 0, %27 ]
  %32 = phi i64 [ %41, %30 ], [ 0, %27 ]
  %33 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %34 = getelementptr inbounds nuw i64, ptr %0, i64 %31
  %35 = getelementptr inbounds nuw i64, ptr %0, i64 %31
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 8
  %37 = load i64, ptr %34, align 8, !tbaa !30
  %38 = load i64, ptr %36, align 8, !tbaa !30
  %39 = mul i64 %17, %37
  %40 = mul i64 %17, %38
  %41 = add i64 %39, %32
  %42 = add i64 %40, %33
  %43 = add nuw i64 %31, 2
  %44 = icmp eq i64 %43, %25
  br i1 %44, label %45, label %30, !llvm.loop !507

45:                                               ; preds = %30
  %46 = add i64 %42, %41
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %45
  %48 = phi i64 [ 0, %27 ], [ %25, %45 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %45 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !11
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %90, !llvm.loop !508

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds nuw i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !30
  %63 = mul i64 %17, %62
  %64 = add i64 %63, %60
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %23
  br i1 %66, label %67, label %58, !llvm.loop !509

67:                                               ; preds = %58, %45
  %68 = phi i64 [ %46, %45 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !33
  %70 = fptoui double %69 to i64
  %71 = mul i64 %19, %70
  %72 = icmp eq i64 %68, %71
  br i1 %72, label %54, label %50

73:                                               ; preds = %20, %85
  %74 = phi i32 [ %86, %85 ], [ %9, %20 ]
  %75 = phi double [ %87, %85 ], [ %21, %20 ]
  %76 = phi i32 [ %88, %85 ], [ 0, %20 ]
  %77 = fptoui double %75 to i64
  %78 = mul i64 %19, %77
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %73
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %73, %80
  %86 = phi i32 [ %74, %73 ], [ %84, %80 ]
  %87 = phi double [ %75, %73 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %76, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %73, label %90, !llvm.loop !508

90:                                               ; preds = %85, %54, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = mul i64 %3, %4
  %13 = mul i64 %12, %5
  %14 = mul i64 %3, %5
  %15 = mul i64 %14, %2
  %16 = mul i64 %15, %4
  %17 = icmp sgt i32 %1, 0
  %18 = mul i64 %13, %2
  br i1 %17, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

21:                                               ; preds = %11
  %22 = zext nneg i32 %1 to i64
  %23 = icmp ult i32 %1, 4
  %24 = and i64 %22, 2147483644
  %25 = insertelement <2 x i64> poison, i64 %16, i64 0
  %26 = shufflevector <2 x i64> %25, <2 x i64> poison, <2 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %22
  br label %28

28:                                               ; preds = %21, %55
  %29 = phi i32 [ %56, %55 ], [ %9, %21 ]
  %30 = phi i32 [ %57, %55 ], [ 0, %21 ]
  br i1 %23, label %48, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %43, %31 ], [ 0, %28 ]
  %33 = phi <2 x i64> [ %41, %31 ], [ zeroinitializer, %28 ]
  %34 = phi <2 x i64> [ %42, %31 ], [ zeroinitializer, %28 ]
  %35 = getelementptr inbounds nuw i64, ptr %0, i64 %32
  %36 = getelementptr inbounds nuw i8, ptr %35, i64 16
  %37 = load <2 x i64>, ptr %35, align 8, !tbaa !30
  %38 = load <2 x i64>, ptr %36, align 8, !tbaa !30
  %39 = add <2 x i64> %33, %26
  %40 = add <2 x i64> %34, %26
  %41 = add <2 x i64> %39, %37
  %42 = add <2 x i64> %40, %38
  %43 = add nuw i64 %32, 4
  %44 = icmp eq i64 %43, %24
  br i1 %44, label %45, label %31, !llvm.loop !510

45:                                               ; preds = %31
  %46 = add <2 x i64> %42, %41
  %47 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %46)
  br i1 %27, label %68, label %48

48:                                               ; preds = %28, %45
  %49 = phi i64 [ 0, %28 ], [ %24, %45 ]
  %50 = phi i64 [ 0, %28 ], [ %47, %45 ]
  br label %59

51:                                               ; preds = %68
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %52)
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %68
  %56 = phi i32 [ %54, %51 ], [ %29, %68 ]
  %57 = add nuw nsw i32 %30, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %28, label %93, !llvm.loop !511

59:                                               ; preds = %48, %59
  %60 = phi i64 [ %66, %59 ], [ %49, %48 ]
  %61 = phi i64 [ %65, %59 ], [ %50, %48 ]
  %62 = getelementptr inbounds nuw i64, ptr %0, i64 %60
  %63 = load i64, ptr %62, align 8, !tbaa !30
  %64 = add i64 %61, %16
  %65 = add i64 %64, %63
  %66 = add nuw nsw i64 %60, 1
  %67 = icmp eq i64 %66, %22
  br i1 %67, label %68, label %59, !llvm.loop !512

68:                                               ; preds = %59, %45
  %69 = phi i64 [ %47, %45 ], [ %65, %59 ]
  %70 = load double, ptr @init_value, align 8, !tbaa !33
  %71 = fptoui double %70 to i64
  %72 = add i64 %18, %71
  %73 = mul i64 %72, 8000
  %74 = icmp eq i64 %69, %73
  br i1 %74, label %55, label %51

75:                                               ; preds = %19, %88
  %76 = phi i32 [ %89, %88 ], [ %9, %19 ]
  %77 = phi double [ %90, %88 ], [ %20, %19 ]
  %78 = phi i32 [ %91, %88 ], [ 0, %19 ]
  %79 = fptoui double %77 to i64
  %80 = add i64 %18, %79
  %81 = mul i64 %80, 8000
  %82 = icmp eq i64 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %75
  %84 = load i32, ptr @current_test, align 4, !tbaa !11
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %88

88:                                               ; preds = %75, %83
  %89 = phi i32 [ %76, %75 ], [ %87, %83 ]
  %90 = phi double [ %77, %75 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %78, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %75, label %93, !llvm.loop !511

93:                                               ; preds = %88, %55, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !30
  %95 = load i64, ptr @start_time, align 8, !tbaa !30
  %96 = load ptr, ptr @results, align 8, !tbaa !6
  %97 = icmp ne ptr %96, null
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %99 = load i32, ptr @current_test, align 4
  %100 = icmp slt i32 %99, %98
  %101 = select i1 %97, i1 %100, i1 false
  br i1 %101, label %113, label %102

102:                                              ; preds = %93
  %103 = add nsw i32 %98, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !11
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %96, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !6
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %102
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %113

110:                                              ; preds = %102
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %93, %108
  %114 = phi i32 [ %109, %108 ], [ %99, %93 ]
  %115 = phi ptr [ %106, %108 ], [ %96, %93 ]
  %116 = sub nsw i64 %94, %95
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !13
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %6, ptr %121, align 8, !tbaa !17
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %64

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp eq i32 %1, 1
  %15 = and i64 %13, 2147483646
  %16 = icmp eq i64 %15, %13
  br label %17

17:                                               ; preds = %12, %44
  %18 = phi i32 [ %45, %44 ], [ %6, %12 ]
  %19 = phi i32 [ %46, %44 ], [ 0, %12 ]
  br i1 %14, label %37, label %20

20:                                               ; preds = %17, %20
  %21 = phi i64 [ %33, %20 ], [ 0, %17 ]
  %22 = phi i64 [ %31, %20 ], [ 0, %17 ]
  %23 = phi i64 [ %32, %20 ], [ 0, %17 ]
  %24 = getelementptr inbounds nuw i64, ptr %0, i64 %21
  %25 = getelementptr inbounds nuw i64, ptr %0, i64 %21
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 8
  %27 = load i64, ptr %24, align 8, !tbaa !30
  %28 = load i64, ptr %26, align 8, !tbaa !30
  %29 = udiv i64 %27, %2
  %30 = udiv i64 %28, %2
  %31 = add i64 %29, %22
  %32 = add i64 %30, %23
  %33 = add nuw i64 %21, 2
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %20, !llvm.loop !513

35:                                               ; preds = %20
  %36 = add i64 %32, %31
  br i1 %16, label %57, label %37

37:                                               ; preds = %17, %35
  %38 = phi i64 [ 0, %17 ], [ %15, %35 ]
  %39 = phi i64 [ 0, %17 ], [ %36, %35 ]
  br label %48

40:                                               ; preds = %57
  %41 = load i32, ptr @current_test, align 4, !tbaa !11
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %40, %57
  %45 = phi i32 [ %43, %40 ], [ %18, %57 ]
  %46 = add nuw nsw i32 %19, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %17, label %82, !llvm.loop !514

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %55, %48 ], [ %38, %37 ]
  %50 = phi i64 [ %54, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds nuw i64, ptr %0, i64 %49
  %52 = load i64, ptr %51, align 8, !tbaa !30
  %53 = udiv i64 %52, %2
  %54 = add i64 %53, %50
  %55 = add nuw nsw i64 %49, 1
  %56 = icmp eq i64 %55, %13
  br i1 %56, label %57, label %48, !llvm.loop !515

57:                                               ; preds = %48, %35
  %58 = phi i64 [ %36, %35 ], [ %54, %48 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !33
  %60 = fptoui double %59 to i64
  %61 = udiv i64 %60, %2
  %62 = mul i64 %61, 8000
  %63 = icmp eq i64 %58, %62
  br i1 %63, label %44, label %40

64:                                               ; preds = %10, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %10 ]
  %66 = phi double [ %79, %77 ], [ %11, %10 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %10 ]
  %68 = fptoui double %66 to i64
  %69 = udiv i64 %68, %2
  %70 = mul i64 %69, 8000
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !11
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !33
  %76 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !514

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !30
  %84 = load i64, ptr @start_time, align 8, !tbaa !30
  %85 = load ptr, ptr @results, align 8, !tbaa !6
  %86 = icmp ne ptr %85, null
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %88 = load i32, ptr @current_test, align 4
  %89 = icmp slt i32 %88, %87
  %90 = select i1 %86, i1 %89, i1 false
  br i1 %90, label %102, label %91

91:                                               ; preds = %82
  %92 = add nsw i32 %87, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !11
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %85, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !6
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %91
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %102

99:                                               ; preds = %91
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %82, %97
  %103 = phi i32 [ %98, %97 ], [ %88, %82 ]
  %104 = phi ptr [ %95, %97 ], [ %85, %82 ]
  %105 = sub nsw i64 %83, %84
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !13
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !17
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp eq i32 %1, 1
  %18 = and i64 %16, 2147483646
  %19 = icmp eq i64 %18, %16
  br label %20

20:                                               ; preds = %15, %53
  %21 = phi i32 [ %54, %53 ], [ %9, %15 ]
  %22 = phi i32 [ %55, %53 ], [ 0, %15 ]
  br i1 %17, label %46, label %23

23:                                               ; preds = %20, %23
  %24 = phi i64 [ %42, %23 ], [ 0, %20 ]
  %25 = phi i64 [ %40, %23 ], [ 0, %20 ]
  %26 = phi i64 [ %41, %23 ], [ 0, %20 ]
  %27 = getelementptr inbounds nuw i64, ptr %0, i64 %24
  %28 = getelementptr inbounds nuw i64, ptr %0, i64 %24
  %29 = getelementptr inbounds nuw i8, ptr %28, i64 8
  %30 = load i64, ptr %27, align 8, !tbaa !30
  %31 = load i64, ptr %29, align 8, !tbaa !30
  %32 = udiv i64 %30, %2
  %33 = udiv i64 %31, %2
  %34 = udiv i64 %32, %3
  %35 = udiv i64 %33, %3
  %36 = udiv i64 %34, %4
  %37 = udiv i64 %35, %4
  %38 = udiv i64 %36, %5
  %39 = udiv i64 %37, %5
  %40 = add i64 %38, %25
  %41 = add i64 %39, %26
  %42 = add nuw i64 %24, 2
  %43 = icmp eq i64 %42, %18
  br i1 %43, label %44, label %23, !llvm.loop !516

44:                                               ; preds = %23
  %45 = add i64 %41, %40
  br i1 %19, label %69, label %46

46:                                               ; preds = %20, %44
  %47 = phi i64 [ 0, %20 ], [ %18, %44 ]
  %48 = phi i64 [ 0, %20 ], [ %45, %44 ]
  br label %57

49:                                               ; preds = %69
  %50 = load i32, ptr @current_test, align 4, !tbaa !11
  %51 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %50)
  %52 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %53

53:                                               ; preds = %49, %69
  %54 = phi i32 [ %52, %49 ], [ %21, %69 ]
  %55 = add nuw nsw i32 %22, 1
  %56 = icmp slt i32 %55, %54
  br i1 %56, label %20, label %100, !llvm.loop !517

57:                                               ; preds = %46, %57
  %58 = phi i64 [ %67, %57 ], [ %47, %46 ]
  %59 = phi i64 [ %66, %57 ], [ %48, %46 ]
  %60 = getelementptr inbounds nuw i64, ptr %0, i64 %58
  %61 = load i64, ptr %60, align 8, !tbaa !30
  %62 = udiv i64 %61, %2
  %63 = udiv i64 %62, %3
  %64 = udiv i64 %63, %4
  %65 = udiv i64 %64, %5
  %66 = add i64 %65, %59
  %67 = add nuw nsw i64 %58, 1
  %68 = icmp eq i64 %67, %16
  br i1 %68, label %69, label %57, !llvm.loop !518

69:                                               ; preds = %57, %44
  %70 = phi i64 [ %45, %44 ], [ %66, %57 ]
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  %72 = fptoui double %71 to i64
  %73 = udiv i64 %72, %2
  %74 = udiv i64 %73, %3
  %75 = udiv i64 %74, %4
  %76 = udiv i64 %75, %5
  %77 = mul i64 %76, 8000
  %78 = icmp eq i64 %70, %77
  br i1 %78, label %53, label %49

79:                                               ; preds = %13, %95
  %80 = phi i32 [ %96, %95 ], [ %9, %13 ]
  %81 = phi double [ %97, %95 ], [ %14, %13 ]
  %82 = phi i32 [ %98, %95 ], [ 0, %13 ]
  %83 = fptoui double %81 to i64
  %84 = udiv i64 %83, %2
  %85 = udiv i64 %84, %3
  %86 = udiv i64 %85, %4
  %87 = udiv i64 %86, %5
  %88 = mul i64 %87, 8000
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %79
  %91 = load i32, ptr @current_test, align 4, !tbaa !11
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !33
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %95

95:                                               ; preds = %79, %90
  %96 = phi i32 [ %80, %79 ], [ %94, %90 ]
  %97 = phi double [ %81, %79 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %82, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %79, label %100, !llvm.loop !517

100:                                              ; preds = %95, %53, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !30
  %102 = load i64, ptr @start_time, align 8, !tbaa !30
  %103 = load ptr, ptr @results, align 8, !tbaa !6
  %104 = icmp ne ptr %103, null
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = load i32, ptr @current_test, align 4
  %107 = icmp slt i32 %106, %105
  %108 = select i1 %104, i1 %107, i1 false
  br i1 %108, label %120, label %109

109:                                              ; preds = %100
  %110 = add nsw i32 %105, 10
  store i32 %110, ptr @allocated_results, align 4, !tbaa !11
  %111 = sext i32 %110 to i64
  %112 = shl nsw i64 %111, 4
  %113 = tail call ptr @realloc(ptr noundef %103, i64 noundef %112) #14
  store ptr %113, ptr @results, align 8, !tbaa !6
  %114 = icmp eq ptr %113, null
  br i1 %114, label %117, label %115

115:                                              ; preds = %109
  %116 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %120

117:                                              ; preds = %109
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %119 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %118)
  tail call void @exit(i32 noundef -1) #15
  unreachable

120:                                              ; preds = %100, %115
  %121 = phi i32 [ %116, %115 ], [ %106, %100 ]
  %122 = phi ptr [ %113, %115 ], [ %103, %100 ]
  %123 = sub nsw i64 %101, %102
  %124 = sitofp i64 %123 to double
  %125 = fdiv double %124, 1.000000e+06
  %126 = sext i32 %121 to i64
  %127 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126
  store double %125, ptr %127, align 8, !tbaa !13
  %128 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126, i32 1
  store ptr %6, ptr %128, align 8, !tbaa !17
  %129 = add nsw i32 %121, 1
  store i32 %129, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i64 %2, %3
  %14 = udiv i64 %13, %4
  %15 = udiv i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %72

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %52, %18
  %26 = phi i32 [ %9, %18 ], [ %53, %52 ]
  %27 = phi i32 [ 0, %18 ], [ %54, %52 ]
  br i1 %20, label %45, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %40, %28 ], [ 0, %25 ]
  %30 = phi <2 x i64> [ %38, %28 ], [ zeroinitializer, %25 ]
  %31 = phi <2 x i64> [ %39, %28 ], [ zeroinitializer, %25 ]
  %32 = getelementptr inbounds nuw i64, ptr %0, i64 %29
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x i64>, ptr %32, align 8, !tbaa !30
  %35 = load <2 x i64>, ptr %33, align 8, !tbaa !30
  %36 = add <2 x i64> %34, %30
  %37 = add <2 x i64> %35, %31
  %38 = add <2 x i64> %36, %23
  %39 = add <2 x i64> %37, %23
  %40 = add nuw i64 %29, 4
  %41 = icmp eq i64 %40, %21
  br i1 %41, label %42, label %28, !llvm.loop !519

42:                                               ; preds = %28
  %43 = add <2 x i64> %39, %38
  %44 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %43)
  br i1 %24, label %65, label %45

45:                                               ; preds = %25, %42
  %46 = phi i64 [ 0, %25 ], [ %21, %42 ]
  %47 = phi i64 [ 0, %25 ], [ %44, %42 ]
  br label %56

48:                                               ; preds = %65
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %65
  %53 = phi i32 [ %51, %48 ], [ %26, %65 ]
  %54 = add nuw nsw i32 %27, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %25, label %90, !llvm.loop !520

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %63, %56 ], [ %46, %45 ]
  %58 = phi i64 [ %62, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw i64, ptr %0, i64 %57
  %60 = load i64, ptr %59, align 8, !tbaa !30
  %61 = add i64 %60, %58
  %62 = add i64 %61, %15
  %63 = add nuw nsw i64 %57, 1
  %64 = icmp eq i64 %63, %19
  br i1 %64, label %65, label %56, !llvm.loop !521

65:                                               ; preds = %56, %42
  %66 = phi i64 [ %44, %42 ], [ %62, %56 ]
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  %68 = fptoui double %67 to i64
  %69 = add i64 %15, %68
  %70 = mul i64 %69, 8000
  %71 = icmp eq i64 %66, %70
  br i1 %71, label %52, label %48

72:                                               ; preds = %16, %85
  %73 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %74 = phi double [ %87, %85 ], [ %17, %16 ]
  %75 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %76 = fptoui double %74 to i64
  %77 = add i64 %15, %76
  %78 = mul i64 %77, 8000
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %72
  %81 = load i32, ptr @current_test, align 4, !tbaa !11
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !33
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %85

85:                                               ; preds = %72, %80
  %86 = phi i32 [ %73, %72 ], [ %84, %80 ]
  %87 = phi double [ %74, %72 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %75, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %72, label %90, !llvm.loop !520

90:                                               ; preds = %85, %52, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !30
  %92 = load i64, ptr @start_time, align 8, !tbaa !30
  %93 = load ptr, ptr @results, align 8, !tbaa !6
  %94 = icmp ne ptr %93, null
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %96 = load i32, ptr @current_test, align 4
  %97 = icmp slt i32 %96, %95
  %98 = select i1 %94, i1 %97, i1 false
  br i1 %98, label %110, label %99

99:                                               ; preds = %90
  %100 = add nsw i32 %95, 10
  store i32 %100, ptr @allocated_results, align 4, !tbaa !11
  %101 = sext i32 %100 to i64
  %102 = shl nsw i64 %101, 4
  %103 = tail call ptr @realloc(ptr noundef %93, i64 noundef %102) #14
  store ptr %103, ptr @results, align 8, !tbaa !6
  %104 = icmp eq ptr %103, null
  br i1 %104, label %107, label %105

105:                                              ; preds = %99
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %110

107:                                              ; preds = %99
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %108)
  tail call void @exit(i32 noundef -1) #15
  unreachable

110:                                              ; preds = %90, %105
  %111 = phi i32 [ %106, %105 ], [ %96, %90 ]
  %112 = phi ptr [ %103, %105 ], [ %93, %90 ]
  %113 = sub nsw i64 %91, %92
  %114 = sitofp i64 %113 to double
  %115 = fdiv double %114, 1.000000e+06
  %116 = sext i32 %111 to i64
  %117 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116
  store double %115, ptr %117, align 8, !tbaa !13
  %118 = getelementptr inbounds %struct.one_result, ptr %112, i64 %116, i32 1
  store ptr %6, ptr %118, align 8, !tbaa !17
  %119 = add nsw i32 %111, 1
  store i32 %119, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %95

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i64 %4, %3
  %14 = udiv i64 %13, %5
  %15 = sub i64 %2, %14
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %77

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %2, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %14, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %56, %18
  %28 = phi i32 [ %9, %18 ], [ %57, %56 ]
  %29 = phi i32 [ 0, %18 ], [ %58, %56 ]
  br i1 %20, label %49, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %44, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %42, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %43, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds nuw i64, ptr %0, i64 %31
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <2 x i64>, ptr %34, align 8, !tbaa !30
  %37 = load <2 x i64>, ptr %35, align 8, !tbaa !30
  %38 = add <2 x i64> %32, %23
  %39 = add <2 x i64> %33, %23
  %40 = add <2 x i64> %38, %36
  %41 = add <2 x i64> %39, %37
  %42 = sub <2 x i64> %40, %25
  %43 = sub <2 x i64> %41, %25
  %44 = add nuw i64 %31, 4
  %45 = icmp eq i64 %44, %21
  br i1 %45, label %46, label %30, !llvm.loop !522

46:                                               ; preds = %30
  %47 = add <2 x i64> %43, %42
  %48 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %47)
  br i1 %26, label %70, label %49

49:                                               ; preds = %27, %46
  %50 = phi i64 [ 0, %27 ], [ %21, %46 ]
  %51 = phi i64 [ 0, %27 ], [ %48, %46 ]
  br label %60

52:                                               ; preds = %70
  %53 = load i32, ptr @current_test, align 4, !tbaa !11
  %54 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %53)
  %55 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %56

56:                                               ; preds = %52, %70
  %57 = phi i32 [ %55, %52 ], [ %28, %70 ]
  %58 = add nuw nsw i32 %29, 1
  %59 = icmp slt i32 %58, %57
  br i1 %59, label %27, label %95, !llvm.loop !523

60:                                               ; preds = %49, %60
  %61 = phi i64 [ %68, %60 ], [ %50, %49 ]
  %62 = phi i64 [ %67, %60 ], [ %51, %49 ]
  %63 = getelementptr inbounds nuw i64, ptr %0, i64 %61
  %64 = load i64, ptr %63, align 8, !tbaa !30
  %65 = add i64 %62, %2
  %66 = add i64 %65, %64
  %67 = sub i64 %66, %14
  %68 = add nuw nsw i64 %61, 1
  %69 = icmp eq i64 %68, %19
  br i1 %69, label %70, label %60, !llvm.loop !524

70:                                               ; preds = %60, %46
  %71 = phi i64 [ %48, %46 ], [ %67, %60 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !33
  %73 = fptoui double %72 to i64
  %74 = add i64 %15, %73
  %75 = mul i64 %74, 8000
  %76 = icmp eq i64 %71, %75
  br i1 %76, label %56, label %52

77:                                               ; preds = %16, %90
  %78 = phi i32 [ %91, %90 ], [ %9, %16 ]
  %79 = phi double [ %92, %90 ], [ %17, %16 ]
  %80 = phi i32 [ %93, %90 ], [ 0, %16 ]
  %81 = fptoui double %79 to i64
  %82 = add i64 %15, %81
  %83 = mul i64 %82, 8000
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %90, label %85

85:                                               ; preds = %77
  %86 = load i32, ptr @current_test, align 4, !tbaa !11
  %87 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %86)
  %88 = load double, ptr @init_value, align 8, !tbaa !33
  %89 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %90

90:                                               ; preds = %77, %85
  %91 = phi i32 [ %78, %77 ], [ %89, %85 ]
  %92 = phi double [ %79, %77 ], [ %88, %85 ]
  %93 = add nuw nsw i32 %80, 1
  %94 = icmp slt i32 %93, %91
  br i1 %94, label %77, label %95, !llvm.loop !523

95:                                               ; preds = %90, %56, %7
  %96 = tail call i64 @clock() #17
  store i64 %96, ptr @end_time, align 8, !tbaa !30
  %97 = load i64, ptr @start_time, align 8, !tbaa !30
  %98 = load ptr, ptr @results, align 8, !tbaa !6
  %99 = icmp ne ptr %98, null
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %101 = load i32, ptr @current_test, align 4
  %102 = icmp slt i32 %101, %100
  %103 = select i1 %99, i1 %102, i1 false
  br i1 %103, label %115, label %104

104:                                              ; preds = %95
  %105 = add nsw i32 %100, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !11
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %98, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !6
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %104
  %111 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %115

112:                                              ; preds = %104
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %95, %110
  %116 = phi i32 [ %111, %110 ], [ %101, %95 ]
  %117 = phi ptr [ %108, %110 ], [ %98, %95 ]
  %118 = sub nsw i64 %96, %97
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !13
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !17
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = and <2 x i64> %28, %17
  %31 = and <2 x i64> %29, %17
  %32 = add <2 x i64> %30, %24
  %33 = add <2 x i64> %31, %25
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !525

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !526

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = and i64 %54, %2
  %56 = add i64 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !527

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i64
  %63 = and i64 %2, %62
  %64 = mul i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i64
  %71 = and i64 %2, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !526

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %105

11:                                               ; preds = %7
  %12 = and i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = and i64 %2, %12
  %15 = and i64 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %4, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %5, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = insertelement <2 x i64> poison, i64 %2, i64 0
  %27 = shufflevector <2 x i64> %26, <2 x i64> poison, <2 x i32> zeroinitializer
  %28 = insertelement <2 x i64> poison, i64 %3, i64 0
  %29 = shufflevector <2 x i64> %28, <2 x i64> poison, <2 x i32> zeroinitializer
  %30 = and <2 x i64> %23, %25
  %31 = and <2 x i64> %23, %25
  %32 = and <2 x i64> %30, %27
  %33 = and <2 x i64> %31, %27
  %34 = and <2 x i64> %32, %29
  %35 = and <2 x i64> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = and i64 %4, %5
  %38 = and i64 %37, %2
  %39 = and i64 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <2 x i64> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <2 x i64> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i64, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <2 x i64>, ptr %47, align 8, !tbaa !30
  %50 = load <2 x i64>, ptr %48, align 8, !tbaa !30
  %51 = and <2 x i64> %49, %34
  %52 = and <2 x i64> %50, %35
  %53 = add <2 x i64> %51, %45
  %54 = add <2 x i64> %52, %46
  %55 = add nuw i64 %44, 4
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !528

57:                                               ; preds = %43
  %58 = add <2 x i64> %54, %53
  %59 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i64 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %105, !llvm.loop !529

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i64 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i64, ptr %0, i64 %72
  %75 = load i64, ptr %74, align 8, !tbaa !30
  %76 = and i64 %75, %39
  %77 = add i64 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !530

80:                                               ; preds = %71, %57
  %81 = phi i64 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptoui double %82 to i64
  %84 = and i64 %15, %83
  %85 = mul i64 %84, 8000
  %86 = icmp eq i64 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %100
  %88 = phi i32 [ %101, %100 ], [ %9, %16 ]
  %89 = phi double [ %102, %100 ], [ %17, %16 ]
  %90 = phi i32 [ %103, %100 ], [ 0, %16 ]
  %91 = fptoui double %89 to i64
  %92 = and i64 %15, %91
  %93 = mul i64 %92, 8000
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %100, label %95

95:                                               ; preds = %87
  %96 = load i32, ptr @current_test, align 4, !tbaa !11
  %97 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %96)
  %98 = load double, ptr @init_value, align 8, !tbaa !33
  %99 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %100

100:                                              ; preds = %87, %95
  %101 = phi i32 [ %88, %87 ], [ %99, %95 ]
  %102 = phi double [ %89, %87 ], [ %98, %95 ]
  %103 = add nuw nsw i32 %90, 1
  %104 = icmp slt i32 %103, %101
  br i1 %104, label %87, label %105, !llvm.loop !529

105:                                              ; preds = %100, %67, %7
  %106 = tail call i64 @clock() #17
  store i64 %106, ptr @end_time, align 8, !tbaa !30
  %107 = load i64, ptr @start_time, align 8, !tbaa !30
  %108 = load ptr, ptr @results, align 8, !tbaa !6
  %109 = icmp ne ptr %108, null
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = load i32, ptr @current_test, align 4
  %112 = icmp slt i32 %111, %110
  %113 = select i1 %109, i1 %112, i1 false
  br i1 %113, label %125, label %114

114:                                              ; preds = %105
  %115 = add nsw i32 %110, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !11
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %108, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !6
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %114
  %121 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %125

122:                                              ; preds = %114
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %105, %120
  %126 = phi i32 [ %121, %120 ], [ %111, %105 ]
  %127 = phi ptr [ %118, %120 ], [ %108, %105 ]
  %128 = sub nsw i64 %106, %107
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !13
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !17
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = or <2 x i64> %28, %17
  %31 = or <2 x i64> %29, %17
  %32 = add <2 x i64> %30, %24
  %33 = add <2 x i64> %31, %25
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !531

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !532

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = or i64 %54, %2
  %56 = add i64 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !533

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i64
  %63 = or i64 %2, %62
  %64 = mul i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i64
  %71 = or i64 %2, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !532

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %105

11:                                               ; preds = %7
  %12 = or i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = or i64 %2, %12
  %15 = or i64 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %4, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %5, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = insertelement <2 x i64> poison, i64 %2, i64 0
  %27 = shufflevector <2 x i64> %26, <2 x i64> poison, <2 x i32> zeroinitializer
  %28 = insertelement <2 x i64> poison, i64 %3, i64 0
  %29 = shufflevector <2 x i64> %28, <2 x i64> poison, <2 x i32> zeroinitializer
  %30 = or <2 x i64> %23, %25
  %31 = or <2 x i64> %23, %25
  %32 = or <2 x i64> %30, %27
  %33 = or <2 x i64> %31, %27
  %34 = or <2 x i64> %32, %29
  %35 = or <2 x i64> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = or i64 %4, %5
  %38 = or i64 %37, %2
  %39 = or i64 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <2 x i64> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <2 x i64> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i64, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <2 x i64>, ptr %47, align 8, !tbaa !30
  %50 = load <2 x i64>, ptr %48, align 8, !tbaa !30
  %51 = or <2 x i64> %49, %34
  %52 = or <2 x i64> %50, %35
  %53 = add <2 x i64> %51, %45
  %54 = add <2 x i64> %52, %46
  %55 = add nuw i64 %44, 4
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !534

57:                                               ; preds = %43
  %58 = add <2 x i64> %54, %53
  %59 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i64 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %105, !llvm.loop !535

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i64 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i64, ptr %0, i64 %72
  %75 = load i64, ptr %74, align 8, !tbaa !30
  %76 = or i64 %75, %39
  %77 = add i64 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !536

80:                                               ; preds = %71, %57
  %81 = phi i64 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptoui double %82 to i64
  %84 = or i64 %15, %83
  %85 = mul i64 %84, 8000
  %86 = icmp eq i64 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %100
  %88 = phi i32 [ %101, %100 ], [ %9, %16 ]
  %89 = phi double [ %102, %100 ], [ %17, %16 ]
  %90 = phi i32 [ %103, %100 ], [ 0, %16 ]
  %91 = fptoui double %89 to i64
  %92 = or i64 %15, %91
  %93 = mul i64 %92, 8000
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %100, label %95

95:                                               ; preds = %87
  %96 = load i32, ptr @current_test, align 4, !tbaa !11
  %97 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %96)
  %98 = load double, ptr @init_value, align 8, !tbaa !33
  %99 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %100

100:                                              ; preds = %87, %95
  %101 = phi i32 [ %88, %87 ], [ %99, %95 ]
  %102 = phi double [ %89, %87 ], [ %98, %95 ]
  %103 = add nuw nsw i32 %90, 1
  %104 = icmp slt i32 %103, %101
  br i1 %104, label %87, label %105, !llvm.loop !535

105:                                              ; preds = %100, %67, %7
  %106 = tail call i64 @clock() #17
  store i64 %106, ptr @end_time, align 8, !tbaa !30
  %107 = load i64, ptr @start_time, align 8, !tbaa !30
  %108 = load ptr, ptr @results, align 8, !tbaa !6
  %109 = icmp ne ptr %108, null
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = load i32, ptr @current_test, align 4
  %112 = icmp slt i32 %111, %110
  %113 = select i1 %109, i1 %112, i1 false
  br i1 %113, label %125, label %114

114:                                              ; preds = %105
  %115 = add nsw i32 %110, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !11
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %108, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !6
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %114
  %121 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %125

122:                                              ; preds = %114
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %105, %120
  %126 = phi i32 [ %121, %120 ], [ %111, %105 ]
  %127 = phi ptr [ %118, %120 ], [ %108, %105 ]
  %128 = sub nsw i64 %106, %107
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !13
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !17
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %66

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %46
  %20 = phi i32 [ %47, %46 ], [ %6, %12 ]
  %21 = phi i32 [ %48, %46 ], [ 0, %12 ]
  br i1 %14, label %39, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %34, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %32, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %33, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds nuw i64, ptr %0, i64 %23
  %27 = getelementptr inbounds nuw i8, ptr %26, i64 16
  %28 = load <2 x i64>, ptr %26, align 8, !tbaa !30
  %29 = load <2 x i64>, ptr %27, align 8, !tbaa !30
  %30 = xor <2 x i64> %28, %17
  %31 = xor <2 x i64> %29, %17
  %32 = add <2 x i64> %30, %24
  %33 = add <2 x i64> %31, %25
  %34 = add nuw i64 %23, 4
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %22, !llvm.loop !537

36:                                               ; preds = %22
  %37 = add <2 x i64> %33, %32
  %38 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %37)
  br i1 %18, label %59, label %39

39:                                               ; preds = %19, %36
  %40 = phi i64 [ 0, %19 ], [ %15, %36 ]
  %41 = phi i64 [ 0, %19 ], [ %38, %36 ]
  br label %50

42:                                               ; preds = %59
  %43 = load i32, ptr @current_test, align 4, !tbaa !11
  %44 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %43)
  %45 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %46

46:                                               ; preds = %42, %59
  %47 = phi i32 [ %45, %42 ], [ %20, %59 ]
  %48 = add nuw nsw i32 %21, 1
  %49 = icmp slt i32 %48, %47
  br i1 %49, label %19, label %84, !llvm.loop !538

50:                                               ; preds = %39, %50
  %51 = phi i64 [ %57, %50 ], [ %40, %39 ]
  %52 = phi i64 [ %56, %50 ], [ %41, %39 ]
  %53 = getelementptr inbounds nuw i64, ptr %0, i64 %51
  %54 = load i64, ptr %53, align 8, !tbaa !30
  %55 = xor i64 %54, %2
  %56 = add i64 %55, %52
  %57 = add nuw nsw i64 %51, 1
  %58 = icmp eq i64 %57, %13
  br i1 %58, label %59, label %50, !llvm.loop !539

59:                                               ; preds = %50, %36
  %60 = phi i64 [ %38, %36 ], [ %56, %50 ]
  %61 = load double, ptr @init_value, align 8, !tbaa !33
  %62 = fptoui double %61 to i64
  %63 = xor i64 %2, %62
  %64 = mul i64 %63, 8000
  %65 = icmp eq i64 %60, %64
  br i1 %65, label %46, label %42

66:                                               ; preds = %10, %79
  %67 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %68 = phi double [ %81, %79 ], [ %11, %10 ]
  %69 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %70 = fptoui double %68 to i64
  %71 = xor i64 %2, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %79, label %74

74:                                               ; preds = %66
  %75 = load i32, ptr @current_test, align 4, !tbaa !11
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !33
  %78 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %79

79:                                               ; preds = %66, %74
  %80 = phi i32 [ %67, %66 ], [ %78, %74 ]
  %81 = phi double [ %68, %66 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %69, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %66, label %84, !llvm.loop !538

84:                                               ; preds = %79, %46, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !30
  %86 = load i64, ptr @start_time, align 8, !tbaa !30
  %87 = load ptr, ptr @results, align 8, !tbaa !6
  %88 = icmp ne ptr %87, null
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %90 = load i32, ptr @current_test, align 4
  %91 = icmp slt i32 %90, %89
  %92 = select i1 %88, i1 %91, i1 false
  br i1 %92, label %104, label %93

93:                                               ; preds = %84
  %94 = add nsw i32 %89, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !11
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %87, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !6
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %93
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %104

101:                                              ; preds = %93
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %84, %99
  %105 = phi i32 [ %100, %99 ], [ %90, %84 ]
  %106 = phi ptr [ %97, %99 ], [ %87, %84 ]
  %107 = sub nsw i64 %85, %86
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !13
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !17
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %105

11:                                               ; preds = %7
  %12 = xor i64 %4, %5
  %13 = icmp sgt i32 %1, 0
  %14 = xor i64 %2, %12
  %15 = xor i64 %14, %3
  br i1 %13, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %87

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x i64> poison, i64 %4, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %5, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = insertelement <2 x i64> poison, i64 %2, i64 0
  %27 = shufflevector <2 x i64> %26, <2 x i64> poison, <2 x i32> zeroinitializer
  %28 = insertelement <2 x i64> poison, i64 %3, i64 0
  %29 = shufflevector <2 x i64> %28, <2 x i64> poison, <2 x i32> zeroinitializer
  %30 = xor <2 x i64> %23, %25
  %31 = xor <2 x i64> %23, %25
  %32 = xor <2 x i64> %30, %27
  %33 = xor <2 x i64> %31, %27
  %34 = xor <2 x i64> %32, %29
  %35 = xor <2 x i64> %33, %29
  %36 = icmp eq i64 %21, %19
  %37 = xor i64 %4, %5
  %38 = xor i64 %37, %2
  %39 = xor i64 %38, %3
  br label %40

40:                                               ; preds = %18, %67
  %41 = phi i32 [ %68, %67 ], [ %9, %18 ]
  %42 = phi i32 [ %69, %67 ], [ 0, %18 ]
  br i1 %20, label %60, label %43

43:                                               ; preds = %40, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %40 ]
  %45 = phi <2 x i64> [ %53, %43 ], [ zeroinitializer, %40 ]
  %46 = phi <2 x i64> [ %54, %43 ], [ zeroinitializer, %40 ]
  %47 = getelementptr inbounds nuw i64, ptr %0, i64 %44
  %48 = getelementptr inbounds nuw i8, ptr %47, i64 16
  %49 = load <2 x i64>, ptr %47, align 8, !tbaa !30
  %50 = load <2 x i64>, ptr %48, align 8, !tbaa !30
  %51 = xor <2 x i64> %49, %34
  %52 = xor <2 x i64> %50, %35
  %53 = add <2 x i64> %51, %45
  %54 = add <2 x i64> %52, %46
  %55 = add nuw i64 %44, 4
  %56 = icmp eq i64 %55, %21
  br i1 %56, label %57, label %43, !llvm.loop !540

57:                                               ; preds = %43
  %58 = add <2 x i64> %54, %53
  %59 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %58)
  br i1 %36, label %80, label %60

60:                                               ; preds = %40, %57
  %61 = phi i64 [ 0, %40 ], [ %21, %57 ]
  %62 = phi i64 [ 0, %40 ], [ %59, %57 ]
  br label %71

63:                                               ; preds = %80
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %64)
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %80
  %68 = phi i32 [ %66, %63 ], [ %41, %80 ]
  %69 = add nuw nsw i32 %42, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %40, label %105, !llvm.loop !541

71:                                               ; preds = %60, %71
  %72 = phi i64 [ %78, %71 ], [ %61, %60 ]
  %73 = phi i64 [ %77, %71 ], [ %62, %60 ]
  %74 = getelementptr inbounds nuw i64, ptr %0, i64 %72
  %75 = load i64, ptr %74, align 8, !tbaa !30
  %76 = xor i64 %75, %39
  %77 = add i64 %76, %73
  %78 = add nuw nsw i64 %72, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %71, !llvm.loop !542

80:                                               ; preds = %71, %57
  %81 = phi i64 [ %59, %57 ], [ %77, %71 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !33
  %83 = fptoui double %82 to i64
  %84 = xor i64 %15, %83
  %85 = mul i64 %84, 8000
  %86 = icmp eq i64 %81, %85
  br i1 %86, label %67, label %63

87:                                               ; preds = %16, %100
  %88 = phi i32 [ %101, %100 ], [ %9, %16 ]
  %89 = phi double [ %102, %100 ], [ %17, %16 ]
  %90 = phi i32 [ %103, %100 ], [ 0, %16 ]
  %91 = fptoui double %89 to i64
  %92 = xor i64 %15, %91
  %93 = mul i64 %92, 8000
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %100, label %95

95:                                               ; preds = %87
  %96 = load i32, ptr @current_test, align 4, !tbaa !11
  %97 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %96)
  %98 = load double, ptr @init_value, align 8, !tbaa !33
  %99 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %100

100:                                              ; preds = %87, %95
  %101 = phi i32 [ %88, %87 ], [ %99, %95 ]
  %102 = phi double [ %89, %87 ], [ %98, %95 ]
  %103 = add nuw nsw i32 %90, 1
  %104 = icmp slt i32 %103, %101
  br i1 %104, label %87, label %105, !llvm.loop !541

105:                                              ; preds = %100, %67, %7
  %106 = tail call i64 @clock() #17
  store i64 %106, ptr @end_time, align 8, !tbaa !30
  %107 = load i64, ptr @start_time, align 8, !tbaa !30
  %108 = load ptr, ptr @results, align 8, !tbaa !6
  %109 = icmp ne ptr %108, null
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = load i32, ptr @current_test, align 4
  %112 = icmp slt i32 %111, %110
  %113 = select i1 %109, i1 %112, i1 false
  br i1 %113, label %125, label %114

114:                                              ; preds = %105
  %115 = add nsw i32 %110, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !11
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %108, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !6
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %114
  %121 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %125

122:                                              ; preds = %114
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %105, %120
  %126 = phi i32 [ %121, %120 ], [ %111, %105 ]
  %127 = phi ptr [ %118, %120 ], [ %108, %105 ]
  %128 = sub nsw i64 %106, %107
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !13
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !17
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %92

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %71

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x float> poison, float %2, i64 0
  %17 = shufflevector <4 x float> %16, <4 x float> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi float [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw float, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <4 x float>, ptr %25, align 4, !tbaa !43
  %28 = load <4 x float>, ptr %26, align 4, !tbaa !43
  %29 = fadd <4 x float> %17, %27
  %30 = fadd <4 x float> %17, %28
  %31 = tail call float @llvm.vector.reduce.fadd.v4f32(float %24, <4 x float> %29)
  %32 = tail call float @llvm.vector.reduce.fadd.v4f32(float %31, <4 x float> %30)
  %33 = add nuw i64 %23, 8
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !543

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi float [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %92, !llvm.loop !544

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi float [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw float, ptr %0, i64 %48
  %51 = load float, ptr %50, align 4, !tbaa !43
  %52 = fadd float %2, %51
  %53 = fadd float %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !545

56:                                               ; preds = %47, %35
  %57 = phi float [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptrunc double %58 to float
  %60 = fadd float %2, %59
  %61 = fmul float %60, 8.000000e+03
  %62 = fsub float %57, %61
  %63 = tail call noundef float @llvm.fabs.f32(float %57)
  %64 = fpext float %63 to double
  %65 = fcmp ogt double %64, 1.000000e-04
  %66 = fdiv float %62, %57
  %67 = select i1 %65, float %66, float %62
  %68 = tail call float @llvm.fabs.f32(float %67)
  %69 = fpext float %68 to double
  %70 = fcmp olt double %69, 1.000000e-03
  br i1 %70, label %43, label %39

71:                                               ; preds = %10, %87
  %72 = phi i32 [ %88, %87 ], [ %6, %10 ]
  %73 = phi double [ %89, %87 ], [ %11, %10 ]
  %74 = phi i32 [ %90, %87 ], [ 0, %10 ]
  %75 = fptrunc double %73 to float
  %76 = fadd float %2, %75
  %77 = fmul float %76, 8.000000e+03
  %78 = fsub float 0.000000e+00, %77
  %79 = tail call float @llvm.fabs.f32(float %78)
  %80 = fpext float %79 to double
  %81 = fcmp olt double %80, 1.000000e-03
  br i1 %81, label %87, label %82

82:                                               ; preds = %71
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %71, %82
  %88 = phi i32 [ %72, %71 ], [ %86, %82 ]
  %89 = phi double [ %73, %71 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %74, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %71, label %92, !llvm.loop !544

92:                                               ; preds = %87, %43, %4
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %3, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %115

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sitofp i32 %1 to float
  br i1 %9, label %11, label %66

11:                                               ; preds = %8
  %12 = zext nneg i32 %1 to i64
  %13 = icmp ult i32 %1, 8
  %14 = and i64 %12, 2147483640
  %15 = icmp eq i64 %14, %12
  br label %16

16:                                               ; preds = %11, %38
  %17 = phi i32 [ %39, %38 ], [ %6, %11 ]
  %18 = phi i32 [ %40, %38 ], [ 0, %11 ]
  br i1 %13, label %31, label %19

19:                                               ; preds = %16, %19
  %20 = phi i64 [ %28, %19 ], [ 0, %16 ]
  %21 = phi float [ %27, %19 ], [ 0.000000e+00, %16 ]
  %22 = getelementptr inbounds nuw float, ptr %0, i64 %20
  %23 = getelementptr inbounds nuw i8, ptr %22, i64 16
  %24 = load <4 x float>, ptr %22, align 4, !tbaa !43
  %25 = load <4 x float>, ptr %23, align 4, !tbaa !43
  %26 = tail call float @llvm.vector.reduce.fadd.v4f32(float %21, <4 x float> %24)
  %27 = tail call float @llvm.vector.reduce.fadd.v4f32(float %26, <4 x float> %25)
  %28 = add nuw i64 %20, 8
  %29 = icmp eq i64 %28, %14
  br i1 %29, label %30, label %19, !llvm.loop !546

30:                                               ; preds = %19
  br i1 %15, label %50, label %31

31:                                               ; preds = %16, %30
  %32 = phi i64 [ 0, %16 ], [ %14, %30 ]
  %33 = phi float [ 0.000000e+00, %16 ], [ %27, %30 ]
  br label %42

34:                                               ; preds = %50
  %35 = load i32, ptr @current_test, align 4, !tbaa !11
  %36 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %35)
  %37 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %38

38:                                               ; preds = %34, %50
  %39 = phi i32 [ %37, %34 ], [ %17, %50 ]
  %40 = add nuw nsw i32 %18, 1
  %41 = icmp slt i32 %40, %39
  br i1 %41, label %16, label %115, !llvm.loop !547

42:                                               ; preds = %31, %42
  %43 = phi i64 [ %48, %42 ], [ %32, %31 ]
  %44 = phi float [ %47, %42 ], [ %33, %31 ]
  %45 = getelementptr inbounds nuw float, ptr %0, i64 %43
  %46 = load float, ptr %45, align 4, !tbaa !43
  %47 = fadd float %44, %46
  %48 = add nuw nsw i64 %43, 1
  %49 = icmp eq i64 %48, %12
  br i1 %49, label %50, label %42, !llvm.loop !548

50:                                               ; preds = %42, %30
  %51 = phi float [ %27, %30 ], [ %47, %42 ]
  %52 = tail call float @llvm.fmuladd.f32(float %10, float %2, float %51)
  %53 = load double, ptr @init_value, align 8, !tbaa !33
  %54 = fptrunc double %53 to float
  %55 = fadd float %2, %54
  %56 = fmul float %55, 8.000000e+03
  %57 = fsub float %52, %56
  %58 = tail call noundef float @llvm.fabs.f32(float %52)
  %59 = fpext float %58 to double
  %60 = fcmp ogt double %59, 1.000000e-04
  %61 = fdiv float %57, %52
  %62 = select i1 %60, float %61, float %57
  %63 = tail call float @llvm.fabs.f32(float %62)
  %64 = fpext float %63 to double
  %65 = fcmp olt double %64, 1.000000e-03
  br i1 %65, label %38, label %34

66:                                               ; preds = %8
  %67 = tail call float @llvm.fmuladd.f32(float %10, float %2, float 0.000000e+00)
  %68 = tail call noundef float @llvm.fabs.f32(float %67)
  %69 = fpext float %68 to double
  %70 = fcmp ogt double %69, 1.000000e-04
  %71 = load double, ptr @init_value, align 8, !tbaa !33
  br i1 %70, label %72, label %94

72:                                               ; preds = %66, %89
  %73 = phi i32 [ %90, %89 ], [ %6, %66 ]
  %74 = phi double [ %91, %89 ], [ %71, %66 ]
  %75 = phi i32 [ %92, %89 ], [ 0, %66 ]
  %76 = fptrunc double %74 to float
  %77 = fadd float %2, %76
  %78 = fmul float %77, 8.000000e+03
  %79 = fsub float %67, %78
  %80 = fdiv float %79, %67
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fpext float %81 to double
  %83 = fcmp olt double %82, 1.000000e-03
  br i1 %83, label %89, label %84

84:                                               ; preds = %72
  %85 = load i32, ptr @current_test, align 4, !tbaa !11
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %85)
  %87 = load double, ptr @init_value, align 8, !tbaa !33
  %88 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %89

89:                                               ; preds = %72, %84
  %90 = phi i32 [ %73, %72 ], [ %88, %84 ]
  %91 = phi double [ %74, %72 ], [ %87, %84 ]
  %92 = add nuw nsw i32 %75, 1
  %93 = icmp slt i32 %92, %90
  br i1 %93, label %72, label %115, !llvm.loop !547

94:                                               ; preds = %66, %110
  %95 = phi i32 [ %111, %110 ], [ %6, %66 ]
  %96 = phi double [ %112, %110 ], [ %71, %66 ]
  %97 = phi i32 [ %113, %110 ], [ 0, %66 ]
  %98 = fptrunc double %96 to float
  %99 = fadd float %2, %98
  %100 = fmul float %99, 8.000000e+03
  %101 = fsub float %67, %100
  %102 = tail call float @llvm.fabs.f32(float %101)
  %103 = fpext float %102 to double
  %104 = fcmp olt double %103, 1.000000e-03
  br i1 %104, label %110, label %105

105:                                              ; preds = %94
  %106 = load i32, ptr @current_test, align 4, !tbaa !11
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %106)
  %108 = load double, ptr @init_value, align 8, !tbaa !33
  %109 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %110

110:                                              ; preds = %94, %105
  %111 = phi i32 [ %95, %94 ], [ %109, %105 ]
  %112 = phi double [ %96, %94 ], [ %108, %105 ]
  %113 = add nuw nsw i32 %97, 1
  %114 = icmp slt i32 %113, %111
  br i1 %114, label %94, label %115, !llvm.loop !547

115:                                              ; preds = %110, %89, %38, %4
  %116 = tail call i64 @clock() #17
  store i64 %116, ptr @end_time, align 8, !tbaa !30
  %117 = load i64, ptr @start_time, align 8, !tbaa !30
  %118 = load ptr, ptr @results, align 8, !tbaa !6
  %119 = icmp ne ptr %118, null
  %120 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %121 = load i32, ptr @current_test, align 4
  %122 = icmp slt i32 %121, %120
  %123 = select i1 %119, i1 %122, i1 false
  br i1 %123, label %135, label %124

124:                                              ; preds = %115
  %125 = add nsw i32 %120, 10
  store i32 %125, ptr @allocated_results, align 4, !tbaa !11
  %126 = sext i32 %125 to i64
  %127 = shl nsw i64 %126, 4
  %128 = tail call ptr @realloc(ptr noundef %118, i64 noundef %127) #14
  store ptr %128, ptr @results, align 8, !tbaa !6
  %129 = icmp eq ptr %128, null
  br i1 %129, label %132, label %130

130:                                              ; preds = %124
  %131 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %135

132:                                              ; preds = %124
  %133 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %134 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %133)
  tail call void @exit(i32 noundef -1) #15
  unreachable

135:                                              ; preds = %115, %130
  %136 = phi i32 [ %131, %130 ], [ %121, %115 ]
  %137 = phi ptr [ %128, %130 ], [ %118, %115 ]
  %138 = sub nsw i64 %116, %117
  %139 = sitofp i64 %138 to double
  %140 = fdiv double %139, 1.000000e+06
  %141 = sext i32 %136 to i64
  %142 = getelementptr inbounds %struct.one_result, ptr %137, i64 %141
  store double %140, ptr %142, align 8, !tbaa !13
  %143 = getelementptr inbounds %struct.one_result, ptr %137, i64 %141, i32 1
  store ptr %3, ptr %143, align 8, !tbaa !17
  %144 = add nsw i32 %136, 1
  store i32 %144, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %92

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 8
  %18 = and i64 %16, 2147483640
  %19 = insertelement <4 x float> poison, float %2, i64 0
  %20 = shufflevector <4 x float> %19, <4 x float> poison, <4 x i32> zeroinitializer
  %21 = insertelement <4 x float> poison, float %3, i64 0
  %22 = shufflevector <4 x float> %21, <4 x float> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x float> poison, float %4, i64 0
  %24 = shufflevector <4 x float> %23, <4 x float> poison, <4 x i32> zeroinitializer
  %25 = insertelement <4 x float> poison, float %5, i64 0
  %26 = shufflevector <4 x float> %25, <4 x float> poison, <4 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi float [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw float, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <4 x float>, ptr %34, align 4, !tbaa !43
  %37 = load <4 x float>, ptr %35, align 4, !tbaa !43
  %38 = fadd <4 x float> %20, %36
  %39 = fadd <4 x float> %20, %37
  %40 = fadd <4 x float> %22, %38
  %41 = fadd <4 x float> %22, %39
  %42 = fadd <4 x float> %24, %40
  %43 = fadd <4 x float> %24, %41
  %44 = fadd <4 x float> %26, %42
  %45 = fadd <4 x float> %26, %43
  %46 = tail call float @llvm.vector.reduce.fadd.v4f32(float %33, <4 x float> %44)
  %47 = tail call float @llvm.vector.reduce.fadd.v4f32(float %46, <4 x float> %45)
  %48 = add nuw i64 %32, 8
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !549

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi float [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %116, !llvm.loop !550

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi float [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw float, ptr %0, i64 %63
  %66 = load float, ptr %65, align 4, !tbaa !43
  %67 = fadd float %2, %66
  %68 = fadd float %3, %67
  %69 = fadd float %4, %68
  %70 = fadd float %5, %69
  %71 = fadd float %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !551

74:                                               ; preds = %62, %50
  %75 = phi float [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fptrunc double %76 to float
  %78 = fadd float %2, %77
  %79 = fadd float %3, %78
  %80 = fadd float %4, %79
  %81 = fadd float %5, %80
  %82 = fmul float %81, 8.000000e+03
  %83 = fsub float %75, %82
  %84 = tail call noundef float @llvm.fabs.f32(float %75)
  %85 = fpext float %84 to double
  %86 = fcmp ogt double %85, 1.000000e-04
  %87 = fdiv float %83, %75
  %88 = select i1 %86, float %87, float %83
  %89 = tail call float @llvm.fabs.f32(float %88)
  %90 = fpext float %89 to double
  %91 = fcmp olt double %90, 1.000000e-03
  br i1 %91, label %58, label %54

92:                                               ; preds = %13, %111
  %93 = phi i32 [ %112, %111 ], [ %9, %13 ]
  %94 = phi double [ %113, %111 ], [ %14, %13 ]
  %95 = phi i32 [ %114, %111 ], [ 0, %13 ]
  %96 = fptrunc double %94 to float
  %97 = fadd float %2, %96
  %98 = fadd float %3, %97
  %99 = fadd float %4, %98
  %100 = fadd float %5, %99
  %101 = fmul float %100, 8.000000e+03
  %102 = fsub float 0.000000e+00, %101
  %103 = tail call float @llvm.fabs.f32(float %102)
  %104 = fpext float %103 to double
  %105 = fcmp olt double %104, 1.000000e-03
  br i1 %105, label %111, label %106

106:                                              ; preds = %92
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %92, %106
  %112 = phi i32 [ %93, %92 ], [ %110, %106 ]
  %113 = phi double [ %94, %92 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %95, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %92, label %116, !llvm.loop !550

116:                                              ; preds = %111, %58, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %92

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %71

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x float> poison, float %2, i64 0
  %17 = shufflevector <4 x float> %16, <4 x float> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi float [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw float, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <4 x float>, ptr %25, align 4, !tbaa !43
  %28 = load <4 x float>, ptr %26, align 4, !tbaa !43
  %29 = fsub <4 x float> %27, %17
  %30 = fsub <4 x float> %28, %17
  %31 = tail call float @llvm.vector.reduce.fadd.v4f32(float %24, <4 x float> %29)
  %32 = tail call float @llvm.vector.reduce.fadd.v4f32(float %31, <4 x float> %30)
  %33 = add nuw i64 %23, 8
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !552

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi float [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %92, !llvm.loop !553

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi float [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw float, ptr %0, i64 %48
  %51 = load float, ptr %50, align 4, !tbaa !43
  %52 = fsub float %51, %2
  %53 = fadd float %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !554

56:                                               ; preds = %47, %35
  %57 = phi float [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptrunc double %58 to float
  %60 = fsub float %59, %2
  %61 = fmul float %60, 8.000000e+03
  %62 = fsub float %57, %61
  %63 = tail call noundef float @llvm.fabs.f32(float %57)
  %64 = fpext float %63 to double
  %65 = fcmp ogt double %64, 1.000000e-04
  %66 = fdiv float %62, %57
  %67 = select i1 %65, float %66, float %62
  %68 = tail call float @llvm.fabs.f32(float %67)
  %69 = fpext float %68 to double
  %70 = fcmp olt double %69, 1.000000e-03
  br i1 %70, label %43, label %39

71:                                               ; preds = %10, %87
  %72 = phi i32 [ %88, %87 ], [ %6, %10 ]
  %73 = phi double [ %89, %87 ], [ %11, %10 ]
  %74 = phi i32 [ %90, %87 ], [ 0, %10 ]
  %75 = fptrunc double %73 to float
  %76 = fsub float %75, %2
  %77 = fmul float %76, 8.000000e+03
  %78 = fsub float 0.000000e+00, %77
  %79 = tail call float @llvm.fabs.f32(float %78)
  %80 = fpext float %79 to double
  %81 = fcmp olt double %80, 1.000000e-03
  br i1 %81, label %87, label %82

82:                                               ; preds = %71
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %71, %82
  %88 = phi i32 [ %72, %71 ], [ %86, %82 ]
  %89 = phi double [ %73, %71 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %74, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %71, label %92, !llvm.loop !553

92:                                               ; preds = %87, %43, %4
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %3, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %92

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 8
  %18 = and i64 %16, 2147483640
  %19 = insertelement <4 x float> poison, float %2, i64 0
  %20 = shufflevector <4 x float> %19, <4 x float> poison, <4 x i32> zeroinitializer
  %21 = insertelement <4 x float> poison, float %3, i64 0
  %22 = shufflevector <4 x float> %21, <4 x float> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x float> poison, float %4, i64 0
  %24 = shufflevector <4 x float> %23, <4 x float> poison, <4 x i32> zeroinitializer
  %25 = insertelement <4 x float> poison, float %5, i64 0
  %26 = shufflevector <4 x float> %25, <4 x float> poison, <4 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi float [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw float, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <4 x float>, ptr %34, align 4, !tbaa !43
  %37 = load <4 x float>, ptr %35, align 4, !tbaa !43
  %38 = fsub <4 x float> %36, %20
  %39 = fsub <4 x float> %37, %20
  %40 = fsub <4 x float> %38, %22
  %41 = fsub <4 x float> %39, %22
  %42 = fsub <4 x float> %40, %24
  %43 = fsub <4 x float> %41, %24
  %44 = fsub <4 x float> %42, %26
  %45 = fsub <4 x float> %43, %26
  %46 = tail call float @llvm.vector.reduce.fadd.v4f32(float %33, <4 x float> %44)
  %47 = tail call float @llvm.vector.reduce.fadd.v4f32(float %46, <4 x float> %45)
  %48 = add nuw i64 %32, 8
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !555

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi float [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %116, !llvm.loop !556

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi float [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw float, ptr %0, i64 %63
  %66 = load float, ptr %65, align 4, !tbaa !43
  %67 = fsub float %66, %2
  %68 = fsub float %67, %3
  %69 = fsub float %68, %4
  %70 = fsub float %69, %5
  %71 = fadd float %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !557

74:                                               ; preds = %62, %50
  %75 = phi float [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fptrunc double %76 to float
  %78 = fsub float %77, %2
  %79 = fsub float %78, %3
  %80 = fsub float %79, %4
  %81 = fsub float %80, %5
  %82 = fmul float %81, 8.000000e+03
  %83 = fsub float %75, %82
  %84 = tail call noundef float @llvm.fabs.f32(float %75)
  %85 = fpext float %84 to double
  %86 = fcmp ogt double %85, 1.000000e-04
  %87 = fdiv float %83, %75
  %88 = select i1 %86, float %87, float %83
  %89 = tail call float @llvm.fabs.f32(float %88)
  %90 = fpext float %89 to double
  %91 = fcmp olt double %90, 1.000000e-03
  br i1 %91, label %58, label %54

92:                                               ; preds = %13, %111
  %93 = phi i32 [ %112, %111 ], [ %9, %13 ]
  %94 = phi double [ %113, %111 ], [ %14, %13 ]
  %95 = phi i32 [ %114, %111 ], [ 0, %13 ]
  %96 = fptrunc double %94 to float
  %97 = fsub float %96, %2
  %98 = fsub float %97, %3
  %99 = fsub float %98, %4
  %100 = fsub float %99, %5
  %101 = fmul float %100, 8.000000e+03
  %102 = fsub float 0.000000e+00, %101
  %103 = tail call float @llvm.fabs.f32(float %102)
  %104 = fpext float %103 to double
  %105 = fcmp olt double %104, 1.000000e-03
  br i1 %105, label %111, label %106

106:                                              ; preds = %92
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %92, %106
  %112 = phi i32 [ %93, %92 ], [ %110, %106 ]
  %113 = phi double [ %94, %92 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %95, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %92, label %116, !llvm.loop !556

116:                                              ; preds = %111, %58, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %92

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %71

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x float> poison, float %2, i64 0
  %17 = shufflevector <4 x float> %16, <4 x float> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi float [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw float, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <4 x float>, ptr %25, align 4, !tbaa !43
  %28 = load <4 x float>, ptr %26, align 4, !tbaa !43
  %29 = fmul <4 x float> %17, %27
  %30 = fmul <4 x float> %17, %28
  %31 = tail call float @llvm.vector.reduce.fadd.v4f32(float %24, <4 x float> %29)
  %32 = tail call float @llvm.vector.reduce.fadd.v4f32(float %31, <4 x float> %30)
  %33 = add nuw i64 %23, 8
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !558

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi float [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %92, !llvm.loop !559

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi float [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw float, ptr %0, i64 %48
  %51 = load float, ptr %50, align 4, !tbaa !43
  %52 = fmul float %2, %51
  %53 = fadd float %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !560

56:                                               ; preds = %47, %35
  %57 = phi float [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptrunc double %58 to float
  %60 = fmul float %2, %59
  %61 = fmul float %60, 8.000000e+03
  %62 = fsub float %57, %61
  %63 = tail call noundef float @llvm.fabs.f32(float %57)
  %64 = fpext float %63 to double
  %65 = fcmp ogt double %64, 1.000000e-04
  %66 = fdiv float %62, %57
  %67 = select i1 %65, float %66, float %62
  %68 = tail call float @llvm.fabs.f32(float %67)
  %69 = fpext float %68 to double
  %70 = fcmp olt double %69, 1.000000e-03
  br i1 %70, label %43, label %39

71:                                               ; preds = %10, %87
  %72 = phi i32 [ %88, %87 ], [ %6, %10 ]
  %73 = phi double [ %89, %87 ], [ %11, %10 ]
  %74 = phi i32 [ %90, %87 ], [ 0, %10 ]
  %75 = fptrunc double %73 to float
  %76 = fmul float %2, %75
  %77 = fmul float %76, 8.000000e+03
  %78 = fsub float 0.000000e+00, %77
  %79 = tail call float @llvm.fabs.f32(float %78)
  %80 = fpext float %79 to double
  %81 = fcmp olt double %80, 1.000000e-03
  br i1 %81, label %87, label %82

82:                                               ; preds = %71
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %71, %82
  %88 = phi i32 [ %72, %71 ], [ %86, %82 ]
  %89 = phi double [ %73, %71 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %74, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %71, label %92, !llvm.loop !559

92:                                               ; preds = %87, %43, %4
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %3, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %92

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 8
  %18 = and i64 %16, 2147483640
  %19 = insertelement <4 x float> poison, float %2, i64 0
  %20 = shufflevector <4 x float> %19, <4 x float> poison, <4 x i32> zeroinitializer
  %21 = insertelement <4 x float> poison, float %3, i64 0
  %22 = shufflevector <4 x float> %21, <4 x float> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x float> poison, float %4, i64 0
  %24 = shufflevector <4 x float> %23, <4 x float> poison, <4 x i32> zeroinitializer
  %25 = insertelement <4 x float> poison, float %5, i64 0
  %26 = shufflevector <4 x float> %25, <4 x float> poison, <4 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi float [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw float, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <4 x float>, ptr %34, align 4, !tbaa !43
  %37 = load <4 x float>, ptr %35, align 4, !tbaa !43
  %38 = fmul <4 x float> %20, %36
  %39 = fmul <4 x float> %20, %37
  %40 = fmul <4 x float> %22, %38
  %41 = fmul <4 x float> %22, %39
  %42 = fmul <4 x float> %24, %40
  %43 = fmul <4 x float> %24, %41
  %44 = fmul <4 x float> %26, %42
  %45 = fmul <4 x float> %26, %43
  %46 = tail call float @llvm.vector.reduce.fadd.v4f32(float %33, <4 x float> %44)
  %47 = tail call float @llvm.vector.reduce.fadd.v4f32(float %46, <4 x float> %45)
  %48 = add nuw i64 %32, 8
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !561

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi float [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %116, !llvm.loop !562

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi float [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw float, ptr %0, i64 %63
  %66 = load float, ptr %65, align 4, !tbaa !43
  %67 = fmul float %2, %66
  %68 = fmul float %3, %67
  %69 = fmul float %4, %68
  %70 = fmul float %5, %69
  %71 = fadd float %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !563

74:                                               ; preds = %62, %50
  %75 = phi float [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fptrunc double %76 to float
  %78 = fmul float %2, %77
  %79 = fmul float %3, %78
  %80 = fmul float %4, %79
  %81 = fmul float %5, %80
  %82 = fmul float %81, 8.000000e+03
  %83 = fsub float %75, %82
  %84 = tail call noundef float @llvm.fabs.f32(float %75)
  %85 = fpext float %84 to double
  %86 = fcmp ogt double %85, 1.000000e-04
  %87 = fdiv float %83, %75
  %88 = select i1 %86, float %87, float %83
  %89 = tail call float @llvm.fabs.f32(float %88)
  %90 = fpext float %89 to double
  %91 = fcmp olt double %90, 1.000000e-03
  br i1 %91, label %58, label %54

92:                                               ; preds = %13, %111
  %93 = phi i32 [ %112, %111 ], [ %9, %13 ]
  %94 = phi double [ %113, %111 ], [ %14, %13 ]
  %95 = phi i32 [ %114, %111 ], [ 0, %13 ]
  %96 = fptrunc double %94 to float
  %97 = fmul float %2, %96
  %98 = fmul float %3, %97
  %99 = fmul float %4, %98
  %100 = fmul float %5, %99
  %101 = fmul float %100, 8.000000e+03
  %102 = fsub float 0.000000e+00, %101
  %103 = tail call float @llvm.fabs.f32(float %102)
  %104 = fpext float %103 to double
  %105 = fcmp olt double %104, 1.000000e-03
  br i1 %105, label %111, label %106

106:                                              ; preds = %92
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %92, %106
  %112 = phi i32 [ %93, %92 ], [ %110, %106 ]
  %113 = phi double [ %94, %92 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %95, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %92, label %116, !llvm.loop !562

116:                                              ; preds = %111, %58, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %99

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul float %2, %3
  %14 = fmul float %13, %4
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !33
  br label %78

17:                                               ; preds = %11
  %18 = zext nneg i32 %1 to i64
  %19 = icmp ult i32 %1, 8
  %20 = and i64 %18, 2147483640
  %21 = insertelement <4 x float> poison, float %14, i64 0
  %22 = shufflevector <4 x float> %21, <4 x float> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x float> poison, float %5, i64 0
  %24 = shufflevector <4 x float> %23, <4 x float> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %20, %18
  br label %26

26:                                               ; preds = %17, %50
  %27 = phi i32 [ %51, %50 ], [ %9, %17 ]
  %28 = phi i32 [ %52, %50 ], [ 0, %17 ]
  br i1 %19, label %43, label %29

29:                                               ; preds = %26, %29
  %30 = phi i64 [ %40, %29 ], [ 0, %26 ]
  %31 = phi float [ %39, %29 ], [ 0.000000e+00, %26 ]
  %32 = getelementptr inbounds nuw float, ptr %0, i64 %30
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x float>, ptr %32, align 4, !tbaa !43
  %35 = load <4 x float>, ptr %33, align 4, !tbaa !43
  %36 = tail call <4 x float> @llvm.fmuladd.v4f32(<4 x float> %22, <4 x float> %24, <4 x float> %34)
  %37 = tail call <4 x float> @llvm.fmuladd.v4f32(<4 x float> %22, <4 x float> %24, <4 x float> %35)
  %38 = tail call float @llvm.vector.reduce.fadd.v4f32(float %31, <4 x float> %36)
  %39 = tail call float @llvm.vector.reduce.fadd.v4f32(float %38, <4 x float> %37)
  %40 = add nuw i64 %30, 8
  %41 = icmp eq i64 %40, %20
  br i1 %41, label %42, label %29, !llvm.loop !564

42:                                               ; preds = %29
  br i1 %25, label %63, label %43

43:                                               ; preds = %26, %42
  %44 = phi i64 [ 0, %26 ], [ %20, %42 ]
  %45 = phi float [ 0.000000e+00, %26 ], [ %39, %42 ]
  br label %54

46:                                               ; preds = %63
  %47 = load i32, ptr @current_test, align 4, !tbaa !11
  %48 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %47)
  %49 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %50

50:                                               ; preds = %46, %63
  %51 = phi i32 [ %49, %46 ], [ %27, %63 ]
  %52 = add nuw nsw i32 %28, 1
  %53 = icmp slt i32 %52, %51
  br i1 %53, label %26, label %99, !llvm.loop !565

54:                                               ; preds = %43, %54
  %55 = phi i64 [ %61, %54 ], [ %44, %43 ]
  %56 = phi float [ %60, %54 ], [ %45, %43 ]
  %57 = getelementptr inbounds nuw float, ptr %0, i64 %55
  %58 = load float, ptr %57, align 4, !tbaa !43
  %59 = tail call noundef float @llvm.fmuladd.f32(float %14, float %5, float %58)
  %60 = fadd float %56, %59
  %61 = add nuw nsw i64 %55, 1
  %62 = icmp eq i64 %61, %18
  br i1 %62, label %63, label %54, !llvm.loop !566

63:                                               ; preds = %54, %42
  %64 = phi float [ %39, %42 ], [ %60, %54 ]
  %65 = load double, ptr @init_value, align 8, !tbaa !33
  %66 = fptrunc double %65 to float
  %67 = tail call noundef float @llvm.fmuladd.f32(float %14, float %5, float %66)
  %68 = fmul float %67, 8.000000e+03
  %69 = fsub float %64, %68
  %70 = tail call noundef float @llvm.fabs.f32(float %64)
  %71 = fpext float %70 to double
  %72 = fcmp ogt double %71, 1.000000e-04
  %73 = fdiv float %69, %64
  %74 = select i1 %72, float %73, float %69
  %75 = tail call float @llvm.fabs.f32(float %74)
  %76 = fpext float %75 to double
  %77 = fcmp olt double %76, 1.000000e-03
  br i1 %77, label %50, label %46

78:                                               ; preds = %15, %94
  %79 = phi i32 [ %95, %94 ], [ %9, %15 ]
  %80 = phi double [ %96, %94 ], [ %16, %15 ]
  %81 = phi i32 [ %97, %94 ], [ 0, %15 ]
  %82 = fptrunc double %80 to float
  %83 = tail call noundef float @llvm.fmuladd.f32(float %14, float %5, float %82)
  %84 = fmul float %83, 8.000000e+03
  %85 = fsub float 0.000000e+00, %84
  %86 = tail call float @llvm.fabs.f32(float %85)
  %87 = fpext float %86 to double
  %88 = fcmp olt double %87, 1.000000e-03
  br i1 %88, label %94, label %89

89:                                               ; preds = %78
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %90)
  %92 = load double, ptr @init_value, align 8, !tbaa !33
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %78, %89
  %95 = phi i32 [ %79, %78 ], [ %93, %89 ]
  %96 = phi double [ %80, %78 ], [ %92, %89 ]
  %97 = add nuw nsw i32 %81, 1
  %98 = icmp slt i32 %97, %95
  br i1 %98, label %78, label %99, !llvm.loop !565

99:                                               ; preds = %94, %50, %7
  %100 = tail call i64 @clock() #17
  store i64 %100, ptr @end_time, align 8, !tbaa !30
  %101 = load i64, ptr @start_time, align 8, !tbaa !30
  %102 = load ptr, ptr @results, align 8, !tbaa !6
  %103 = icmp ne ptr %102, null
  %104 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %105 = load i32, ptr @current_test, align 4
  %106 = icmp slt i32 %105, %104
  %107 = select i1 %103, i1 %106, i1 false
  br i1 %107, label %119, label %108

108:                                              ; preds = %99
  %109 = add nsw i32 %104, 10
  store i32 %109, ptr @allocated_results, align 4, !tbaa !11
  %110 = sext i32 %109 to i64
  %111 = shl nsw i64 %110, 4
  %112 = tail call ptr @realloc(ptr noundef %102, i64 noundef %111) #14
  store ptr %112, ptr @results, align 8, !tbaa !6
  %113 = icmp eq ptr %112, null
  br i1 %113, label %116, label %114

114:                                              ; preds = %108
  %115 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %119

116:                                              ; preds = %108
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %118 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %117)
  tail call void @exit(i32 noundef -1) #15
  unreachable

119:                                              ; preds = %99, %114
  %120 = phi i32 [ %115, %114 ], [ %105, %99 ]
  %121 = phi ptr [ %112, %114 ], [ %102, %99 ]
  %122 = sub nsw i64 %100, %101
  %123 = sitofp i64 %122 to double
  %124 = fdiv double %123, 1.000000e+06
  %125 = sext i32 %120 to i64
  %126 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125
  store double %124, ptr %126, align 8, !tbaa !13
  %127 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125, i32 1
  store ptr %6, ptr %127, align 8, !tbaa !17
  %128 = add nsw i32 %120, 1
  store i32 %128, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %92

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %71

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 2147483640
  %16 = insertelement <4 x float> poison, float %2, i64 0
  %17 = shufflevector <4 x float> %16, <4 x float> poison, <4 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi float [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw float, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <4 x float>, ptr %25, align 4, !tbaa !43
  %28 = load <4 x float>, ptr %26, align 4, !tbaa !43
  %29 = fdiv <4 x float> %27, %17
  %30 = fdiv <4 x float> %28, %17
  %31 = tail call float @llvm.vector.reduce.fadd.v4f32(float %24, <4 x float> %29)
  %32 = tail call float @llvm.vector.reduce.fadd.v4f32(float %31, <4 x float> %30)
  %33 = add nuw i64 %23, 8
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !567

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi float [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %92, !llvm.loop !568

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi float [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw float, ptr %0, i64 %48
  %51 = load float, ptr %50, align 4, !tbaa !43
  %52 = fdiv float %51, %2
  %53 = fadd float %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !569

56:                                               ; preds = %47, %35
  %57 = phi float [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fptrunc double %58 to float
  %60 = fdiv float %59, %2
  %61 = fmul float %60, 8.000000e+03
  %62 = fsub float %57, %61
  %63 = tail call noundef float @llvm.fabs.f32(float %57)
  %64 = fpext float %63 to double
  %65 = fcmp ogt double %64, 1.000000e-04
  %66 = fdiv float %62, %57
  %67 = select i1 %65, float %66, float %62
  %68 = tail call float @llvm.fabs.f32(float %67)
  %69 = fpext float %68 to double
  %70 = fcmp olt double %69, 1.000000e-03
  br i1 %70, label %43, label %39

71:                                               ; preds = %10, %87
  %72 = phi i32 [ %88, %87 ], [ %6, %10 ]
  %73 = phi double [ %89, %87 ], [ %11, %10 ]
  %74 = phi i32 [ %90, %87 ], [ 0, %10 ]
  %75 = fptrunc double %73 to float
  %76 = fdiv float %75, %2
  %77 = fmul float %76, 8.000000e+03
  %78 = fsub float 0.000000e+00, %77
  %79 = tail call float @llvm.fabs.f32(float %78)
  %80 = fpext float %79 to double
  %81 = fcmp olt double %80, 1.000000e-03
  br i1 %81, label %87, label %82

82:                                               ; preds = %71
  %83 = load i32, ptr @current_test, align 4, !tbaa !11
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !33
  %86 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %87

87:                                               ; preds = %71, %82
  %88 = phi i32 [ %72, %71 ], [ %86, %82 ]
  %89 = phi double [ %73, %71 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %74, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %71, label %92, !llvm.loop !568

92:                                               ; preds = %87, %43, %4
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !30
  %94 = load i64, ptr @start_time, align 8, !tbaa !30
  %95 = load ptr, ptr @results, align 8, !tbaa !6
  %96 = icmp ne ptr %95, null
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %98 = load i32, ptr @current_test, align 4
  %99 = icmp slt i32 %98, %97
  %100 = select i1 %96, i1 %99, i1 false
  br i1 %100, label %112, label %101

101:                                              ; preds = %92
  %102 = add nsw i32 %97, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !11
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %95, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !6
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %101
  %108 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %112

109:                                              ; preds = %101
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %92, %107
  %113 = phi i32 [ %108, %107 ], [ %98, %92 ]
  %114 = phi ptr [ %105, %107 ], [ %95, %92 ]
  %115 = sub nsw i64 %93, %94
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !13
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %3, ptr %120, align 8, !tbaa !17
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %92

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 8
  %18 = and i64 %16, 2147483640
  %19 = insertelement <4 x float> poison, float %2, i64 0
  %20 = shufflevector <4 x float> %19, <4 x float> poison, <4 x i32> zeroinitializer
  %21 = insertelement <4 x float> poison, float %3, i64 0
  %22 = shufflevector <4 x float> %21, <4 x float> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x float> poison, float %4, i64 0
  %24 = shufflevector <4 x float> %23, <4 x float> poison, <4 x i32> zeroinitializer
  %25 = insertelement <4 x float> poison, float %5, i64 0
  %26 = shufflevector <4 x float> %25, <4 x float> poison, <4 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi float [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw float, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <4 x float>, ptr %34, align 4, !tbaa !43
  %37 = load <4 x float>, ptr %35, align 4, !tbaa !43
  %38 = fdiv <4 x float> %36, %20
  %39 = fdiv <4 x float> %37, %20
  %40 = fdiv <4 x float> %38, %22
  %41 = fdiv <4 x float> %39, %22
  %42 = fdiv <4 x float> %40, %24
  %43 = fdiv <4 x float> %41, %24
  %44 = fdiv <4 x float> %42, %26
  %45 = fdiv <4 x float> %43, %26
  %46 = tail call float @llvm.vector.reduce.fadd.v4f32(float %33, <4 x float> %44)
  %47 = tail call float @llvm.vector.reduce.fadd.v4f32(float %46, <4 x float> %45)
  %48 = add nuw i64 %32, 8
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !570

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi float [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %116, !llvm.loop !571

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi float [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw float, ptr %0, i64 %63
  %66 = load float, ptr %65, align 4, !tbaa !43
  %67 = fdiv float %66, %2
  %68 = fdiv float %67, %3
  %69 = fdiv float %68, %4
  %70 = fdiv float %69, %5
  %71 = fadd float %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !572

74:                                               ; preds = %62, %50
  %75 = phi float [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fptrunc double %76 to float
  %78 = fdiv float %77, %2
  %79 = fdiv float %78, %3
  %80 = fdiv float %79, %4
  %81 = fdiv float %80, %5
  %82 = fmul float %81, 8.000000e+03
  %83 = fsub float %75, %82
  %84 = tail call noundef float @llvm.fabs.f32(float %75)
  %85 = fpext float %84 to double
  %86 = fcmp ogt double %85, 1.000000e-04
  %87 = fdiv float %83, %75
  %88 = select i1 %86, float %87, float %83
  %89 = tail call float @llvm.fabs.f32(float %88)
  %90 = fpext float %89 to double
  %91 = fcmp olt double %90, 1.000000e-03
  br i1 %91, label %58, label %54

92:                                               ; preds = %13, %111
  %93 = phi i32 [ %112, %111 ], [ %9, %13 ]
  %94 = phi double [ %113, %111 ], [ %14, %13 ]
  %95 = phi i32 [ %114, %111 ], [ 0, %13 ]
  %96 = fptrunc double %94 to float
  %97 = fdiv float %96, %2
  %98 = fdiv float %97, %3
  %99 = fdiv float %98, %4
  %100 = fdiv float %99, %5
  %101 = fmul float %100, 8.000000e+03
  %102 = fsub float 0.000000e+00, %101
  %103 = tail call float @llvm.fabs.f32(float %102)
  %104 = fpext float %103 to double
  %105 = fcmp olt double %104, 1.000000e-03
  br i1 %105, label %111, label %106

106:                                              ; preds = %92
  %107 = load i32, ptr @current_test, align 4, !tbaa !11
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !33
  %110 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %111

111:                                              ; preds = %92, %106
  %112 = phi i32 [ %93, %92 ], [ %110, %106 ]
  %113 = phi double [ %94, %92 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %95, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %92, label %116, !llvm.loop !571

116:                                              ; preds = %111, %58, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !30
  %118 = load i64, ptr @start_time, align 8, !tbaa !30
  %119 = load ptr, ptr @results, align 8, !tbaa !6
  %120 = icmp ne ptr %119, null
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %122 = load i32, ptr @current_test, align 4
  %123 = icmp slt i32 %122, %121
  %124 = select i1 %120, i1 %123, i1 false
  br i1 %124, label %136, label %125

125:                                              ; preds = %116
  %126 = add nsw i32 %121, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !11
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %119, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !6
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %125
  %132 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %136

133:                                              ; preds = %125
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %116, %131
  %137 = phi i32 [ %132, %131 ], [ %122, %116 ]
  %138 = phi ptr [ %129, %131 ], [ %119, %116 ]
  %139 = sub nsw i64 %117, %118
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !13
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !17
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %98

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fdiv float %2, %3
  %14 = fdiv float %13, %4
  %15 = fdiv float %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %77

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 2147483640
  %22 = insertelement <4 x float> poison, float %15, i64 0
  %23 = shufflevector <4 x float> %22, <4 x float> poison, <4 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %49
  %26 = phi i32 [ %50, %49 ], [ %9, %18 ]
  %27 = phi i32 [ %51, %49 ], [ 0, %18 ]
  br i1 %20, label %42, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %39, %28 ], [ 0, %25 ]
  %30 = phi float [ %38, %28 ], [ 0.000000e+00, %25 ]
  %31 = getelementptr inbounds nuw float, ptr %0, i64 %29
  %32 = getelementptr inbounds nuw i8, ptr %31, i64 16
  %33 = load <4 x float>, ptr %31, align 4, !tbaa !43
  %34 = load <4 x float>, ptr %32, align 4, !tbaa !43
  %35 = fadd <4 x float> %23, %33
  %36 = fadd <4 x float> %23, %34
  %37 = tail call float @llvm.vector.reduce.fadd.v4f32(float %30, <4 x float> %35)
  %38 = tail call float @llvm.vector.reduce.fadd.v4f32(float %37, <4 x float> %36)
  %39 = add nuw i64 %29, 8
  %40 = icmp eq i64 %39, %21
  br i1 %40, label %41, label %28, !llvm.loop !573

41:                                               ; preds = %28
  br i1 %24, label %62, label %42

42:                                               ; preds = %25, %41
  %43 = phi i64 [ 0, %25 ], [ %21, %41 ]
  %44 = phi float [ 0.000000e+00, %25 ], [ %38, %41 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !11
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %26, %62 ]
  %51 = add nuw nsw i32 %27, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %25, label %98, !llvm.loop !574

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi float [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds nuw float, ptr %0, i64 %54
  %57 = load float, ptr %56, align 4, !tbaa !43
  %58 = fadd float %15, %57
  %59 = fadd float %55, %58
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %19
  br i1 %61, label %62, label %53, !llvm.loop !575

62:                                               ; preds = %53, %41
  %63 = phi float [ %38, %41 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !33
  %65 = fptrunc double %64 to float
  %66 = fadd float %15, %65
  %67 = fmul float %66, 8.000000e+03
  %68 = fsub float %63, %67
  %69 = tail call noundef float @llvm.fabs.f32(float %63)
  %70 = fpext float %69 to double
  %71 = fcmp ogt double %70, 1.000000e-04
  %72 = fdiv float %68, %63
  %73 = select i1 %71, float %72, float %68
  %74 = tail call float @llvm.fabs.f32(float %73)
  %75 = fpext float %74 to double
  %76 = fcmp olt double %75, 1.000000e-03
  br i1 %76, label %49, label %45

77:                                               ; preds = %16, %93
  %78 = phi i32 [ %94, %93 ], [ %9, %16 ]
  %79 = phi double [ %95, %93 ], [ %17, %16 ]
  %80 = phi i32 [ %96, %93 ], [ 0, %16 ]
  %81 = fptrunc double %79 to float
  %82 = fadd float %15, %81
  %83 = fmul float %82, 8.000000e+03
  %84 = fsub float 0.000000e+00, %83
  %85 = tail call float @llvm.fabs.f32(float %84)
  %86 = fpext float %85 to double
  %87 = fcmp olt double %86, 1.000000e-03
  br i1 %87, label %93, label %88

88:                                               ; preds = %77
  %89 = load i32, ptr @current_test, align 4, !tbaa !11
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %89)
  %91 = load double, ptr @init_value, align 8, !tbaa !33
  %92 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %93

93:                                               ; preds = %77, %88
  %94 = phi i32 [ %78, %77 ], [ %92, %88 ]
  %95 = phi double [ %79, %77 ], [ %91, %88 ]
  %96 = add nuw nsw i32 %80, 1
  %97 = icmp slt i32 %96, %94
  br i1 %97, label %77, label %98, !llvm.loop !574

98:                                               ; preds = %93, %49, %7
  %99 = tail call i64 @clock() #17
  store i64 %99, ptr @end_time, align 8, !tbaa !30
  %100 = load i64, ptr @start_time, align 8, !tbaa !30
  %101 = load ptr, ptr @results, align 8, !tbaa !6
  %102 = icmp ne ptr %101, null
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %104 = load i32, ptr @current_test, align 4
  %105 = icmp slt i32 %104, %103
  %106 = select i1 %102, i1 %105, i1 false
  br i1 %106, label %118, label %107

107:                                              ; preds = %98
  %108 = add nsw i32 %103, 10
  store i32 %108, ptr @allocated_results, align 4, !tbaa !11
  %109 = sext i32 %108 to i64
  %110 = shl nsw i64 %109, 4
  %111 = tail call ptr @realloc(ptr noundef %101, i64 noundef %110) #14
  store ptr %111, ptr @results, align 8, !tbaa !6
  %112 = icmp eq ptr %111, null
  br i1 %112, label %115, label %113

113:                                              ; preds = %107
  %114 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %118

115:                                              ; preds = %107
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %117 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %116)
  tail call void @exit(i32 noundef -1) #15
  unreachable

118:                                              ; preds = %98, %113
  %119 = phi i32 [ %114, %113 ], [ %104, %98 ]
  %120 = phi ptr [ %111, %113 ], [ %101, %98 ]
  %121 = sub nsw i64 %99, %100
  %122 = sitofp i64 %121 to double
  %123 = fdiv double %122, 1.000000e+06
  %124 = sext i32 %119 to i64
  %125 = getelementptr inbounds %struct.one_result, ptr %120, i64 %124
  store double %123, ptr %125, align 8, !tbaa !13
  %126 = getelementptr inbounds %struct.one_result, ptr %120, i64 %124, i32 1
  store ptr %6, ptr %126, align 8, !tbaa !17
  %127 = add nsw i32 %119, 1
  store i32 %127, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %104

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul float %3, %4
  %14 = fdiv float %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !33
  br label %82

17:                                               ; preds = %11
  %18 = zext nneg i32 %1 to i64
  %19 = icmp ult i32 %1, 8
  %20 = and i64 %18, 2147483640
  %21 = insertelement <4 x float> poison, float %2, i64 0
  %22 = shufflevector <4 x float> %21, <4 x float> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x float> poison, float %14, i64 0
  %24 = shufflevector <4 x float> %23, <4 x float> poison, <4 x i32> zeroinitializer
  %25 = icmp eq i64 %20, %18
  br label %26

26:                                               ; preds = %17, %52
  %27 = phi i32 [ %53, %52 ], [ %9, %17 ]
  %28 = phi i32 [ %54, %52 ], [ 0, %17 ]
  br i1 %19, label %45, label %29

29:                                               ; preds = %26, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %26 ]
  %31 = phi float [ %41, %29 ], [ 0.000000e+00, %26 ]
  %32 = getelementptr inbounds nuw float, ptr %0, i64 %30
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <4 x float>, ptr %32, align 4, !tbaa !43
  %35 = load <4 x float>, ptr %33, align 4, !tbaa !43
  %36 = fadd <4 x float> %22, %34
  %37 = fadd <4 x float> %22, %35
  %38 = fsub <4 x float> %36, %24
  %39 = fsub <4 x float> %37, %24
  %40 = tail call float @llvm.vector.reduce.fadd.v4f32(float %31, <4 x float> %38)
  %41 = tail call float @llvm.vector.reduce.fadd.v4f32(float %40, <4 x float> %39)
  %42 = add nuw i64 %30, 8
  %43 = icmp eq i64 %42, %20
  br i1 %43, label %44, label %29, !llvm.loop !576

44:                                               ; preds = %29
  br i1 %25, label %66, label %45

45:                                               ; preds = %26, %44
  %46 = phi i64 [ 0, %26 ], [ %20, %44 ]
  %47 = phi float [ 0.000000e+00, %26 ], [ %41, %44 ]
  br label %56

48:                                               ; preds = %66
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %66
  %53 = phi i32 [ %51, %48 ], [ %27, %66 ]
  %54 = add nuw nsw i32 %28, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %26, label %104, !llvm.loop !577

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %64, %56 ], [ %46, %45 ]
  %58 = phi float [ %63, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw float, ptr %0, i64 %57
  %60 = load float, ptr %59, align 4, !tbaa !43
  %61 = fadd float %2, %60
  %62 = fsub float %61, %14
  %63 = fadd float %58, %62
  %64 = add nuw nsw i64 %57, 1
  %65 = icmp eq i64 %64, %18
  br i1 %65, label %66, label %56, !llvm.loop !578

66:                                               ; preds = %56, %44
  %67 = phi float [ %41, %44 ], [ %63, %56 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !33
  %69 = fptrunc double %68 to float
  %70 = fadd float %2, %69
  %71 = fsub float %70, %14
  %72 = fmul float %71, 8.000000e+03
  %73 = fsub float %67, %72
  %74 = tail call noundef float @llvm.fabs.f32(float %67)
  %75 = fpext float %74 to double
  %76 = fcmp ogt double %75, 1.000000e-04
  %77 = fdiv float %73, %67
  %78 = select i1 %76, float %77, float %73
  %79 = tail call float @llvm.fabs.f32(float %78)
  %80 = fpext float %79 to double
  %81 = fcmp olt double %80, 1.000000e-03
  br i1 %81, label %52, label %48

82:                                               ; preds = %15, %99
  %83 = phi i32 [ %100, %99 ], [ %9, %15 ]
  %84 = phi double [ %101, %99 ], [ %16, %15 ]
  %85 = phi i32 [ %102, %99 ], [ 0, %15 ]
  %86 = fptrunc double %84 to float
  %87 = fadd float %2, %86
  %88 = fsub float %87, %14
  %89 = fmul float %88, 8.000000e+03
  %90 = fsub float 0.000000e+00, %89
  %91 = tail call float @llvm.fabs.f32(float %90)
  %92 = fpext float %91 to double
  %93 = fcmp olt double %92, 1.000000e-03
  br i1 %93, label %99, label %94

94:                                               ; preds = %82
  %95 = load i32, ptr @current_test, align 4, !tbaa !11
  %96 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %95)
  %97 = load double, ptr @init_value, align 8, !tbaa !33
  %98 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %99

99:                                               ; preds = %82, %94
  %100 = phi i32 [ %83, %82 ], [ %98, %94 ]
  %101 = phi double [ %84, %82 ], [ %97, %94 ]
  %102 = add nuw nsw i32 %85, 1
  %103 = icmp slt i32 %102, %100
  br i1 %103, label %82, label %104, !llvm.loop !577

104:                                              ; preds = %99, %52, %7
  %105 = tail call i64 @clock() #17
  store i64 %105, ptr @end_time, align 8, !tbaa !30
  %106 = load i64, ptr @start_time, align 8, !tbaa !30
  %107 = load ptr, ptr @results, align 8, !tbaa !6
  %108 = icmp ne ptr %107, null
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %110 = load i32, ptr @current_test, align 4
  %111 = icmp slt i32 %110, %109
  %112 = select i1 %108, i1 %111, i1 false
  br i1 %112, label %124, label %113

113:                                              ; preds = %104
  %114 = add nsw i32 %109, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !11
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %107, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !6
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %113
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %124

121:                                              ; preds = %113
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %104, %119
  %125 = phi i32 [ %120, %119 ], [ %110, %104 ]
  %126 = phi ptr [ %117, %119 ], [ %107, %104 ]
  %127 = sub nsw i64 %105, %106
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !13
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !17
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %87

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %68

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x double> poison, double %2, i64 0
  %17 = shufflevector <2 x double> %16, <2 x double> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi double [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw double, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <2 x double>, ptr %25, align 8, !tbaa !33
  %28 = load <2 x double>, ptr %26, align 8, !tbaa !33
  %29 = fadd <2 x double> %17, %27
  %30 = fadd <2 x double> %17, %28
  %31 = tail call double @llvm.vector.reduce.fadd.v2f64(double %24, <2 x double> %29)
  %32 = tail call double @llvm.vector.reduce.fadd.v2f64(double %31, <2 x double> %30)
  %33 = add nuw i64 %23, 4
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !579

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi double [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %87, !llvm.loop !580

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi double [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !33
  %52 = fadd double %2, %51
  %53 = fadd double %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !581

56:                                               ; preds = %47, %35
  %57 = phi double [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fadd double %2, %58
  %60 = fmul double %59, 8.000000e+03
  %61 = fsub double %57, %60
  %62 = tail call double @llvm.fabs.f64(double %57)
  %63 = fcmp ogt double %62, 1.000000e-08
  %64 = fdiv double %61, %57
  %65 = select i1 %63, double %64, double %61
  %66 = tail call double @llvm.fabs.f64(double %65)
  %67 = fcmp olt double %66, 0x3EB0C6F7A0B5ED8D
  br i1 %67, label %43, label %39

68:                                               ; preds = %10, %82
  %69 = phi i32 [ %83, %82 ], [ %6, %10 ]
  %70 = phi double [ %84, %82 ], [ %11, %10 ]
  %71 = phi i32 [ %85, %82 ], [ 0, %10 ]
  %72 = fadd double %2, %70
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double 0.000000e+00, %73
  %75 = tail call double @llvm.fabs.f64(double %74)
  %76 = fcmp olt double %75, 0x3EB0C6F7A0B5ED8D
  br i1 %76, label %82, label %77

77:                                               ; preds = %68
  %78 = load i32, ptr @current_test, align 4, !tbaa !11
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %68, %77
  %83 = phi i32 [ %69, %68 ], [ %81, %77 ]
  %84 = phi double [ %70, %68 ], [ %80, %77 ]
  %85 = add nuw nsw i32 %71, 1
  %86 = icmp slt i32 %85, %83
  br i1 %86, label %68, label %87, !llvm.loop !580

87:                                               ; preds = %82, %43, %4
  %88 = tail call i64 @clock() #17
  store i64 %88, ptr @end_time, align 8, !tbaa !30
  %89 = load i64, ptr @start_time, align 8, !tbaa !30
  %90 = load ptr, ptr @results, align 8, !tbaa !6
  %91 = icmp ne ptr %90, null
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %93 = load i32, ptr @current_test, align 4
  %94 = icmp slt i32 %93, %92
  %95 = select i1 %91, i1 %94, i1 false
  br i1 %95, label %107, label %96

96:                                               ; preds = %87
  %97 = add nsw i32 %92, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !11
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %90, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !6
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %96
  %103 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %107

104:                                              ; preds = %96
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %87, %102
  %108 = phi i32 [ %103, %102 ], [ %93, %87 ]
  %109 = phi ptr [ %100, %102 ], [ %90, %87 ]
  %110 = sub nsw i64 %88, %89
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !13
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !17
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %107

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sitofp i32 %1 to double
  br i1 %9, label %11, label %63

11:                                               ; preds = %8
  %12 = zext nneg i32 %1 to i64
  %13 = icmp ult i32 %1, 4
  %14 = and i64 %12, 2147483644
  %15 = icmp eq i64 %14, %12
  br label %16

16:                                               ; preds = %11, %38
  %17 = phi i32 [ %39, %38 ], [ %6, %11 ]
  %18 = phi i32 [ %40, %38 ], [ 0, %11 ]
  br i1 %13, label %31, label %19

19:                                               ; preds = %16, %19
  %20 = phi i64 [ %28, %19 ], [ 0, %16 ]
  %21 = phi double [ %27, %19 ], [ 0.000000e+00, %16 ]
  %22 = getelementptr inbounds nuw double, ptr %0, i64 %20
  %23 = getelementptr inbounds nuw i8, ptr %22, i64 16
  %24 = load <2 x double>, ptr %22, align 8, !tbaa !33
  %25 = load <2 x double>, ptr %23, align 8, !tbaa !33
  %26 = tail call double @llvm.vector.reduce.fadd.v2f64(double %21, <2 x double> %24)
  %27 = tail call double @llvm.vector.reduce.fadd.v2f64(double %26, <2 x double> %25)
  %28 = add nuw i64 %20, 4
  %29 = icmp eq i64 %28, %14
  br i1 %29, label %30, label %19, !llvm.loop !582

30:                                               ; preds = %19
  br i1 %15, label %50, label %31

31:                                               ; preds = %16, %30
  %32 = phi i64 [ 0, %16 ], [ %14, %30 ]
  %33 = phi double [ 0.000000e+00, %16 ], [ %27, %30 ]
  br label %42

34:                                               ; preds = %50
  %35 = load i32, ptr @current_test, align 4, !tbaa !11
  %36 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %35)
  %37 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %38

38:                                               ; preds = %34, %50
  %39 = phi i32 [ %37, %34 ], [ %17, %50 ]
  %40 = add nuw nsw i32 %18, 1
  %41 = icmp slt i32 %40, %39
  br i1 %41, label %16, label %107, !llvm.loop !583

42:                                               ; preds = %31, %42
  %43 = phi i64 [ %48, %42 ], [ %32, %31 ]
  %44 = phi double [ %47, %42 ], [ %33, %31 ]
  %45 = getelementptr inbounds nuw double, ptr %0, i64 %43
  %46 = load double, ptr %45, align 8, !tbaa !33
  %47 = fadd double %44, %46
  %48 = add nuw nsw i64 %43, 1
  %49 = icmp eq i64 %48, %12
  br i1 %49, label %50, label %42, !llvm.loop !584

50:                                               ; preds = %42, %30
  %51 = phi double [ %27, %30 ], [ %47, %42 ]
  %52 = tail call double @llvm.fmuladd.f64(double %10, double %2, double %51)
  %53 = load double, ptr @init_value, align 8, !tbaa !33
  %54 = fadd double %2, %53
  %55 = fmul double %54, 8.000000e+03
  %56 = fsub double %52, %55
  %57 = tail call double @llvm.fabs.f64(double %52)
  %58 = fcmp ogt double %57, 1.000000e-08
  %59 = fdiv double %56, %52
  %60 = select i1 %58, double %59, double %56
  %61 = tail call double @llvm.fabs.f64(double %60)
  %62 = fcmp olt double %61, 0x3EB0C6F7A0B5ED8D
  br i1 %62, label %38, label %34

63:                                               ; preds = %8
  %64 = tail call double @llvm.fmuladd.f64(double %10, double %2, double 0.000000e+00)
  %65 = tail call double @llvm.fabs.f64(double %64)
  %66 = fcmp ogt double %65, 1.000000e-08
  %67 = load double, ptr @init_value, align 8, !tbaa !33
  br i1 %66, label %68, label %88

68:                                               ; preds = %63, %83
  %69 = phi i32 [ %84, %83 ], [ %6, %63 ]
  %70 = phi double [ %85, %83 ], [ %67, %63 ]
  %71 = phi i32 [ %86, %83 ], [ 0, %63 ]
  %72 = fadd double %2, %70
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double %64, %73
  %75 = fdiv double %74, %64
  %76 = tail call double @llvm.fabs.f64(double %75)
  %77 = fcmp olt double %76, 0x3EB0C6F7A0B5ED8D
  br i1 %77, label %83, label %78

78:                                               ; preds = %68
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %79)
  %81 = load double, ptr @init_value, align 8, !tbaa !33
  %82 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %83

83:                                               ; preds = %68, %78
  %84 = phi i32 [ %69, %68 ], [ %82, %78 ]
  %85 = phi double [ %70, %68 ], [ %81, %78 ]
  %86 = add nuw nsw i32 %71, 1
  %87 = icmp slt i32 %86, %84
  br i1 %87, label %68, label %107, !llvm.loop !583

88:                                               ; preds = %63, %102
  %89 = phi i32 [ %103, %102 ], [ %6, %63 ]
  %90 = phi double [ %104, %102 ], [ %67, %63 ]
  %91 = phi i32 [ %105, %102 ], [ 0, %63 ]
  %92 = fadd double %2, %90
  %93 = fmul double %92, 8.000000e+03
  %94 = fsub double %64, %93
  %95 = tail call double @llvm.fabs.f64(double %94)
  %96 = fcmp olt double %95, 0x3EB0C6F7A0B5ED8D
  br i1 %96, label %102, label %97

97:                                               ; preds = %88
  %98 = load i32, ptr @current_test, align 4, !tbaa !11
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %98)
  %100 = load double, ptr @init_value, align 8, !tbaa !33
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %88, %97
  %103 = phi i32 [ %89, %88 ], [ %101, %97 ]
  %104 = phi double [ %90, %88 ], [ %100, %97 ]
  %105 = add nuw nsw i32 %91, 1
  %106 = icmp slt i32 %105, %103
  br i1 %106, label %88, label %107, !llvm.loop !583

107:                                              ; preds = %102, %83, %38, %4
  %108 = tail call i64 @clock() #17
  store i64 %108, ptr @end_time, align 8, !tbaa !30
  %109 = load i64, ptr @start_time, align 8, !tbaa !30
  %110 = load ptr, ptr @results, align 8, !tbaa !6
  %111 = icmp ne ptr %110, null
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = load i32, ptr @current_test, align 4
  %114 = icmp slt i32 %113, %112
  %115 = select i1 %111, i1 %114, i1 false
  br i1 %115, label %127, label %116

116:                                              ; preds = %107
  %117 = add nsw i32 %112, 10
  store i32 %117, ptr @allocated_results, align 4, !tbaa !11
  %118 = sext i32 %117 to i64
  %119 = shl nsw i64 %118, 4
  %120 = tail call ptr @realloc(ptr noundef %110, i64 noundef %119) #14
  store ptr %120, ptr @results, align 8, !tbaa !6
  %121 = icmp eq ptr %120, null
  br i1 %121, label %124, label %122

122:                                              ; preds = %116
  %123 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %127

124:                                              ; preds = %116
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %126 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %125)
  tail call void @exit(i32 noundef -1) #15
  unreachable

127:                                              ; preds = %107, %122
  %128 = phi i32 [ %123, %122 ], [ %113, %107 ]
  %129 = phi ptr [ %120, %122 ], [ %110, %107 ]
  %130 = sub nsw i64 %108, %109
  %131 = sitofp i64 %130 to double
  %132 = fdiv double %131, 1.000000e+06
  %133 = sext i32 %128 to i64
  %134 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133
  store double %132, ptr %134, align 8, !tbaa !13
  %135 = getelementptr inbounds %struct.one_result, ptr %129, i64 %133, i32 1
  store ptr %3, ptr %135, align 8, !tbaa !17
  %136 = add nsw i32 %128, 1
  store i32 %136, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %89

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 4
  %18 = and i64 %16, 2147483644
  %19 = insertelement <2 x double> poison, double %2, i64 0
  %20 = shufflevector <2 x double> %19, <2 x double> poison, <2 x i32> zeroinitializer
  %21 = insertelement <2 x double> poison, double %3, i64 0
  %22 = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x double> poison, double %4, i64 0
  %24 = shufflevector <2 x double> %23, <2 x double> poison, <2 x i32> zeroinitializer
  %25 = insertelement <2 x double> poison, double %5, i64 0
  %26 = shufflevector <2 x double> %25, <2 x double> poison, <2 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi double [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw double, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <2 x double>, ptr %34, align 8, !tbaa !33
  %37 = load <2 x double>, ptr %35, align 8, !tbaa !33
  %38 = fadd <2 x double> %20, %36
  %39 = fadd <2 x double> %20, %37
  %40 = fadd <2 x double> %22, %38
  %41 = fadd <2 x double> %22, %39
  %42 = fadd <2 x double> %24, %40
  %43 = fadd <2 x double> %24, %41
  %44 = fadd <2 x double> %26, %42
  %45 = fadd <2 x double> %26, %43
  %46 = tail call double @llvm.vector.reduce.fadd.v2f64(double %33, <2 x double> %44)
  %47 = tail call double @llvm.vector.reduce.fadd.v2f64(double %46, <2 x double> %45)
  %48 = add nuw i64 %32, 4
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !585

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi double [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %111, !llvm.loop !586

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi double [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw double, ptr %0, i64 %63
  %66 = load double, ptr %65, align 8, !tbaa !33
  %67 = fadd double %2, %66
  %68 = fadd double %3, %67
  %69 = fadd double %4, %68
  %70 = fadd double %5, %69
  %71 = fadd double %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !587

74:                                               ; preds = %62, %50
  %75 = phi double [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fadd double %2, %76
  %78 = fadd double %3, %77
  %79 = fadd double %4, %78
  %80 = fadd double %5, %79
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %75, %81
  %83 = tail call double @llvm.fabs.f64(double %75)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = fdiv double %82, %75
  %86 = select i1 %84, double %85, double %82
  %87 = tail call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %58, label %54

89:                                               ; preds = %13, %106
  %90 = phi i32 [ %107, %106 ], [ %9, %13 ]
  %91 = phi double [ %108, %106 ], [ %14, %13 ]
  %92 = phi i32 [ %109, %106 ], [ 0, %13 ]
  %93 = fadd double %2, %91
  %94 = fadd double %3, %93
  %95 = fadd double %4, %94
  %96 = fadd double %5, %95
  %97 = fmul double %96, 8.000000e+03
  %98 = fsub double 0.000000e+00, %97
  %99 = tail call double @llvm.fabs.f64(double %98)
  %100 = fcmp olt double %99, 0x3EB0C6F7A0B5ED8D
  br i1 %100, label %106, label %101

101:                                              ; preds = %89
  %102 = load i32, ptr @current_test, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !33
  %105 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %106

106:                                              ; preds = %89, %101
  %107 = phi i32 [ %90, %89 ], [ %105, %101 ]
  %108 = phi double [ %91, %89 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %92, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %89, label %111, !llvm.loop !586

111:                                              ; preds = %106, %58, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !30
  %113 = load i64, ptr @start_time, align 8, !tbaa !30
  %114 = load ptr, ptr @results, align 8, !tbaa !6
  %115 = icmp ne ptr %114, null
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %117 = load i32, ptr @current_test, align 4
  %118 = icmp slt i32 %117, %116
  %119 = select i1 %115, i1 %118, i1 false
  br i1 %119, label %131, label %120

120:                                              ; preds = %111
  %121 = add nsw i32 %116, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !11
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %114, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !6
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %120
  %127 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %131

128:                                              ; preds = %120
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %111, %126
  %132 = phi i32 [ %127, %126 ], [ %117, %111 ]
  %133 = phi ptr [ %124, %126 ], [ %114, %111 ]
  %134 = sub nsw i64 %112, %113
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !13
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !17
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %87

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %68

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x double> poison, double %2, i64 0
  %17 = shufflevector <2 x double> %16, <2 x double> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi double [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw double, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <2 x double>, ptr %25, align 8, !tbaa !33
  %28 = load <2 x double>, ptr %26, align 8, !tbaa !33
  %29 = fsub <2 x double> %27, %17
  %30 = fsub <2 x double> %28, %17
  %31 = tail call double @llvm.vector.reduce.fadd.v2f64(double %24, <2 x double> %29)
  %32 = tail call double @llvm.vector.reduce.fadd.v2f64(double %31, <2 x double> %30)
  %33 = add nuw i64 %23, 4
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !588

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi double [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %87, !llvm.loop !589

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi double [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !33
  %52 = fsub double %51, %2
  %53 = fadd double %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !590

56:                                               ; preds = %47, %35
  %57 = phi double [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fsub double %58, %2
  %60 = fmul double %59, 8.000000e+03
  %61 = fsub double %57, %60
  %62 = tail call double @llvm.fabs.f64(double %57)
  %63 = fcmp ogt double %62, 1.000000e-08
  %64 = fdiv double %61, %57
  %65 = select i1 %63, double %64, double %61
  %66 = tail call double @llvm.fabs.f64(double %65)
  %67 = fcmp olt double %66, 0x3EB0C6F7A0B5ED8D
  br i1 %67, label %43, label %39

68:                                               ; preds = %10, %82
  %69 = phi i32 [ %83, %82 ], [ %6, %10 ]
  %70 = phi double [ %84, %82 ], [ %11, %10 ]
  %71 = phi i32 [ %85, %82 ], [ 0, %10 ]
  %72 = fsub double %70, %2
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double 0.000000e+00, %73
  %75 = tail call double @llvm.fabs.f64(double %74)
  %76 = fcmp olt double %75, 0x3EB0C6F7A0B5ED8D
  br i1 %76, label %82, label %77

77:                                               ; preds = %68
  %78 = load i32, ptr @current_test, align 4, !tbaa !11
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %68, %77
  %83 = phi i32 [ %69, %68 ], [ %81, %77 ]
  %84 = phi double [ %70, %68 ], [ %80, %77 ]
  %85 = add nuw nsw i32 %71, 1
  %86 = icmp slt i32 %85, %83
  br i1 %86, label %68, label %87, !llvm.loop !589

87:                                               ; preds = %82, %43, %4
  %88 = tail call i64 @clock() #17
  store i64 %88, ptr @end_time, align 8, !tbaa !30
  %89 = load i64, ptr @start_time, align 8, !tbaa !30
  %90 = load ptr, ptr @results, align 8, !tbaa !6
  %91 = icmp ne ptr %90, null
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %93 = load i32, ptr @current_test, align 4
  %94 = icmp slt i32 %93, %92
  %95 = select i1 %91, i1 %94, i1 false
  br i1 %95, label %107, label %96

96:                                               ; preds = %87
  %97 = add nsw i32 %92, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !11
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %90, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !6
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %96
  %103 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %107

104:                                              ; preds = %96
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %87, %102
  %108 = phi i32 [ %103, %102 ], [ %93, %87 ]
  %109 = phi ptr [ %100, %102 ], [ %90, %87 ]
  %110 = sub nsw i64 %88, %89
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !13
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !17
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %89

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 4
  %18 = and i64 %16, 2147483644
  %19 = insertelement <2 x double> poison, double %2, i64 0
  %20 = shufflevector <2 x double> %19, <2 x double> poison, <2 x i32> zeroinitializer
  %21 = insertelement <2 x double> poison, double %3, i64 0
  %22 = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x double> poison, double %4, i64 0
  %24 = shufflevector <2 x double> %23, <2 x double> poison, <2 x i32> zeroinitializer
  %25 = insertelement <2 x double> poison, double %5, i64 0
  %26 = shufflevector <2 x double> %25, <2 x double> poison, <2 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi double [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw double, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <2 x double>, ptr %34, align 8, !tbaa !33
  %37 = load <2 x double>, ptr %35, align 8, !tbaa !33
  %38 = fsub <2 x double> %36, %20
  %39 = fsub <2 x double> %37, %20
  %40 = fsub <2 x double> %38, %22
  %41 = fsub <2 x double> %39, %22
  %42 = fsub <2 x double> %40, %24
  %43 = fsub <2 x double> %41, %24
  %44 = fsub <2 x double> %42, %26
  %45 = fsub <2 x double> %43, %26
  %46 = tail call double @llvm.vector.reduce.fadd.v2f64(double %33, <2 x double> %44)
  %47 = tail call double @llvm.vector.reduce.fadd.v2f64(double %46, <2 x double> %45)
  %48 = add nuw i64 %32, 4
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !591

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi double [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %111, !llvm.loop !592

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi double [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw double, ptr %0, i64 %63
  %66 = load double, ptr %65, align 8, !tbaa !33
  %67 = fsub double %66, %2
  %68 = fsub double %67, %3
  %69 = fsub double %68, %4
  %70 = fsub double %69, %5
  %71 = fadd double %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !593

74:                                               ; preds = %62, %50
  %75 = phi double [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fsub double %76, %2
  %78 = fsub double %77, %3
  %79 = fsub double %78, %4
  %80 = fsub double %79, %5
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %75, %81
  %83 = tail call double @llvm.fabs.f64(double %75)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = fdiv double %82, %75
  %86 = select i1 %84, double %85, double %82
  %87 = tail call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %58, label %54

89:                                               ; preds = %13, %106
  %90 = phi i32 [ %107, %106 ], [ %9, %13 ]
  %91 = phi double [ %108, %106 ], [ %14, %13 ]
  %92 = phi i32 [ %109, %106 ], [ 0, %13 ]
  %93 = fsub double %91, %2
  %94 = fsub double %93, %3
  %95 = fsub double %94, %4
  %96 = fsub double %95, %5
  %97 = fmul double %96, 8.000000e+03
  %98 = fsub double 0.000000e+00, %97
  %99 = tail call double @llvm.fabs.f64(double %98)
  %100 = fcmp olt double %99, 0x3EB0C6F7A0B5ED8D
  br i1 %100, label %106, label %101

101:                                              ; preds = %89
  %102 = load i32, ptr @current_test, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !33
  %105 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %106

106:                                              ; preds = %89, %101
  %107 = phi i32 [ %90, %89 ], [ %105, %101 ]
  %108 = phi double [ %91, %89 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %92, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %89, label %111, !llvm.loop !592

111:                                              ; preds = %106, %58, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !30
  %113 = load i64, ptr @start_time, align 8, !tbaa !30
  %114 = load ptr, ptr @results, align 8, !tbaa !6
  %115 = icmp ne ptr %114, null
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %117 = load i32, ptr @current_test, align 4
  %118 = icmp slt i32 %117, %116
  %119 = select i1 %115, i1 %118, i1 false
  br i1 %119, label %131, label %120

120:                                              ; preds = %111
  %121 = add nsw i32 %116, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !11
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %114, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !6
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %120
  %127 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %131

128:                                              ; preds = %120
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %111, %126
  %132 = phi i32 [ %127, %126 ], [ %117, %111 ]
  %133 = phi ptr [ %124, %126 ], [ %114, %111 ]
  %134 = sub nsw i64 %112, %113
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !13
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !17
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %87

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %68

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x double> poison, double %2, i64 0
  %17 = shufflevector <2 x double> %16, <2 x double> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi double [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw double, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <2 x double>, ptr %25, align 8, !tbaa !33
  %28 = load <2 x double>, ptr %26, align 8, !tbaa !33
  %29 = fmul <2 x double> %17, %27
  %30 = fmul <2 x double> %17, %28
  %31 = tail call double @llvm.vector.reduce.fadd.v2f64(double %24, <2 x double> %29)
  %32 = tail call double @llvm.vector.reduce.fadd.v2f64(double %31, <2 x double> %30)
  %33 = add nuw i64 %23, 4
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !594

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi double [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %87, !llvm.loop !595

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi double [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !33
  %52 = fmul double %2, %51
  %53 = fadd double %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !596

56:                                               ; preds = %47, %35
  %57 = phi double [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fmul double %2, %58
  %60 = fmul double %59, 8.000000e+03
  %61 = fsub double %57, %60
  %62 = tail call double @llvm.fabs.f64(double %57)
  %63 = fcmp ogt double %62, 1.000000e-08
  %64 = fdiv double %61, %57
  %65 = select i1 %63, double %64, double %61
  %66 = tail call double @llvm.fabs.f64(double %65)
  %67 = fcmp olt double %66, 0x3EB0C6F7A0B5ED8D
  br i1 %67, label %43, label %39

68:                                               ; preds = %10, %82
  %69 = phi i32 [ %83, %82 ], [ %6, %10 ]
  %70 = phi double [ %84, %82 ], [ %11, %10 ]
  %71 = phi i32 [ %85, %82 ], [ 0, %10 ]
  %72 = fmul double %2, %70
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double 0.000000e+00, %73
  %75 = tail call double @llvm.fabs.f64(double %74)
  %76 = fcmp olt double %75, 0x3EB0C6F7A0B5ED8D
  br i1 %76, label %82, label %77

77:                                               ; preds = %68
  %78 = load i32, ptr @current_test, align 4, !tbaa !11
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %68, %77
  %83 = phi i32 [ %69, %68 ], [ %81, %77 ]
  %84 = phi double [ %70, %68 ], [ %80, %77 ]
  %85 = add nuw nsw i32 %71, 1
  %86 = icmp slt i32 %85, %83
  br i1 %86, label %68, label %87, !llvm.loop !595

87:                                               ; preds = %82, %43, %4
  %88 = tail call i64 @clock() #17
  store i64 %88, ptr @end_time, align 8, !tbaa !30
  %89 = load i64, ptr @start_time, align 8, !tbaa !30
  %90 = load ptr, ptr @results, align 8, !tbaa !6
  %91 = icmp ne ptr %90, null
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %93 = load i32, ptr @current_test, align 4
  %94 = icmp slt i32 %93, %92
  %95 = select i1 %91, i1 %94, i1 false
  br i1 %95, label %107, label %96

96:                                               ; preds = %87
  %97 = add nsw i32 %92, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !11
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %90, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !6
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %96
  %103 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %107

104:                                              ; preds = %96
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %87, %102
  %108 = phi i32 [ %103, %102 ], [ %93, %87 ]
  %109 = phi ptr [ %100, %102 ], [ %90, %87 ]
  %110 = sub nsw i64 %88, %89
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !13
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !17
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %89

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 4
  %18 = and i64 %16, 2147483644
  %19 = insertelement <2 x double> poison, double %2, i64 0
  %20 = shufflevector <2 x double> %19, <2 x double> poison, <2 x i32> zeroinitializer
  %21 = insertelement <2 x double> poison, double %3, i64 0
  %22 = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x double> poison, double %4, i64 0
  %24 = shufflevector <2 x double> %23, <2 x double> poison, <2 x i32> zeroinitializer
  %25 = insertelement <2 x double> poison, double %5, i64 0
  %26 = shufflevector <2 x double> %25, <2 x double> poison, <2 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi double [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw double, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <2 x double>, ptr %34, align 8, !tbaa !33
  %37 = load <2 x double>, ptr %35, align 8, !tbaa !33
  %38 = fmul <2 x double> %20, %36
  %39 = fmul <2 x double> %20, %37
  %40 = fmul <2 x double> %22, %38
  %41 = fmul <2 x double> %22, %39
  %42 = fmul <2 x double> %24, %40
  %43 = fmul <2 x double> %24, %41
  %44 = fmul <2 x double> %26, %42
  %45 = fmul <2 x double> %26, %43
  %46 = tail call double @llvm.vector.reduce.fadd.v2f64(double %33, <2 x double> %44)
  %47 = tail call double @llvm.vector.reduce.fadd.v2f64(double %46, <2 x double> %45)
  %48 = add nuw i64 %32, 4
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !597

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi double [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %111, !llvm.loop !598

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi double [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw double, ptr %0, i64 %63
  %66 = load double, ptr %65, align 8, !tbaa !33
  %67 = fmul double %2, %66
  %68 = fmul double %3, %67
  %69 = fmul double %4, %68
  %70 = fmul double %5, %69
  %71 = fadd double %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !599

74:                                               ; preds = %62, %50
  %75 = phi double [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fmul double %2, %76
  %78 = fmul double %3, %77
  %79 = fmul double %4, %78
  %80 = fmul double %5, %79
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %75, %81
  %83 = tail call double @llvm.fabs.f64(double %75)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = fdiv double %82, %75
  %86 = select i1 %84, double %85, double %82
  %87 = tail call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %58, label %54

89:                                               ; preds = %13, %106
  %90 = phi i32 [ %107, %106 ], [ %9, %13 ]
  %91 = phi double [ %108, %106 ], [ %14, %13 ]
  %92 = phi i32 [ %109, %106 ], [ 0, %13 ]
  %93 = fmul double %2, %91
  %94 = fmul double %3, %93
  %95 = fmul double %4, %94
  %96 = fmul double %5, %95
  %97 = fmul double %96, 8.000000e+03
  %98 = fsub double 0.000000e+00, %97
  %99 = tail call double @llvm.fabs.f64(double %98)
  %100 = fcmp olt double %99, 0x3EB0C6F7A0B5ED8D
  br i1 %100, label %106, label %101

101:                                              ; preds = %89
  %102 = load i32, ptr @current_test, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !33
  %105 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %106

106:                                              ; preds = %89, %101
  %107 = phi i32 [ %90, %89 ], [ %105, %101 ]
  %108 = phi double [ %91, %89 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %92, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %89, label %111, !llvm.loop !598

111:                                              ; preds = %106, %58, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !30
  %113 = load i64, ptr @start_time, align 8, !tbaa !30
  %114 = load ptr, ptr @results, align 8, !tbaa !6
  %115 = icmp ne ptr %114, null
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %117 = load i32, ptr @current_test, align 4
  %118 = icmp slt i32 %117, %116
  %119 = select i1 %115, i1 %118, i1 false
  br i1 %119, label %131, label %120

120:                                              ; preds = %111
  %121 = add nsw i32 %116, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !11
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %114, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !6
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %120
  %127 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %131

128:                                              ; preds = %120
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %111, %126
  %132 = phi i32 [ %127, %126 ], [ %117, %111 ]
  %133 = phi ptr [ %124, %126 ], [ %114, %111 ]
  %134 = sub nsw i64 %112, %113
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !13
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !17
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %94

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul double %2, %3
  %14 = fmul double %13, %4
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !33
  br label %75

17:                                               ; preds = %11
  %18 = zext nneg i32 %1 to i64
  %19 = icmp ult i32 %1, 4
  %20 = and i64 %18, 2147483644
  %21 = insertelement <2 x double> poison, double %14, i64 0
  %22 = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x double> poison, double %5, i64 0
  %24 = shufflevector <2 x double> %23, <2 x double> poison, <2 x i32> zeroinitializer
  %25 = icmp eq i64 %20, %18
  br label %26

26:                                               ; preds = %17, %50
  %27 = phi i32 [ %51, %50 ], [ %9, %17 ]
  %28 = phi i32 [ %52, %50 ], [ 0, %17 ]
  br i1 %19, label %43, label %29

29:                                               ; preds = %26, %29
  %30 = phi i64 [ %40, %29 ], [ 0, %26 ]
  %31 = phi double [ %39, %29 ], [ 0.000000e+00, %26 ]
  %32 = getelementptr inbounds nuw double, ptr %0, i64 %30
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x double>, ptr %32, align 8, !tbaa !33
  %35 = load <2 x double>, ptr %33, align 8, !tbaa !33
  %36 = tail call <2 x double> @llvm.fmuladd.v2f64(<2 x double> %22, <2 x double> %24, <2 x double> %34)
  %37 = tail call <2 x double> @llvm.fmuladd.v2f64(<2 x double> %22, <2 x double> %24, <2 x double> %35)
  %38 = tail call double @llvm.vector.reduce.fadd.v2f64(double %31, <2 x double> %36)
  %39 = tail call double @llvm.vector.reduce.fadd.v2f64(double %38, <2 x double> %37)
  %40 = add nuw i64 %30, 4
  %41 = icmp eq i64 %40, %20
  br i1 %41, label %42, label %29, !llvm.loop !600

42:                                               ; preds = %29
  br i1 %25, label %63, label %43

43:                                               ; preds = %26, %42
  %44 = phi i64 [ 0, %26 ], [ %20, %42 ]
  %45 = phi double [ 0.000000e+00, %26 ], [ %39, %42 ]
  br label %54

46:                                               ; preds = %63
  %47 = load i32, ptr @current_test, align 4, !tbaa !11
  %48 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %47)
  %49 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %50

50:                                               ; preds = %46, %63
  %51 = phi i32 [ %49, %46 ], [ %27, %63 ]
  %52 = add nuw nsw i32 %28, 1
  %53 = icmp slt i32 %52, %51
  br i1 %53, label %26, label %94, !llvm.loop !601

54:                                               ; preds = %43, %54
  %55 = phi i64 [ %61, %54 ], [ %44, %43 ]
  %56 = phi double [ %60, %54 ], [ %45, %43 ]
  %57 = getelementptr inbounds nuw double, ptr %0, i64 %55
  %58 = load double, ptr %57, align 8, !tbaa !33
  %59 = tail call noundef double @llvm.fmuladd.f64(double %14, double %5, double %58)
  %60 = fadd double %56, %59
  %61 = add nuw nsw i64 %55, 1
  %62 = icmp eq i64 %61, %18
  br i1 %62, label %63, label %54, !llvm.loop !602

63:                                               ; preds = %54, %42
  %64 = phi double [ %39, %42 ], [ %60, %54 ]
  %65 = load double, ptr @init_value, align 8, !tbaa !33
  %66 = tail call noundef double @llvm.fmuladd.f64(double %14, double %5, double %65)
  %67 = fmul double %66, 8.000000e+03
  %68 = fsub double %64, %67
  %69 = tail call double @llvm.fabs.f64(double %64)
  %70 = fcmp ogt double %69, 1.000000e-08
  %71 = fdiv double %68, %64
  %72 = select i1 %70, double %71, double %68
  %73 = tail call double @llvm.fabs.f64(double %72)
  %74 = fcmp olt double %73, 0x3EB0C6F7A0B5ED8D
  br i1 %74, label %50, label %46

75:                                               ; preds = %15, %89
  %76 = phi i32 [ %90, %89 ], [ %9, %15 ]
  %77 = phi double [ %91, %89 ], [ %16, %15 ]
  %78 = phi i32 [ %92, %89 ], [ 0, %15 ]
  %79 = tail call noundef double @llvm.fmuladd.f64(double %14, double %5, double %77)
  %80 = fmul double %79, 8.000000e+03
  %81 = fsub double 0.000000e+00, %80
  %82 = tail call double @llvm.fabs.f64(double %81)
  %83 = fcmp olt double %82, 0x3EB0C6F7A0B5ED8D
  br i1 %83, label %89, label %84

84:                                               ; preds = %75
  %85 = load i32, ptr @current_test, align 4, !tbaa !11
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %85)
  %87 = load double, ptr @init_value, align 8, !tbaa !33
  %88 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %89

89:                                               ; preds = %75, %84
  %90 = phi i32 [ %76, %75 ], [ %88, %84 ]
  %91 = phi double [ %77, %75 ], [ %87, %84 ]
  %92 = add nuw nsw i32 %78, 1
  %93 = icmp slt i32 %92, %90
  br i1 %93, label %75, label %94, !llvm.loop !601

94:                                               ; preds = %89, %50, %7
  %95 = tail call i64 @clock() #17
  store i64 %95, ptr @end_time, align 8, !tbaa !30
  %96 = load i64, ptr @start_time, align 8, !tbaa !30
  %97 = load ptr, ptr @results, align 8, !tbaa !6
  %98 = icmp ne ptr %97, null
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %100 = load i32, ptr @current_test, align 4
  %101 = icmp slt i32 %100, %99
  %102 = select i1 %98, i1 %101, i1 false
  br i1 %102, label %114, label %103

103:                                              ; preds = %94
  %104 = add nsw i32 %99, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !11
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %97, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !6
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %103
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %114

111:                                              ; preds = %103
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %94, %109
  %115 = phi i32 [ %110, %109 ], [ %100, %94 ]
  %116 = phi ptr [ %107, %109 ], [ %97, %94 ]
  %117 = sub nsw i64 %95, %96
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !13
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !17
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !30
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %87

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !33
  br label %68

12:                                               ; preds = %8
  %13 = zext nneg i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 2147483644
  %16 = insertelement <2 x double> poison, double %2, i64 0
  %17 = shufflevector <2 x double> %16, <2 x double> poison, <2 x i32> zeroinitializer
  %18 = icmp eq i64 %15, %13
  br label %19

19:                                               ; preds = %12, %43
  %20 = phi i32 [ %44, %43 ], [ %6, %12 ]
  %21 = phi i32 [ %45, %43 ], [ 0, %12 ]
  br i1 %14, label %36, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %33, %22 ], [ 0, %19 ]
  %24 = phi double [ %32, %22 ], [ 0.000000e+00, %19 ]
  %25 = getelementptr inbounds nuw double, ptr %0, i64 %23
  %26 = getelementptr inbounds nuw i8, ptr %25, i64 16
  %27 = load <2 x double>, ptr %25, align 8, !tbaa !33
  %28 = load <2 x double>, ptr %26, align 8, !tbaa !33
  %29 = fdiv <2 x double> %27, %17
  %30 = fdiv <2 x double> %28, %17
  %31 = tail call double @llvm.vector.reduce.fadd.v2f64(double %24, <2 x double> %29)
  %32 = tail call double @llvm.vector.reduce.fadd.v2f64(double %31, <2 x double> %30)
  %33 = add nuw i64 %23, 4
  %34 = icmp eq i64 %33, %15
  br i1 %34, label %35, label %22, !llvm.loop !603

35:                                               ; preds = %22
  br i1 %18, label %56, label %36

36:                                               ; preds = %19, %35
  %37 = phi i64 [ 0, %19 ], [ %15, %35 ]
  %38 = phi double [ 0.000000e+00, %19 ], [ %32, %35 ]
  br label %47

39:                                               ; preds = %56
  %40 = load i32, ptr @current_test, align 4, !tbaa !11
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %43

43:                                               ; preds = %39, %56
  %44 = phi i32 [ %42, %39 ], [ %20, %56 ]
  %45 = add nuw nsw i32 %21, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %19, label %87, !llvm.loop !604

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %54, %47 ], [ %37, %36 ]
  %49 = phi double [ %53, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds nuw double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !33
  %52 = fdiv double %51, %2
  %53 = fadd double %49, %52
  %54 = add nuw nsw i64 %48, 1
  %55 = icmp eq i64 %54, %13
  br i1 %55, label %56, label %47, !llvm.loop !605

56:                                               ; preds = %47, %35
  %57 = phi double [ %32, %35 ], [ %53, %47 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !33
  %59 = fdiv double %58, %2
  %60 = fmul double %59, 8.000000e+03
  %61 = fsub double %57, %60
  %62 = tail call double @llvm.fabs.f64(double %57)
  %63 = fcmp ogt double %62, 1.000000e-08
  %64 = fdiv double %61, %57
  %65 = select i1 %63, double %64, double %61
  %66 = tail call double @llvm.fabs.f64(double %65)
  %67 = fcmp olt double %66, 0x3EB0C6F7A0B5ED8D
  br i1 %67, label %43, label %39

68:                                               ; preds = %10, %82
  %69 = phi i32 [ %83, %82 ], [ %6, %10 ]
  %70 = phi double [ %84, %82 ], [ %11, %10 ]
  %71 = phi i32 [ %85, %82 ], [ 0, %10 ]
  %72 = fdiv double %70, %2
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double 0.000000e+00, %73
  %75 = tail call double @llvm.fabs.f64(double %74)
  %76 = fcmp olt double %75, 0x3EB0C6F7A0B5ED8D
  br i1 %76, label %82, label %77

77:                                               ; preds = %68
  %78 = load i32, ptr @current_test, align 4, !tbaa !11
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load double, ptr @init_value, align 8, !tbaa !33
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %68, %77
  %83 = phi i32 [ %69, %68 ], [ %81, %77 ]
  %84 = phi double [ %70, %68 ], [ %80, %77 ]
  %85 = add nuw nsw i32 %71, 1
  %86 = icmp slt i32 %85, %83
  br i1 %86, label %68, label %87, !llvm.loop !604

87:                                               ; preds = %82, %43, %4
  %88 = tail call i64 @clock() #17
  store i64 %88, ptr @end_time, align 8, !tbaa !30
  %89 = load i64, ptr @start_time, align 8, !tbaa !30
  %90 = load ptr, ptr @results, align 8, !tbaa !6
  %91 = icmp ne ptr %90, null
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %93 = load i32, ptr @current_test, align 4
  %94 = icmp slt i32 %93, %92
  %95 = select i1 %91, i1 %94, i1 false
  br i1 %95, label %107, label %96

96:                                               ; preds = %87
  %97 = add nsw i32 %92, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !11
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %90, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !6
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %96
  %103 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %107

104:                                              ; preds = %96
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %87, %102
  %108 = phi i32 [ %103, %102 ], [ %93, %87 ]
  %109 = phi ptr [ %100, %102 ], [ %90, %87 ]
  %110 = sub nsw i64 %88, %89
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !13
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !17
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !33
  br label %89

15:                                               ; preds = %11
  %16 = zext nneg i32 %1 to i64
  %17 = icmp ult i32 %1, 4
  %18 = and i64 %16, 2147483644
  %19 = insertelement <2 x double> poison, double %2, i64 0
  %20 = shufflevector <2 x double> %19, <2 x double> poison, <2 x i32> zeroinitializer
  %21 = insertelement <2 x double> poison, double %3, i64 0
  %22 = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x double> poison, double %4, i64 0
  %24 = shufflevector <2 x double> %23, <2 x double> poison, <2 x i32> zeroinitializer
  %25 = insertelement <2 x double> poison, double %5, i64 0
  %26 = shufflevector <2 x double> %25, <2 x double> poison, <2 x i32> zeroinitializer
  %27 = icmp eq i64 %18, %16
  br label %28

28:                                               ; preds = %15, %58
  %29 = phi i32 [ %59, %58 ], [ %9, %15 ]
  %30 = phi i32 [ %60, %58 ], [ 0, %15 ]
  br i1 %17, label %51, label %31

31:                                               ; preds = %28, %31
  %32 = phi i64 [ %48, %31 ], [ 0, %28 ]
  %33 = phi double [ %47, %31 ], [ 0.000000e+00, %28 ]
  %34 = getelementptr inbounds nuw double, ptr %0, i64 %32
  %35 = getelementptr inbounds nuw i8, ptr %34, i64 16
  %36 = load <2 x double>, ptr %34, align 8, !tbaa !33
  %37 = load <2 x double>, ptr %35, align 8, !tbaa !33
  %38 = fdiv <2 x double> %36, %20
  %39 = fdiv <2 x double> %37, %20
  %40 = fdiv <2 x double> %38, %22
  %41 = fdiv <2 x double> %39, %22
  %42 = fdiv <2 x double> %40, %24
  %43 = fdiv <2 x double> %41, %24
  %44 = fdiv <2 x double> %42, %26
  %45 = fdiv <2 x double> %43, %26
  %46 = tail call double @llvm.vector.reduce.fadd.v2f64(double %33, <2 x double> %44)
  %47 = tail call double @llvm.vector.reduce.fadd.v2f64(double %46, <2 x double> %45)
  %48 = add nuw i64 %32, 4
  %49 = icmp eq i64 %48, %18
  br i1 %49, label %50, label %31, !llvm.loop !606

50:                                               ; preds = %31
  br i1 %27, label %74, label %51

51:                                               ; preds = %28, %50
  %52 = phi i64 [ 0, %28 ], [ %18, %50 ]
  %53 = phi double [ 0.000000e+00, %28 ], [ %47, %50 ]
  br label %62

54:                                               ; preds = %74
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %55)
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %74
  %59 = phi i32 [ %57, %54 ], [ %29, %74 ]
  %60 = add nuw nsw i32 %30, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %28, label %111, !llvm.loop !607

62:                                               ; preds = %51, %62
  %63 = phi i64 [ %72, %62 ], [ %52, %51 ]
  %64 = phi double [ %71, %62 ], [ %53, %51 ]
  %65 = getelementptr inbounds nuw double, ptr %0, i64 %63
  %66 = load double, ptr %65, align 8, !tbaa !33
  %67 = fdiv double %66, %2
  %68 = fdiv double %67, %3
  %69 = fdiv double %68, %4
  %70 = fdiv double %69, %5
  %71 = fadd double %64, %70
  %72 = add nuw nsw i64 %63, 1
  %73 = icmp eq i64 %72, %16
  br i1 %73, label %74, label %62, !llvm.loop !608

74:                                               ; preds = %62, %50
  %75 = phi double [ %47, %50 ], [ %71, %62 ]
  %76 = load double, ptr @init_value, align 8, !tbaa !33
  %77 = fdiv double %76, %2
  %78 = fdiv double %77, %3
  %79 = fdiv double %78, %4
  %80 = fdiv double %79, %5
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %75, %81
  %83 = tail call double @llvm.fabs.f64(double %75)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = fdiv double %82, %75
  %86 = select i1 %84, double %85, double %82
  %87 = tail call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %58, label %54

89:                                               ; preds = %13, %106
  %90 = phi i32 [ %107, %106 ], [ %9, %13 ]
  %91 = phi double [ %108, %106 ], [ %14, %13 ]
  %92 = phi i32 [ %109, %106 ], [ 0, %13 ]
  %93 = fdiv double %91, %2
  %94 = fdiv double %93, %3
  %95 = fdiv double %94, %4
  %96 = fdiv double %95, %5
  %97 = fmul double %96, 8.000000e+03
  %98 = fsub double 0.000000e+00, %97
  %99 = tail call double @llvm.fabs.f64(double %98)
  %100 = fcmp olt double %99, 0x3EB0C6F7A0B5ED8D
  br i1 %100, label %106, label %101

101:                                              ; preds = %89
  %102 = load i32, ptr @current_test, align 4, !tbaa !11
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !33
  %105 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %106

106:                                              ; preds = %89, %101
  %107 = phi i32 [ %90, %89 ], [ %105, %101 ]
  %108 = phi double [ %91, %89 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %92, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %89, label %111, !llvm.loop !607

111:                                              ; preds = %106, %58, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !30
  %113 = load i64, ptr @start_time, align 8, !tbaa !30
  %114 = load ptr, ptr @results, align 8, !tbaa !6
  %115 = icmp ne ptr %114, null
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %117 = load i32, ptr @current_test, align 4
  %118 = icmp slt i32 %117, %116
  %119 = select i1 %115, i1 %118, i1 false
  br i1 %119, label %131, label %120

120:                                              ; preds = %111
  %121 = add nsw i32 %116, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !11
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %114, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !6
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %120
  %127 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %131

128:                                              ; preds = %120
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %111, %126
  %132 = phi i32 [ %127, %126 ], [ %117, %111 ]
  %133 = phi ptr [ %124, %126 ], [ %114, %111 ]
  %134 = sub nsw i64 %112, %113
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !13
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !17
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fdiv double %2, %3
  %14 = fdiv double %13, %4
  %15 = fdiv double %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !33
  br label %74

18:                                               ; preds = %11
  %19 = zext nneg i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 2147483644
  %22 = insertelement <2 x double> poison, double %15, i64 0
  %23 = shufflevector <2 x double> %22, <2 x double> poison, <2 x i32> zeroinitializer
  %24 = icmp eq i64 %21, %19
  br label %25

25:                                               ; preds = %18, %49
  %26 = phi i32 [ %50, %49 ], [ %9, %18 ]
  %27 = phi i32 [ %51, %49 ], [ 0, %18 ]
  br i1 %20, label %42, label %28

28:                                               ; preds = %25, %28
  %29 = phi i64 [ %39, %28 ], [ 0, %25 ]
  %30 = phi double [ %38, %28 ], [ 0.000000e+00, %25 ]
  %31 = getelementptr inbounds nuw double, ptr %0, i64 %29
  %32 = getelementptr inbounds nuw i8, ptr %31, i64 16
  %33 = load <2 x double>, ptr %31, align 8, !tbaa !33
  %34 = load <2 x double>, ptr %32, align 8, !tbaa !33
  %35 = fadd <2 x double> %23, %33
  %36 = fadd <2 x double> %23, %34
  %37 = tail call double @llvm.vector.reduce.fadd.v2f64(double %30, <2 x double> %35)
  %38 = tail call double @llvm.vector.reduce.fadd.v2f64(double %37, <2 x double> %36)
  %39 = add nuw i64 %29, 4
  %40 = icmp eq i64 %39, %21
  br i1 %40, label %41, label %28, !llvm.loop !609

41:                                               ; preds = %28
  br i1 %24, label %62, label %42

42:                                               ; preds = %25, %41
  %43 = phi i64 [ 0, %25 ], [ %21, %41 ]
  %44 = phi double [ 0.000000e+00, %25 ], [ %38, %41 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !11
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %26, %62 ]
  %51 = add nuw nsw i32 %27, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %25, label %93, !llvm.loop !610

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi double [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds nuw double, ptr %0, i64 %54
  %57 = load double, ptr %56, align 8, !tbaa !33
  %58 = fadd double %15, %57
  %59 = fadd double %55, %58
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %19
  br i1 %61, label %62, label %53, !llvm.loop !611

62:                                               ; preds = %53, %41
  %63 = phi double [ %38, %41 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !33
  %65 = fadd double %15, %64
  %66 = fmul double %65, 8.000000e+03
  %67 = fsub double %63, %66
  %68 = tail call double @llvm.fabs.f64(double %63)
  %69 = fcmp ogt double %68, 1.000000e-08
  %70 = fdiv double %67, %63
  %71 = select i1 %69, double %70, double %67
  %72 = tail call double @llvm.fabs.f64(double %71)
  %73 = fcmp olt double %72, 0x3EB0C6F7A0B5ED8D
  br i1 %73, label %49, label %45

74:                                               ; preds = %16, %88
  %75 = phi i32 [ %89, %88 ], [ %9, %16 ]
  %76 = phi double [ %90, %88 ], [ %17, %16 ]
  %77 = phi i32 [ %91, %88 ], [ 0, %16 ]
  %78 = fadd double %15, %76
  %79 = fmul double %78, 8.000000e+03
  %80 = fsub double 0.000000e+00, %79
  %81 = tail call double @llvm.fabs.f64(double %80)
  %82 = fcmp olt double %81, 0x3EB0C6F7A0B5ED8D
  br i1 %82, label %88, label %83

83:                                               ; preds = %74
  %84 = load i32, ptr @current_test, align 4, !tbaa !11
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !33
  %87 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %88

88:                                               ; preds = %74, %83
  %89 = phi i32 [ %75, %74 ], [ %87, %83 ]
  %90 = phi double [ %76, %74 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %77, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %74, label %93, !llvm.loop !610

93:                                               ; preds = %88, %49, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !30
  %95 = load i64, ptr @start_time, align 8, !tbaa !30
  %96 = load ptr, ptr @results, align 8, !tbaa !6
  %97 = icmp ne ptr %96, null
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %99 = load i32, ptr @current_test, align 4
  %100 = icmp slt i32 %99, %98
  %101 = select i1 %97, i1 %100, i1 false
  br i1 %101, label %113, label %102

102:                                              ; preds = %93
  %103 = add nsw i32 %98, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !11
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %96, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !6
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %102
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %113

110:                                              ; preds = %102
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %93, %108
  %114 = phi i32 [ %109, %108 ], [ %99, %93 ]
  %115 = phi ptr [ %106, %108 ], [ %96, %93 ]
  %116 = sub nsw i64 %94, %95
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !13
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %6, ptr %121, align 8, !tbaa !17
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !30
  %9 = load i32, ptr @iterations, align 4, !tbaa !11
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %99

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul double %3, %4
  %14 = fdiv double %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !33
  br label %79

17:                                               ; preds = %11
  %18 = zext nneg i32 %1 to i64
  %19 = icmp ult i32 %1, 4
  %20 = and i64 %18, 2147483644
  %21 = insertelement <2 x double> poison, double %2, i64 0
  %22 = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x double> poison, double %14, i64 0
  %24 = shufflevector <2 x double> %23, <2 x double> poison, <2 x i32> zeroinitializer
  %25 = icmp eq i64 %20, %18
  br label %26

26:                                               ; preds = %17, %52
  %27 = phi i32 [ %53, %52 ], [ %9, %17 ]
  %28 = phi i32 [ %54, %52 ], [ 0, %17 ]
  br i1 %19, label %45, label %29

29:                                               ; preds = %26, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %26 ]
  %31 = phi double [ %41, %29 ], [ 0.000000e+00, %26 ]
  %32 = getelementptr inbounds nuw double, ptr %0, i64 %30
  %33 = getelementptr inbounds nuw i8, ptr %32, i64 16
  %34 = load <2 x double>, ptr %32, align 8, !tbaa !33
  %35 = load <2 x double>, ptr %33, align 8, !tbaa !33
  %36 = fadd <2 x double> %22, %34
  %37 = fadd <2 x double> %22, %35
  %38 = fsub <2 x double> %36, %24
  %39 = fsub <2 x double> %37, %24
  %40 = tail call double @llvm.vector.reduce.fadd.v2f64(double %31, <2 x double> %38)
  %41 = tail call double @llvm.vector.reduce.fadd.v2f64(double %40, <2 x double> %39)
  %42 = add nuw i64 %30, 4
  %43 = icmp eq i64 %42, %20
  br i1 %43, label %44, label %29, !llvm.loop !612

44:                                               ; preds = %29
  br i1 %25, label %66, label %45

45:                                               ; preds = %26, %44
  %46 = phi i64 [ 0, %26 ], [ %20, %44 ]
  %47 = phi double [ 0.000000e+00, %26 ], [ %41, %44 ]
  br label %56

48:                                               ; preds = %66
  %49 = load i32, ptr @current_test, align 4, !tbaa !11
  %50 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %49)
  %51 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %52

52:                                               ; preds = %48, %66
  %53 = phi i32 [ %51, %48 ], [ %27, %66 ]
  %54 = add nuw nsw i32 %28, 1
  %55 = icmp slt i32 %54, %53
  br i1 %55, label %26, label %99, !llvm.loop !613

56:                                               ; preds = %45, %56
  %57 = phi i64 [ %64, %56 ], [ %46, %45 ]
  %58 = phi double [ %63, %56 ], [ %47, %45 ]
  %59 = getelementptr inbounds nuw double, ptr %0, i64 %57
  %60 = load double, ptr %59, align 8, !tbaa !33
  %61 = fadd double %2, %60
  %62 = fsub double %61, %14
  %63 = fadd double %58, %62
  %64 = add nuw nsw i64 %57, 1
  %65 = icmp eq i64 %64, %18
  br i1 %65, label %66, label %56, !llvm.loop !614

66:                                               ; preds = %56, %44
  %67 = phi double [ %41, %44 ], [ %63, %56 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !33
  %69 = fadd double %2, %68
  %70 = fsub double %69, %14
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %67, %71
  %73 = tail call double @llvm.fabs.f64(double %67)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = fdiv double %72, %67
  %76 = select i1 %74, double %75, double %72
  %77 = tail call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %52, label %48

79:                                               ; preds = %15, %94
  %80 = phi i32 [ %95, %94 ], [ %9, %15 ]
  %81 = phi double [ %96, %94 ], [ %16, %15 ]
  %82 = phi i32 [ %97, %94 ], [ 0, %15 ]
  %83 = fadd double %2, %81
  %84 = fsub double %83, %14
  %85 = fmul double %84, 8.000000e+03
  %86 = fsub double 0.000000e+00, %85
  %87 = tail call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %94, label %89

89:                                               ; preds = %79
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %90)
  %92 = load double, ptr @init_value, align 8, !tbaa !33
  %93 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %94

94:                                               ; preds = %79, %89
  %95 = phi i32 [ %80, %79 ], [ %93, %89 ]
  %96 = phi double [ %81, %79 ], [ %92, %89 ]
  %97 = add nuw nsw i32 %82, 1
  %98 = icmp slt i32 %97, %95
  br i1 %98, label %79, label %99, !llvm.loop !613

99:                                               ; preds = %94, %52, %7
  %100 = tail call i64 @clock() #17
  store i64 %100, ptr @end_time, align 8, !tbaa !30
  %101 = load i64, ptr @start_time, align 8, !tbaa !30
  %102 = load ptr, ptr @results, align 8, !tbaa !6
  %103 = icmp ne ptr %102, null
  %104 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %105 = load i32, ptr @current_test, align 4
  %106 = icmp slt i32 %105, %104
  %107 = select i1 %103, i1 %106, i1 false
  br i1 %107, label %119, label %108

108:                                              ; preds = %99
  %109 = add nsw i32 %104, 10
  store i32 %109, ptr @allocated_results, align 4, !tbaa !11
  %110 = sext i32 %109 to i64
  %111 = shl nsw i64 %110, 4
  %112 = tail call ptr @realloc(ptr noundef %102, i64 noundef %111) #14
  store ptr %112, ptr @results, align 8, !tbaa !6
  %113 = icmp eq ptr %112, null
  br i1 %113, label %116, label %114

114:                                              ; preds = %108
  %115 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %119

116:                                              ; preds = %108
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %118 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %117)
  tail call void @exit(i32 noundef -1) #15
  unreachable

119:                                              ; preds = %99, %114
  %120 = phi i32 [ %115, %114 ], [ %105, %99 ]
  %121 = phi ptr [ %112, %114 ], [ %102, %99 ]
  %122 = sub nsw i64 %100, %101
  %123 = sitofp i64 %122 to double
  %124 = fdiv double %123, 1.000000e+06
  %125 = sext i32 %120 to i64
  %126 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125
  store double %124, ptr %126, align 8, !tbaa !13
  %127 = getelementptr inbounds %struct.one_result, ptr %121, i64 %125, i32 1
  store ptr %6, ptr %127, align 8, !tbaa !17
  %128 = add nsw i32 %120, 1
  store i32 %128, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: nounwind
declare i64 @__isoc23_strtol(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #7

; Function Attrs: mustprogress nocallback nofree nounwind willreturn
declare double @strtod(ptr noundef readonly, ptr noundef captures(none)) local_unnamed_addr #10

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #11

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #11

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #11

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #11

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #12

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr writeonly captures(none), i8, i64, i1 immarg) #13

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.add.v16i8(<16 x i8>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.add.v8i8(<8 x i8>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i16 @llvm.vector.reduce.add.v8i16(<8 x i16>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i16 @llvm.vector.reduce.add.v4i16(<4 x i16>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.vector.reduce.fadd.v4f32(float, <4 x float>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <4 x float> @llvm.fmuladd.v4f32(<4 x float>, <4 x float>, <4 x float>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.vector.reduce.fadd.v2f64(double, <2 x double>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x double> @llvm.fmuladd.v2f64(<2 x double>, <2 x double>, <2 x double>) #12

attributes #0 = { mustprogress nounwind uwtable "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #1 = { mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #2 = { nofree nounwind "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #3 = { nofree noreturn nounwind "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #4 = { mustprogress nofree nounwind uwtable "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #5 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: read) "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #6 = { mustprogress nocallback nofree nounwind willreturn memory(errnomem: write) "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #7 = { nounwind "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #8 = { mustprogress norecurse uwtable "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #9 = { mustprogress uwtable "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #10 = { mustprogress nocallback nofree nounwind willreturn "frame-pointer"="non-leaf" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "target-features"="+fp-armv8,+neon,+outline-atomics,+v8a,-fmv" }
attributes #11 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #12 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #13 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #14 = { nounwind allocsize(1) }
attributes #15 = { cold noreturn nounwind }
attributes #16 = { nounwind willreturn memory(read) }
attributes #17 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 1}
!5 = !{!"clang version 22.0.0git (https://github.com/steven-studio/llvm-project.git c2901ea177a93cdcea513ae5bdc6a189f274f4ca)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"p1 _ZTS10one_result", !8, i64 0}
!8 = !{!"any pointer", !9, i64 0}
!9 = !{!"omnipotent char", !10, i64 0}
!10 = !{!"Simple C++ TBAA"}
!11 = !{!12, !12, i64 0}
!12 = !{!"int", !9, i64 0}
!13 = !{!14, !15, i64 0}
!14 = !{!"_ZTS10one_result", !15, i64 0, !16, i64 8}
!15 = !{!"double", !9, i64 0}
!16 = !{!"p1 omnipotent char", !8, i64 0}
!17 = !{!14, !16, i64 8}
!18 = distinct !{!18, !19}
!19 = !{!"llvm.loop.mustprogress"}
!20 = distinct !{!20, !19, !21, !22}
!21 = !{!"llvm.loop.isvectorized", i32 1}
!22 = !{!"llvm.loop.unroll.runtime.disable"}
!23 = distinct !{!23, !19}
!24 = distinct !{!24, !19, !21}
!25 = distinct !{!25, !19}
!26 = distinct !{!26, !19}
!27 = distinct !{!27, !19, !21, !22}
!28 = distinct !{!28, !19}
!29 = distinct !{!29, !19, !21}
!30 = !{!31, !31, i64 0}
!31 = !{!"long", !9, i64 0}
!32 = !{!16, !16, i64 0}
!33 = !{!15, !15, i64 0}
!34 = !{!9, !9, i64 0}
!35 = !{!36, !36, i64 0}
!36 = !{!"short", !9, i64 0}
!37 = distinct !{!37, !19, !21, !22}
!38 = distinct !{!38, !19, !21, !22}
!39 = distinct !{!39, !19, !21, !22}
!40 = distinct !{!40, !19, !21, !22}
!41 = distinct !{!41, !19, !21, !22}
!42 = distinct !{!42, !19, !21, !22}
!43 = !{!44, !44, i64 0}
!44 = !{!"float", !9, i64 0}
!45 = distinct !{!45, !19, !21, !22}
!46 = distinct !{!46, !19, !21, !22}
!47 = distinct !{!47, !19, !21, !22}
!48 = distinct !{!48, !19, !21, !22}
!49 = distinct !{!49, !19}
!50 = distinct !{!50, !19, !22, !21}
!51 = distinct !{!51, !19, !21, !22}
!52 = distinct !{!52, !19, !21, !22}
!53 = distinct !{!53, !19}
!54 = distinct !{!54, !19, !22, !21}
!55 = distinct !{!55, !19, !21, !22}
!56 = distinct !{!56, !19, !21, !22}
!57 = distinct !{!57, !19}
!58 = distinct !{!58, !19, !22, !21}
!59 = distinct !{!59, !19, !21, !22}
!60 = distinct !{!60, !19, !21, !22}
!61 = distinct !{!61, !19}
!62 = distinct !{!62, !19, !22, !21}
!63 = distinct !{!63, !19, !21, !22}
!64 = distinct !{!64, !19, !21, !22}
!65 = distinct !{!65, !19}
!66 = distinct !{!66, !19, !22, !21}
!67 = distinct !{!67, !19, !21, !22}
!68 = distinct !{!68, !19, !21, !22}
!69 = distinct !{!69, !19}
!70 = distinct !{!70, !19, !22, !21}
!71 = distinct !{!71, !19, !21, !22}
!72 = distinct !{!72, !19, !21, !22}
!73 = distinct !{!73, !19}
!74 = distinct !{!74, !19, !22, !21}
!75 = distinct !{!75, !19, !21, !22}
!76 = distinct !{!76, !19, !21, !22}
!77 = distinct !{!77, !19}
!78 = distinct !{!78, !19, !22, !21}
!79 = distinct !{!79, !19, !21, !22}
!80 = distinct !{!80, !19}
!81 = distinct !{!81, !19, !21}
!82 = distinct !{!82, !19, !21, !22}
!83 = distinct !{!83, !19}
!84 = distinct !{!84, !19, !21}
!85 = distinct !{!85, !19, !21, !22}
!86 = distinct !{!86, !19, !21, !22}
!87 = distinct !{!87, !19}
!88 = distinct !{!88, !19, !22, !21}
!89 = distinct !{!89, !19, !21, !22}
!90 = distinct !{!90, !19, !21, !22}
!91 = distinct !{!91, !19}
!92 = distinct !{!92, !19, !22, !21}
!93 = distinct !{!93, !19, !21, !22}
!94 = distinct !{!94, !19, !21, !22}
!95 = distinct !{!95, !19}
!96 = distinct !{!96, !19, !22, !21}
!97 = distinct !{!97, !19, !21, !22}
!98 = distinct !{!98, !19, !21, !22}
!99 = distinct !{!99, !19}
!100 = distinct !{!100, !19, !22, !21}
!101 = distinct !{!101, !19, !21, !22}
!102 = distinct !{!102, !19, !21, !22}
!103 = distinct !{!103, !19}
!104 = distinct !{!104, !19, !22, !21}
!105 = distinct !{!105, !19, !21, !22}
!106 = distinct !{!106, !19, !21, !22}
!107 = distinct !{!107, !19}
!108 = distinct !{!108, !19, !22, !21}
!109 = distinct !{!109, !19, !21, !22}
!110 = distinct !{!110, !19, !21, !22}
!111 = distinct !{!111, !19}
!112 = distinct !{!112, !19, !22, !21}
!113 = distinct !{!113, !19, !21, !22}
!114 = distinct !{!114, !19, !21, !22}
!115 = distinct !{!115, !19}
!116 = distinct !{!116, !19, !22, !21}
!117 = distinct !{!117, !19, !21, !22}
!118 = distinct !{!118, !19, !21, !22}
!119 = distinct !{!119, !19}
!120 = distinct !{!120, !19, !22, !21}
!121 = distinct !{!121, !19, !21, !22}
!122 = distinct !{!122, !19, !21, !22}
!123 = distinct !{!123, !19}
!124 = distinct !{!124, !19, !22, !21}
!125 = distinct !{!125, !19, !21, !22}
!126 = distinct !{!126, !19, !21, !22}
!127 = distinct !{!127, !19}
!128 = distinct !{!128, !19, !22, !21}
!129 = distinct !{!129, !19, !21, !22}
!130 = distinct !{!130, !19, !21, !22}
!131 = distinct !{!131, !19}
!132 = distinct !{!132, !19, !22, !21}
!133 = distinct !{!133, !19, !21, !22}
!134 = distinct !{!134, !19, !21, !22}
!135 = distinct !{!135, !19}
!136 = distinct !{!136, !19, !22, !21}
!137 = distinct !{!137, !19, !21, !22}
!138 = distinct !{!138, !19, !21, !22}
!139 = distinct !{!139, !19}
!140 = distinct !{!140, !19, !22, !21}
!141 = distinct !{!141, !19, !21, !22}
!142 = distinct !{!142, !19, !21, !22}
!143 = distinct !{!143, !19}
!144 = distinct !{!144, !19, !22, !21}
!145 = distinct !{!145, !19, !21, !22}
!146 = distinct !{!146, !19, !21, !22}
!147 = distinct !{!147, !19}
!148 = distinct !{!148, !19, !22, !21}
!149 = distinct !{!149, !19, !21, !22}
!150 = distinct !{!150, !19}
!151 = distinct !{!151, !19, !21}
!152 = distinct !{!152, !19, !21, !22}
!153 = distinct !{!153, !19}
!154 = distinct !{!154, !19, !21}
!155 = distinct !{!155, !19, !21, !22}
!156 = distinct !{!156, !19, !21, !22}
!157 = distinct !{!157, !19}
!158 = distinct !{!158, !19, !22, !21}
!159 = distinct !{!159, !19, !21, !22}
!160 = distinct !{!160, !19, !21, !22}
!161 = distinct !{!161, !19}
!162 = distinct !{!162, !19, !22, !21}
!163 = distinct !{!163, !19, !21, !22}
!164 = distinct !{!164, !19, !21, !22}
!165 = distinct !{!165, !19}
!166 = distinct !{!166, !19, !22, !21}
!167 = distinct !{!167, !19, !21, !22}
!168 = distinct !{!168, !19, !21, !22}
!169 = distinct !{!169, !19}
!170 = distinct !{!170, !19, !22, !21}
!171 = distinct !{!171, !19, !21, !22}
!172 = distinct !{!172, !19, !21, !22}
!173 = distinct !{!173, !19}
!174 = distinct !{!174, !19, !22, !21}
!175 = distinct !{!175, !19, !21, !22}
!176 = distinct !{!176, !19, !21, !22}
!177 = distinct !{!177, !19}
!178 = distinct !{!178, !19, !22, !21}
!179 = distinct !{!179, !19, !21, !22}
!180 = distinct !{!180, !19, !21, !22}
!181 = distinct !{!181, !19}
!182 = distinct !{!182, !19, !22, !21}
!183 = distinct !{!183, !19, !21, !22}
!184 = distinct !{!184, !19, !21, !22}
!185 = distinct !{!185, !19}
!186 = distinct !{!186, !19, !22, !21}
!187 = distinct !{!187, !19, !21, !22}
!188 = distinct !{!188, !19, !21, !22}
!189 = distinct !{!189, !19}
!190 = distinct !{!190, !19, !22, !21}
!191 = distinct !{!191, !19, !21, !22}
!192 = distinct !{!192, !19, !21, !22}
!193 = distinct !{!193, !19}
!194 = distinct !{!194, !19, !22, !21}
!195 = distinct !{!195, !19, !21, !22}
!196 = distinct !{!196, !19, !21, !22}
!197 = distinct !{!197, !19}
!198 = distinct !{!198, !19, !22, !21}
!199 = distinct !{!199, !19, !21, !22}
!200 = distinct !{!200, !19, !21, !22}
!201 = distinct !{!201, !19}
!202 = distinct !{!202, !19, !22, !21}
!203 = distinct !{!203, !19, !21, !22}
!204 = distinct !{!204, !19, !21, !22}
!205 = distinct !{!205, !19}
!206 = distinct !{!206, !19, !22, !21}
!207 = distinct !{!207, !19, !21, !22}
!208 = distinct !{!208, !19, !21, !22}
!209 = distinct !{!209, !19}
!210 = distinct !{!210, !19, !22, !21}
!211 = distinct !{!211, !19, !21, !22}
!212 = distinct !{!212, !19, !21, !22}
!213 = distinct !{!213, !19}
!214 = distinct !{!214, !19, !22, !21}
!215 = distinct !{!215, !19, !21, !22}
!216 = distinct !{!216, !19, !21, !22}
!217 = distinct !{!217, !19}
!218 = distinct !{!218, !19, !22, !21}
!219 = distinct !{!219, !19, !21, !22}
!220 = distinct !{!220, !19}
!221 = distinct !{!221, !19, !21}
!222 = distinct !{!222, !19, !21, !22}
!223 = distinct !{!223, !19}
!224 = distinct !{!224, !19, !21}
!225 = distinct !{!225, !19, !21, !22}
!226 = distinct !{!226, !19, !21, !22}
!227 = distinct !{!227, !19}
!228 = distinct !{!228, !19, !22, !21}
!229 = distinct !{!229, !19, !21, !22}
!230 = distinct !{!230, !19, !21, !22}
!231 = distinct !{!231, !19}
!232 = distinct !{!232, !19, !22, !21}
!233 = distinct !{!233, !19, !21, !22}
!234 = distinct !{!234, !19, !21, !22}
!235 = distinct !{!235, !19}
!236 = distinct !{!236, !19, !22, !21}
!237 = distinct !{!237, !19, !21, !22}
!238 = distinct !{!238, !19, !21, !22}
!239 = distinct !{!239, !19}
!240 = distinct !{!240, !19, !22, !21}
!241 = distinct !{!241, !19, !21, !22}
!242 = distinct !{!242, !19, !21, !22}
!243 = distinct !{!243, !19}
!244 = distinct !{!244, !19, !22, !21}
!245 = distinct !{!245, !19, !21, !22}
!246 = distinct !{!246, !19, !21, !22}
!247 = distinct !{!247, !19}
!248 = distinct !{!248, !19, !22, !21}
!249 = distinct !{!249, !19, !21, !22}
!250 = distinct !{!250, !19, !21, !22}
!251 = distinct !{!251, !19}
!252 = distinct !{!252, !19, !22, !21}
!253 = distinct !{!253, !19, !21, !22}
!254 = distinct !{!254, !19, !21, !22}
!255 = distinct !{!255, !19}
!256 = distinct !{!256, !19, !22, !21}
!257 = distinct !{!257, !19, !21, !22}
!258 = distinct !{!258, !19, !21, !22}
!259 = distinct !{!259, !19}
!260 = distinct !{!260, !19, !22, !21}
!261 = distinct !{!261, !19, !21, !22}
!262 = distinct !{!262, !19, !21, !22}
!263 = distinct !{!263, !19}
!264 = distinct !{!264, !19, !22, !21}
!265 = distinct !{!265, !19, !21, !22}
!266 = distinct !{!266, !19, !21, !22}
!267 = distinct !{!267, !19}
!268 = distinct !{!268, !19, !22, !21}
!269 = distinct !{!269, !19, !21, !22}
!270 = distinct !{!270, !19, !21, !22}
!271 = distinct !{!271, !19}
!272 = distinct !{!272, !19, !22, !21}
!273 = distinct !{!273, !19, !21, !22}
!274 = distinct !{!274, !19, !21, !22}
!275 = distinct !{!275, !19}
!276 = distinct !{!276, !19, !22, !21}
!277 = distinct !{!277, !19, !21, !22}
!278 = distinct !{!278, !19, !21, !22}
!279 = distinct !{!279, !19}
!280 = distinct !{!280, !19, !22, !21}
!281 = distinct !{!281, !19, !21, !22}
!282 = distinct !{!282, !19, !21, !22}
!283 = distinct !{!283, !19}
!284 = distinct !{!284, !19, !22, !21}
!285 = distinct !{!285, !19, !21, !22}
!286 = distinct !{!286, !19, !21, !22}
!287 = distinct !{!287, !19}
!288 = distinct !{!288, !19, !22, !21}
!289 = distinct !{!289, !19, !21, !22}
!290 = distinct !{!290, !19}
!291 = distinct !{!291, !19, !21}
!292 = distinct !{!292, !19, !21, !22}
!293 = distinct !{!293, !19}
!294 = distinct !{!294, !19, !21}
!295 = distinct !{!295, !19, !21, !22}
!296 = distinct !{!296, !19, !21, !22}
!297 = distinct !{!297, !19}
!298 = distinct !{!298, !19, !22, !21}
!299 = distinct !{!299, !19, !21, !22}
!300 = distinct !{!300, !19, !21, !22}
!301 = distinct !{!301, !19}
!302 = distinct !{!302, !19, !22, !21}
!303 = distinct !{!303, !19, !21, !22}
!304 = distinct !{!304, !19, !21, !22}
!305 = distinct !{!305, !19}
!306 = distinct !{!306, !19, !22, !21}
!307 = distinct !{!307, !19, !21, !22}
!308 = distinct !{!308, !19, !21, !22}
!309 = distinct !{!309, !19}
!310 = distinct !{!310, !19, !22, !21}
!311 = distinct !{!311, !19, !21, !22}
!312 = distinct !{!312, !19, !21, !22}
!313 = distinct !{!313, !19}
!314 = distinct !{!314, !19, !22, !21}
!315 = distinct !{!315, !19, !21, !22}
!316 = distinct !{!316, !19, !21, !22}
!317 = distinct !{!317, !19}
!318 = distinct !{!318, !19, !22, !21}
!319 = distinct !{!319, !19, !21, !22}
!320 = distinct !{!320, !19, !21, !22}
!321 = distinct !{!321, !19}
!322 = distinct !{!322, !19, !22, !21}
!323 = distinct !{!323, !19, !21, !22}
!324 = distinct !{!324, !19, !21, !22}
!325 = distinct !{!325, !19}
!326 = distinct !{!326, !19, !22, !21}
!327 = distinct !{!327, !19, !21, !22}
!328 = distinct !{!328, !19}
!329 = distinct !{!329, !19, !22, !21}
!330 = distinct !{!330, !19, !21, !22}
!331 = distinct !{!331, !19}
!332 = distinct !{!332, !19, !22, !21}
!333 = distinct !{!333, !19, !21, !22}
!334 = distinct !{!334, !19}
!335 = distinct !{!335, !19, !22, !21}
!336 = distinct !{!336, !19, !21, !22}
!337 = distinct !{!337, !19}
!338 = distinct !{!338, !19, !22, !21}
!339 = distinct !{!339, !19, !21, !22}
!340 = distinct !{!340, !19}
!341 = distinct !{!341, !19, !22, !21}
!342 = distinct !{!342, !19, !21, !22}
!343 = distinct !{!343, !19}
!344 = distinct !{!344, !19, !22, !21}
!345 = distinct !{!345, !19, !21, !22}
!346 = distinct !{!346, !19}
!347 = distinct !{!347, !19, !22, !21}
!348 = distinct !{!348, !19, !21, !22}
!349 = distinct !{!349, !19}
!350 = distinct !{!350, !19, !22, !21}
!351 = distinct !{!351, !19, !21, !22}
!352 = distinct !{!352, !19}
!353 = distinct !{!353, !19, !21}
!354 = distinct !{!354, !19, !21, !22}
!355 = distinct !{!355, !19}
!356 = distinct !{!356, !19, !21}
!357 = distinct !{!357, !19, !21, !22}
!358 = distinct !{!358, !19}
!359 = distinct !{!359, !19, !22, !21}
!360 = distinct !{!360, !19, !21, !22}
!361 = distinct !{!361, !19}
!362 = distinct !{!362, !19, !22, !21}
!363 = distinct !{!363, !19, !21, !22}
!364 = distinct !{!364, !19}
!365 = distinct !{!365, !19, !22, !21}
!366 = distinct !{!366, !19, !21, !22}
!367 = distinct !{!367, !19}
!368 = distinct !{!368, !19, !22, !21}
!369 = distinct !{!369, !19, !21, !22}
!370 = distinct !{!370, !19}
!371 = distinct !{!371, !19, !22, !21}
!372 = distinct !{!372, !19, !21, !22}
!373 = distinct !{!373, !19}
!374 = distinct !{!374, !19, !22, !21}
!375 = distinct !{!375, !19, !21, !22}
!376 = distinct !{!376, !19}
!377 = distinct !{!377, !19, !22, !21}
!378 = distinct !{!378, !19, !21, !22}
!379 = distinct !{!379, !19}
!380 = distinct !{!380, !19, !22, !21}
!381 = distinct !{!381, !19, !21, !22}
!382 = distinct !{!382, !19}
!383 = distinct !{!383, !19, !22, !21}
!384 = distinct !{!384, !19, !21, !22}
!385 = distinct !{!385, !19}
!386 = distinct !{!386, !19, !22, !21}
!387 = distinct !{!387, !19, !21, !22}
!388 = distinct !{!388, !19}
!389 = distinct !{!389, !19, !22, !21}
!390 = distinct !{!390, !19, !21, !22}
!391 = distinct !{!391, !19}
!392 = distinct !{!392, !19, !22, !21}
!393 = distinct !{!393, !19, !21, !22}
!394 = distinct !{!394, !19}
!395 = distinct !{!395, !19, !22, !21}
!396 = distinct !{!396, !19, !21, !22}
!397 = distinct !{!397, !19}
!398 = distinct !{!398, !19, !22, !21}
!399 = distinct !{!399, !19, !21, !22}
!400 = distinct !{!400, !19}
!401 = distinct !{!401, !19, !22, !21}
!402 = distinct !{!402, !19, !21, !22}
!403 = distinct !{!403, !19}
!404 = distinct !{!404, !19, !22, !21}
!405 = distinct !{!405, !19, !21, !22}
!406 = distinct !{!406, !19}
!407 = distinct !{!407, !19, !21}
!408 = distinct !{!408, !19, !21, !22}
!409 = distinct !{!409, !19}
!410 = distinct !{!410, !19, !21}
!411 = distinct !{!411, !19, !21, !22}
!412 = distinct !{!412, !19}
!413 = distinct !{!413, !19, !22, !21}
!414 = distinct !{!414, !19, !21, !22}
!415 = distinct !{!415, !19}
!416 = distinct !{!416, !19, !22, !21}
!417 = distinct !{!417, !19, !21, !22}
!418 = distinct !{!418, !19}
!419 = distinct !{!419, !19, !22, !21}
!420 = distinct !{!420, !19, !21, !22}
!421 = distinct !{!421, !19}
!422 = distinct !{!422, !19, !22, !21}
!423 = distinct !{!423, !19, !21, !22}
!424 = distinct !{!424, !19}
!425 = distinct !{!425, !19, !22, !21}
!426 = distinct !{!426, !19, !21, !22}
!427 = distinct !{!427, !19}
!428 = distinct !{!428, !19, !22, !21}
!429 = distinct !{!429, !19, !21, !22}
!430 = distinct !{!430, !19}
!431 = distinct !{!431, !19, !22, !21}
!432 = distinct !{!432, !19, !21, !22}
!433 = distinct !{!433, !19}
!434 = distinct !{!434, !19, !22, !21}
!435 = distinct !{!435, !19, !21, !22}
!436 = distinct !{!436, !19}
!437 = distinct !{!437, !19, !22, !21}
!438 = distinct !{!438, !19, !21, !22}
!439 = distinct !{!439, !19}
!440 = distinct !{!440, !19, !22, !21}
!441 = distinct !{!441, !19, !21, !22}
!442 = distinct !{!442, !19}
!443 = distinct !{!443, !19, !22, !21}
!444 = distinct !{!444, !19, !21, !22}
!445 = distinct !{!445, !19}
!446 = distinct !{!446, !19, !22, !21}
!447 = distinct !{!447, !19, !21, !22}
!448 = distinct !{!448, !19}
!449 = distinct !{!449, !19, !22, !21}
!450 = distinct !{!450, !19, !21, !22}
!451 = distinct !{!451, !19}
!452 = distinct !{!452, !19, !21}
!453 = distinct !{!453, !19, !21, !22}
!454 = distinct !{!454, !19}
!455 = distinct !{!455, !19, !21}
!456 = distinct !{!456, !19, !21, !22}
!457 = distinct !{!457, !19}
!458 = distinct !{!458, !19, !22, !21}
!459 = distinct !{!459, !19, !21, !22}
!460 = distinct !{!460, !19}
!461 = distinct !{!461, !19, !21}
!462 = distinct !{!462, !19, !21, !22}
!463 = distinct !{!463, !19}
!464 = distinct !{!464, !19, !21}
!465 = distinct !{!465, !19, !21, !22}
!466 = distinct !{!466, !19}
!467 = distinct !{!467, !19, !22, !21}
!468 = distinct !{!468, !19, !21, !22}
!469 = distinct !{!469, !19}
!470 = distinct !{!470, !19, !22, !21}
!471 = distinct !{!471, !19, !21, !22}
!472 = distinct !{!472, !19}
!473 = distinct !{!473, !19, !22, !21}
!474 = distinct !{!474, !19, !21, !22}
!475 = distinct !{!475, !19}
!476 = distinct !{!476, !19, !22, !21}
!477 = distinct !{!477, !19, !21, !22}
!478 = distinct !{!478, !19}
!479 = distinct !{!479, !19, !22, !21}
!480 = distinct !{!480, !19, !21, !22}
!481 = distinct !{!481, !19}
!482 = distinct !{!482, !19, !22, !21}
!483 = distinct !{!483, !19, !21, !22}
!484 = distinct !{!484, !19}
!485 = distinct !{!485, !19, !22, !21}
!486 = distinct !{!486, !19, !21, !22}
!487 = distinct !{!487, !19}
!488 = distinct !{!488, !19, !22, !21}
!489 = distinct !{!489, !19, !21, !22}
!490 = distinct !{!490, !19}
!491 = distinct !{!491, !19, !22, !21}
!492 = distinct !{!492, !19, !21, !22}
!493 = distinct !{!493, !19}
!494 = distinct !{!494, !19, !22, !21}
!495 = distinct !{!495, !19, !21, !22}
!496 = distinct !{!496, !19}
!497 = distinct !{!497, !19, !22, !21}
!498 = distinct !{!498, !19, !21, !22}
!499 = distinct !{!499, !19}
!500 = distinct !{!500, !19, !22, !21}
!501 = distinct !{!501, !19, !21, !22}
!502 = distinct !{!502, !19}
!503 = distinct !{!503, !19, !22, !21}
!504 = distinct !{!504, !19, !21, !22}
!505 = distinct !{!505, !19}
!506 = distinct !{!506, !19, !21}
!507 = distinct !{!507, !19, !21, !22}
!508 = distinct !{!508, !19}
!509 = distinct !{!509, !19, !21}
!510 = distinct !{!510, !19, !21, !22}
!511 = distinct !{!511, !19}
!512 = distinct !{!512, !19, !22, !21}
!513 = distinct !{!513, !19, !21, !22}
!514 = distinct !{!514, !19}
!515 = distinct !{!515, !19, !21}
!516 = distinct !{!516, !19, !21, !22}
!517 = distinct !{!517, !19}
!518 = distinct !{!518, !19, !21}
!519 = distinct !{!519, !19, !21, !22}
!520 = distinct !{!520, !19}
!521 = distinct !{!521, !19, !22, !21}
!522 = distinct !{!522, !19, !21, !22}
!523 = distinct !{!523, !19}
!524 = distinct !{!524, !19, !22, !21}
!525 = distinct !{!525, !19, !21, !22}
!526 = distinct !{!526, !19}
!527 = distinct !{!527, !19, !22, !21}
!528 = distinct !{!528, !19, !21, !22}
!529 = distinct !{!529, !19}
!530 = distinct !{!530, !19, !22, !21}
!531 = distinct !{!531, !19, !21, !22}
!532 = distinct !{!532, !19}
!533 = distinct !{!533, !19, !22, !21}
!534 = distinct !{!534, !19, !21, !22}
!535 = distinct !{!535, !19}
!536 = distinct !{!536, !19, !22, !21}
!537 = distinct !{!537, !19, !21, !22}
!538 = distinct !{!538, !19}
!539 = distinct !{!539, !19, !22, !21}
!540 = distinct !{!540, !19, !21, !22}
!541 = distinct !{!541, !19}
!542 = distinct !{!542, !19, !22, !21}
!543 = distinct !{!543, !19, !21, !22}
!544 = distinct !{!544, !19}
!545 = distinct !{!545, !19, !22, !21}
!546 = distinct !{!546, !19, !21, !22}
!547 = distinct !{!547, !19}
!548 = distinct !{!548, !19, !22, !21}
!549 = distinct !{!549, !19, !21, !22}
!550 = distinct !{!550, !19}
!551 = distinct !{!551, !19, !22, !21}
!552 = distinct !{!552, !19, !21, !22}
!553 = distinct !{!553, !19}
!554 = distinct !{!554, !19, !22, !21}
!555 = distinct !{!555, !19, !21, !22}
!556 = distinct !{!556, !19}
!557 = distinct !{!557, !19, !22, !21}
!558 = distinct !{!558, !19, !21, !22}
!559 = distinct !{!559, !19}
!560 = distinct !{!560, !19, !22, !21}
!561 = distinct !{!561, !19, !21, !22}
!562 = distinct !{!562, !19}
!563 = distinct !{!563, !19, !22, !21}
!564 = distinct !{!564, !19, !21, !22}
!565 = distinct !{!565, !19}
!566 = distinct !{!566, !19, !22, !21}
!567 = distinct !{!567, !19, !21, !22}
!568 = distinct !{!568, !19}
!569 = distinct !{!569, !19, !22, !21}
!570 = distinct !{!570, !19, !21, !22}
!571 = distinct !{!571, !19}
!572 = distinct !{!572, !19, !22, !21}
!573 = distinct !{!573, !19, !21, !22}
!574 = distinct !{!574, !19}
!575 = distinct !{!575, !19, !22, !21}
!576 = distinct !{!576, !19, !21, !22}
!577 = distinct !{!577, !19}
!578 = distinct !{!578, !19, !22, !21}
!579 = distinct !{!579, !19, !21, !22}
!580 = distinct !{!580, !19}
!581 = distinct !{!581, !19, !22, !21}
!582 = distinct !{!582, !19, !21, !22}
!583 = distinct !{!583, !19}
!584 = distinct !{!584, !19, !22, !21}
!585 = distinct !{!585, !19, !21, !22}
!586 = distinct !{!586, !19}
!587 = distinct !{!587, !19, !22, !21}
!588 = distinct !{!588, !19, !21, !22}
!589 = distinct !{!589, !19}
!590 = distinct !{!590, !19, !22, !21}
!591 = distinct !{!591, !19, !21, !22}
!592 = distinct !{!592, !19}
!593 = distinct !{!593, !19, !22, !21}
!594 = distinct !{!594, !19, !21, !22}
!595 = distinct !{!595, !19}
!596 = distinct !{!596, !19, !22, !21}
!597 = distinct !{!597, !19, !21, !22}
!598 = distinct !{!598, !19}
!599 = distinct !{!599, !19, !22, !21}
!600 = distinct !{!600, !19, !21, !22}
!601 = distinct !{!601, !19}
!602 = distinct !{!602, !19, !22, !21}
!603 = distinct !{!603, !19, !21, !22}
!604 = distinct !{!604, !19}
!605 = distinct !{!605, !19, !22, !21}
!606 = distinct !{!606, !19, !21, !22}
!607 = distinct !{!607, !19}
!608 = distinct !{!608, !19, !22, !21}
!609 = distinct !{!609, !19, !21, !22}
!610 = distinct !{!610, !19}
!611 = distinct !{!611, !19, !22, !21}
!612 = distinct !{!612, !19, !21, !22}
!613 = distinct !{!613, !19}
!614 = distinct !{!614, !19, !22, !21}
