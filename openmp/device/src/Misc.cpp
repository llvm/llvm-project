//===--------- Misc.cpp - OpenMP device misc interfaces ----------- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//
//===----------------------------------------------------------------------===//

#include "Allocator.h"
#include "Configuration.h"
#include "DeviceTypes.h"
#include "Shared/RPCOpcodes.h"
#include "shared/rpc.h"

#include "Debug.h"

namespace ompx {
namespace impl {

/// Lookup a device-side function using a host pointer /p HstPtr using the table
/// provided by the device plugin. The table is an ordered pair of host and
/// device pointers sorted on the value of the host pointer.
static void *indirectCallLookup(void *HstPtr) {
  if (!HstPtr)
    return nullptr;

  struct IndirectCallTable {
    void *HstPtr;
    void *DevPtr;
  };
  IndirectCallTable *Table =
      reinterpret_cast<IndirectCallTable *>(config::getIndirectCallTablePtr());
  uint64_t TableSize = config::getIndirectCallTableSize();

  // If the table is empty we assume this is device pointer.
  if (!Table || !TableSize)
    return HstPtr;

  uint32_t Left = 0;
  uint32_t Right = TableSize;

  // If the pointer is definitely not contained in the table we exit early.
  if (HstPtr < Table[Left].HstPtr || HstPtr > Table[Right - 1].HstPtr)
    return HstPtr;

  while (Left != Right) {
    uint32_t Current = Left + (Right - Left) / 2;
    if (Table[Current].HstPtr == HstPtr)
      return Table[Current].DevPtr;

    if (HstPtr < Table[Current].HstPtr)
      Right = Current;
    else
      Left = Current;
  }

  // If we searched the whole table and found nothing this is a device pointer.
  return HstPtr;
}

/// The openmp client instance used to communicate with the server.
[[gnu::visibility("protected"),
  gnu::weak]] rpc::Client Client asm("__llvm_rpc_client");

} // namespace impl
} // namespace ompx

/// Interfaces
///
///{

extern "C" {
int32_t __kmpc_cancellationpoint(IdentTy *, int32_t, int32_t) { return 0; }

int32_t __kmpc_cancel(IdentTy *, int32_t, int32_t) { return 0; }

double omp_get_wtick(void) {
  // The number of ticks per second for the AMDGPU clock varies by card and can
  // only be retrieved by querying the driver. We rely on the device environment
  // to inform us what the proper frequency is. NVPTX uses a nanosecond
  // resolution, we could omit the global read but this makes it consistent.
  return 1.0 / ompx::config::getClockFrequency();
}

double omp_get_wtime(void) {
  return static_cast<double>(__builtin_readsteadycounter()) * omp_get_wtick();
}

void *__llvm_omp_indirect_call_lookup(void *HstPtr) {
  return ompx::impl::indirectCallLookup(HstPtr);
}

void *omp_alloc(size_t size, omp_allocator_handle_t allocator) {
  switch (allocator) {
  case omp_default_mem_alloc:
  case omp_large_cap_mem_alloc:
  case omp_const_mem_alloc:
  case omp_high_bw_mem_alloc:
  case omp_low_lat_mem_alloc:
    return ompx::allocator::alloc(size);
  default:
    return nullptr;
  }
}

void omp_free(void *ptr, omp_allocator_handle_t allocator) {
  switch (allocator) {
  case omp_default_mem_alloc:
  case omp_large_cap_mem_alloc:
  case omp_const_mem_alloc:
  case omp_high_bw_mem_alloc:
  case omp_low_lat_mem_alloc:
    ompx::allocator::free(ptr);
    return;
  case omp_null_allocator:
  default:
    return;
  }
}

unsigned long long __llvm_omp_host_call(void *fn, void *data, size_t size) {
  rpc::Client::Port Port = ompx::impl::Client.open<OFFLOAD_HOST_CALL>();
  Port.send_n(data, size);
  Port.send([=](rpc::Buffer *buffer, uint32_t) {
    buffer->data[0] = reinterpret_cast<uintptr_t>(fn);
  });
  unsigned long long Ret;
  Port.recv([&](rpc::Buffer *Buffer, uint32_t) {
    Ret = static_cast<unsigned long long>(Buffer->data[0]);
  });
  Port.close();
  return Ret;
}

// Calls to __llvm_omp_emissary_rpc and __llvm_omp_emissary_premalloc are
// generated by device codegen at _emissary_exec call sites.
// See clang/lib/CodeGen/CGEmitEmissaryExec.cpp
void *__llvm_emissary_premalloc(uint32_t sz) {
  return omp_alloc((size_t)sz, omp_default_mem_alloc);
}

unsigned long long __llvm_emissary_rpc(uint32_t sz32, void *bufdata) {
  rpc::Client::Port Port = ompx::impl::Client.open<OFFLOAD_EMISSARY>();
  Port.send_n(bufdata, (size_t)sz32);
  unsigned long long Ret;
  Port.recv([&](rpc::Buffer *Buffer, uint32_t) {
    Ret = static_cast<unsigned long long>(Buffer->data[0]);
  });
  omp_free(bufdata, omp_default_mem_alloc);
  Port.close();
  return Ret;
}

// This is for emissary APIs that require d2h or h2d memory transfers.
unsigned long long __llvm_emissary_rpc_dm(uint32_t sz32, void *bufdata) {
  rpc::Client::Port Port = ompx::impl::Client.open<OFFLOAD_EMISSARY_DM>();
  Port.send_n(bufdata, (size_t)sz32);

  char *data = (char *)bufdata;
  uint32_t *int32_data = (uint32_t *)data;
  uint32_t NumArgs = int32_data[1];
  char *keyptr = data + (2 * sizeof(int));
  char *argptr = keyptr + (NumArgs * sizeof(int));
  if (((size_t)argptr) % (size_t)8)
    argptr += 4; // argptr must be aligned
  uint64_t arg1 = *(uint64_t *)argptr;
  uint32_t NumSendXfers = (unsigned int)((arg1 >> 16) & 0xFFFF);
  uint32_t NumRecvXfers = (unsigned int)((arg1) & 0xFFFF);
  // Skip by arg1 and process Send and Recv Xfers if any
  argptr += sizeof(uint64_t);
  for (uint32_t idx = 0; idx < NumSendXfers; idx++) {
    void *D2Hdata = (void *)*((uint64_t *)argptr);
    argptr += sizeof(void *);
    size_t D2Hsize = (size_t)*((size_t *)argptr);
    argptr += sizeof(size_t);
    Port.send_n(D2Hdata, D2Hsize);
  }
  for (uint32_t idx = 0; idx < NumRecvXfers; idx++) {
    void *H2Ddata = (void *)*((uint64_t *)argptr);
    argptr += sizeof(void *);
    argptr += sizeof(size_t);
    uint64_t recv_size;
    void *buf = nullptr;
    Port.recv_n(&buf, &recv_size,
                [&](uint64_t) { return reinterpret_cast<void *>(H2Ddata); });
  }

  unsigned long long Ret;
  Port.recv([&](rpc::Buffer *Buffer, uint32_t) {
    Ret = static_cast<unsigned long long>(Buffer->data[0]);
  });
  omp_free(bufdata, omp_default_mem_alloc);
  Port.close();
  return Ret;
}
}

// C++ ABI helpers.
extern "C" {
[[gnu::weak]] void __cxa_pure_virtual(void) { __builtin_trap(); }
[[gnu::weak]] void __cxa_deleted_virtual(void) { __builtin_trap(); }
}

///}
