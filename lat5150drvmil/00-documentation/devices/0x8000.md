# Device 0x8000: TPMControlDevice

## Device Information

| Property | Value |
|----------|-------|
| **Device ID** | `0x8000` (32768) |
| **Name** | TPMControlDevice |
| **Group** | Group 0: Core Security (0x8000-0x800B) |
| **Risk Level** | üü° MONITORED (85% safe for READ) |
| **Total Operations** | 41 |
| **Total Registers** | 8 |
| **Implementation File** | `device_0x8000_tpm_control.py` |

## Description

TPM Control Device (0x8000)

## Operations (41)

### Core Operations

#### `initialize()`

Initialize TPM device

**Returns:** `OperationResult`

#### `get_capabilities()`

Get device capabilities

#### `get_status()`

Get current device status

### Advanced Operations

#### `read_register(register)`

Read a device register

#### `get_supported_algorithms()`

Get list of supported TPM algorithms

#### `generate_key(algorithm, key_size)`

Generate a new TPM key

Args:
    algorithm: Algorithm identifier (TPM2Algorithm)
    key_size: Key size in bits

Returns:
    OperationResult with key handle

#### `read_pcr(pcr_index)`

Read Platform Configuration Register

Args:
    pcr_index: PCR index (0-23)

Returns:
    OperationResult with PCR value

#### `extend_pcr(pcr_index, data)`

Extend Platform Configuration Register

Args:
    pcr_index: PCR index (0-23)
    data: Data to extend

Returns:
    OperationResult with success status

#### `seal_data(data, pcr_list)`

Seal data to PCR values

Args:
    data: Data to seal
    pcr_list: List of PCR indices to seal to

Returns:
    OperationResult with sealed blob

#### `unseal_data(sealed_blob)`

Unseal data (requires matching PCR values)

Args:
    sealed_blob: Sealed data blob

Returns:
    OperationResult with unsealed data

#### `get_random(num_bytes)`

Get hardware random bytes from TPM

Args:
    num_bytes: Number of random bytes to generate

Returns:
    OperationResult with random bytes

#### `create_primary(hierarchy, algorithm)`

Create a primary key in TPM hierarchy
Equivalent to: tpm2_createprimary

Args:
    hierarchy: Key hierarchy ("owner", "endorsement", "platform", "null")
    algorithm: Key algorithm (e.g., "rsa2048", "ecc256", "aes128")

Returns:
    OperationResult with key handle

#### `create_key(parent_handle, algorithm, attributes)`

Create a child key under a parent
Equivalent to: tpm2_create

Args:
    parent_handle: Parent key handle
    algorithm: Key algorithm
    attributes: Key attributes (e.g., ["sign", "decrypt", "fixedtpm"])

Returns:
    OperationResult with key data

#### `load_key(parent_handle, private_blob, public_blob)`

Load a key into TPM
Equivalent to: tpm2_load

Args:
    parent_handle: Parent key handle
    private_blob: Private key blob
    public_blob: Public key blob

Returns:
    OperationResult with loaded key handle

#### `flush_context(handle)`

Flush a loaded key from TPM memory
Equivalent to: tpm2_flushcontext

Args:
    handle: Key handle to flush

Returns:
    OperationResult with flush status

#### `evict_control(handle, persistent_handle)`

Make a key persistent or evict a persistent key
Equivalent to: tpm2_evictcontrol

Args:
    handle: Transient handle
    persistent_handle: Persistent handle (e.g., "0x81000001")

Returns:
    OperationResult with persist status

#### `sign(key_handle, data, scheme)`

Sign data with TPM key
Equivalent to: tpm2_sign

Args:
    key_handle: Signing key handle
    data: Data to sign
    scheme: Signature scheme ("rsassa", "rsapss", "ecdsa", "ecdaa")

Returns:
    OperationResult with signature

#### `verify_signature(key_handle, data, signature, scheme)`

Verify signature with TPM key
Equivalent to: tpm2_verifysignature

Args:
    key_handle: Verification key handle
    data: Original data
    signature: Signature to verify
    scheme: Signature scheme

Returns:
    OperationResult with verification status

#### `hash(data, algorithm)`

Perform TPM-based hash operation
Equivalent to: tpm2_hash

Args:
    data: Data to hash
    algorithm: Hash algorithm ("sha1", "sha256", "sha384", "sha512")

Returns:
    OperationResult with hash

#### `hmac(key_handle, data, algorithm)`

Perform TPM-based HMAC operation
Equivalent to: tpm2_hmac

Args:
    key_handle: HMAC key handle
    data: Data to HMAC
    algorithm: Hash algorithm

Returns:
    OperationResult with HMAC

#### `quote(key_handle, pcr_list, nonce)`

Generate TPM quote (attestation)
Equivalent to: tpm2_quote

Args:
    key_handle: Attestation key handle
    pcr_list: List of PCRs to quote
    nonce: Optional nonce for freshness

Returns:
    OperationResult with quote data

#### `activate_credential(key_handle, credential_blob)`

Activate a credential
Equivalent to: tpm2_activatecredential

Args:
    key_handle: Activation key handle
    credential_blob: Encrypted credential

Returns:
    OperationResult with activated credential

#### `certify(object_handle, signing_key_handle)`

Certify a TPM object
Equivalent to: tpm2_certify

Args:
    object_handle: Object to certify
    signing_key_handle: Key to sign certification

Returns:
    OperationResult with certification

#### `nv_define(nv_index, size, attributes)`

Define an NV (Non-Volatile) index
Equivalent to: tpm2_nvdefine

Args:
    nv_index: NV index (e.g., "0x1500001")
    size: Size in bytes
    attributes: NV attributes (e.g., ["ownerwrite", "ownerread"])

Returns:
    OperationResult with NV index info

#### `nv_write(nv_index, data, offset)`

Write to NV index
Equivalent to: tpm2_nvwrite

Args:
    nv_index: NV index
    data: Data to write
    offset: Write offset

Returns:
    OperationResult with write status

#### `nv_read(nv_index, size, offset)`

Read from NV index
Equivalent to: tpm2_nvread

Args:
    nv_index: NV index
    size: Bytes to read
    offset: Read offset

Returns:
    OperationResult with data

#### `get_capability(capability)`

Get TPM capability information
Equivalent to: tpm2_getcap

Args:
    capability: Capability type ("algorithms", "commands", "properties", "pcrs")

Returns:
    OperationResult with capability info

#### `clear_tpm(hierarchy)`

Clear TPM (DANGEROUS - erases all data)
Equivalent to: tpm2_clear

Args:
    hierarchy: Authorization hierarchy ("platform", "lockout")

Returns:
    OperationResult with clear status

#### `reset_pcr(pcr_index)`

Reset a PCR to its default value
Equivalent to: tpm2_pcrreset

Args:
    pcr_index: PCR index to reset (16-23 are resettable)

Returns:
    OperationResult with reset status

#### `ml_kem_keypair(algorithm)`

Generate ML-KEM (Key Encapsulation Mechanism) keypair
FIPS 203 - Post-Quantum Key Encapsulation

Args:
    algorithm: ML-KEM algorithm (ML_KEM_512, ML_KEM_768, ML_KEM_1024)
              Default: ML_KEM_1024 (MIL-SPEC required)

Returns:
    OperationResult with public_key, secret_key, and algorithm info

#### `ml_kem_encapsulate(public_key, algorithm)`

Encapsulate a shared secret using ML-KEM public key
FIPS 203 - Key Encapsulation

Args:
    public_key: Recipient's ML-KEM public key (hex string)
    algorithm: ML-KEM algorithm used

Returns:
    OperationResult with ciphertext and shared_secret

#### `ml_kem_decapsulate(secret_key, ciphertext, algorithm)`

Decapsulate shared secret using ML-KEM secret key
FIPS 203 - Key Decapsulation

Args:
    secret_key: Recipient's ML-KEM secret key (hex string)
    ciphertext: Encapsulated ciphertext (hex string)
    algorithm: ML-KEM algorithm used

Returns:
    OperationResult with shared_secret

#### `ml_dsa_keypair(algorithm)`

Generate ML-DSA (Digital Signature Algorithm) keypair
FIPS 204 - Post-Quantum Digital Signatures

Args:
    algorithm: ML-DSA algorithm (ML_DSA_44, ML_DSA_65, ML_DSA_87)
              Default: ML_DSA_87 (MIL-SPEC required)

Returns:
    OperationResult with public_key, secret_key, and algorithm info

#### `ml_dsa_sign(secret_key, data, algorithm)`

Sign data using ML-DSA secret key
FIPS 204 - Post-Quantum Digital Signature

Args:
    secret_key: Signer's ML-DSA secret key (hex string)
    data: Data to sign
    algorithm: ML-DSA algorithm used

Returns:
    OperationResult with signature

#### `ml_dsa_verify(public_key, data, signature, algorithm)`

Verify ML-DSA signature
FIPS 204 - Post-Quantum Signature Verification

Args:
    public_key: Signer's ML-DSA public key (hex string)
    data: Signed data
    signature: ML-DSA signature (hex string)
    algorithm: ML-DSA algorithm used

Returns:
    OperationResult with verification status

#### `hybrid_sign(classical_key, pqc_key, data, classical_algo, pqc_algo)`

Hybrid signing: Combine classical (RSA/ECC) and post-quantum (ML-DSA) signatures
Provides security even if one algorithm is broken

Args:
    classical_key: Classical private key (RSA/ECC)
    pqc_key: ML-DSA secret key
    data: Data to sign
    classical_algo: Classical algorithm ("rsa2048", "rsa3072", "ecc_p384")
    pqc_algo: ML-DSA algorithm (default: ML-DSA-87)

Returns:
    OperationResult with dual signature

#### `hybrid_verify(classical_pubkey, pqc_pubkey, data, classical_sig, pqc_sig, classical_algo, pqc_algo)`

Verify hybrid signature (both classical and PQC must verify)

Args:
    classical_pubkey: Classical public key
    pqc_pubkey: ML-DSA public key
    data: Signed data
    classical_sig: Classical signature
    pqc_sig: ML-DSA signature
    classical_algo: Classical algorithm
    pqc_algo: ML-DSA algorithm

Returns:
    OperationResult with verification status (both must pass)

#### `pqc_encrypt(data, recipient_ml_kem_pubkey)`

Encrypt data using Post-Quantum Cryptography
Uses ML-KEM for key encapsulation + AES-256-GCM for data encryption

Args:
    data: Data to encrypt
    recipient_ml_kem_pubkey: Recipient's ML-KEM public key (or generate ephemeral)

Returns:
    OperationResult with encrypted data, ciphertext, and keys

#### `pqc_decrypt(kem_ciphertext, data_ciphertext, nonce, tag, secret_key)`

Decrypt data using Post-Quantum Cryptography
Uses ML-KEM for key decapsulation + AES-256-GCM for data decryption

Args:
    kem_ciphertext: ML-KEM encapsulated key (hex)
    data_ciphertext: AES-GCM encrypted data (hex)
    nonce: AES-GCM nonce (hex)
    tag: AES-GCM authentication tag (hex)
    secret_key: ML-KEM secret key (hex)

Returns:
    OperationResult with decrypted plaintext

#### `validate_pqc_compliance(kem, signature, symmetric, hash_algo)`

Validate if cryptographic configuration meets MIL-SPEC PQC requirements

Args:
    kem: Key encapsulation algorithm
    signature: Signature algorithm
    symmetric: Symmetric encryption algorithm
    hash_algo: Hash algorithm

Returns:
    OperationResult with compliance status and issues

#### `get_pqc_status()`

Get TPM Post-Quantum Cryptography status and capabilities

Returns:
    OperationResult with PQC status, algorithms, and compliance

## Hardware Registers (8)

| Register Name | Constant | Offset |
|---------------|----------|--------|
| TPM_CAPABILITIES | `REG_TPM_CAPABILITIES` | 0x04 |
| TPM_COMMAND | `REG_TPM_COMMAND` | 0x0C |
| TPM_ERROR_CODE | `REG_TPM_ERROR_CODE` | 0x14 |
| TPM_KEY_HANDLE | `REG_TPM_KEY_HANDLE` | 0x1C |
| TPM_PCR_SELECT | `REG_TPM_PCR_SELECT` | 0x18 |
| TPM_RESPONSE | `REG_TPM_RESPONSE` | 0x10 |
| TPM_STATUS | `REG_TPM_STATUS` | 0x00 |
| TPM_VERSION | `REG_TPM_VERSION` | 0x08 |

## Device Constants

### Status Bits

- `STATUS_READY`
- `STATUS_BUSY`
- `STATUS_ERROR`
- `STATUS_LOCKED`
- `STATUS_INITIALIZED`

### Capabilities

- `CAP_RSA`
- `CAP_ECC`
- `CAP_AES`
- `CAP_SHA256`
- `CAP_SHA512`
- `CAP_PCR_EXTEND`
- `CAP_KEY_GENERATION`
- `CAP_SEALING`
- `CAP_ATTESTATION`
- `CAP_POST_QUANTUM`

## Usage Example

```python
from dsmil_auto_discover import discover_all_devices

# Auto-discover all devices
registry = discover_all_devices()

# Get device 0x8000
device = registry.get_device(32768)

# Initialize device
result = device.initialize()
if result.success:
    print(f'Device initialized: {device.name}')

# Get device status
status = device.get_status()
print(f'Device status: {status}')
```

## ‚ö†Ô∏è Safety Notes

This device is classified as MONITORED:
- READ operations are generally safe
- WRITE operations require careful review
- Always test in safe environment first
- Monitor for unexpected behavior

---

**Document Generated:** 2025-11-08  
**Framework Version:** 2.0.0 (Auto-Discovery)  
**Classification:** UNCLASSIFIED // FOR OFFICIAL USE ONLY
