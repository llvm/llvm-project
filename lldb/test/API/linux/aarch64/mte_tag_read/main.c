#include <arm_acle.h>
#include <asm/hwcap.h>
#include <asm/mman.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <unistd.h>

int main(int argc, char const *argv[]) {
  // We assume that the test runner has checked we're on an MTE system

  if (prctl(PR_SET_TAGGED_ADDR_CTRL,
            PR_TAGGED_ADDR_ENABLE | PR_MTE_TCF_SYNC |
                // Allow all tags to be generated by the addg
                // instruction __arm_mte_increment_tag produces.
                (0xffff << PR_MTE_TAG_SHIFT),
            0, 0, 0)) {
    return 1;
  }

  size_t page_size = sysconf(_SC_PAGESIZE);

  // Allocate memory with MTE
  // We ask for two pages. One is read only so that we get
  // 2 mappings in /proc/.../smaps so we can check reading
  // a range across mappings.
  // The first allocation will start at the highest address,
  // so we allocate buf2 first to get:
  // <low address> | buf | buf2 | <high address>
  int prot = PROT_READ | PROT_MTE;
  int flags = MAP_PRIVATE | MAP_ANONYMOUS;

  char *buf2 = mmap(0, page_size, prot, flags, -1, 0);
  if (buf2 == MAP_FAILED)
    return 1;

  // Writeable so we can set tags on it later
  char *buf = mmap(0, page_size, prot | PROT_WRITE, flags, -1, 0);
  if (buf == MAP_FAILED)
    return 1;

  // We expect the mappings to be next to each other
  if (buf2 - buf != page_size)
    return 1;

  // And without MTE
  char *non_mte_buf = mmap(0, page_size, PROT_READ | PROT_WRITE, flags, -1, 0);
  if (non_mte_buf == MAP_FAILED)
    return 1;

  // Set incrementing tags until end of the first page
  char *tagged_ptr = buf;
  // This ignores tag bits when subtracting the addresses
  while (__arm_mte_ptrdiff(tagged_ptr, buf) < page_size) {
    // Set the allocation tag for this location
    __arm_mte_set_tag(tagged_ptr);
    // + 16 for 16 byte granules
    // Earlier we allowed all tag values, so this will give us an
    // incrementing pattern 0-0xF wrapping back to 0.
    tagged_ptr = __arm_mte_increment_tag(tagged_ptr + 16, 1);
  }

  // Tag the original pointer with 9
  buf = __arm_mte_create_random_tag(buf, ~(1 << 9));
  // A different tag so that buf_alt_tag > buf if you don't handle the tag
  char *buf_alt_tag = __arm_mte_create_random_tag(buf, ~(1 << 10));

  // lldb should be removing the whole top byte, not just the tags.
  // So fill 63-60 with something non zero so we'll fail if we only remove tags.
#define SET_TOP_NIBBLE(ptr) (char *)((size_t)(ptr) | (0xA << 60))
  buf = SET_TOP_NIBBLE(buf);
  buf_alt_tag = SET_TOP_NIBBLE(buf_alt_tag);
  buf2 = SET_TOP_NIBBLE(buf2);

  // Breakpoint here
  return 0;
}
