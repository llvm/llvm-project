# Test unwind info for functions which have been split into two or more parts.
# In particular, check that the address ranges of these plans are correct, as
# overly large ranges have caused a bug in the past.

# REQUIRES: lld, target-x86_64

# RUN: llvm-mc -triple=x86_64-pc-linux -filetype=obj \
# RUN:   %S/Inputs/basic-block-sections-with-dwarf.s > %t.o
# RUN: ld.lld %t.o -o %t
## NB: This minidump exists only as a receptacle for the object file built
## above. This is a workaround for the fact that "image show-unwind" does not
## work without a Process object.
# RUN: yaml2obj %S/Inputs/linux-x86_64.yaml > %t.core
# RUN: %lldb -c %t.core %t -o "image load --file %t --slide 0" -s %s -o exit | \
# RUN:   FileCheck --implicit-check-not="UNWIND PLANS" %s

image show-unwind -n foo
# CHECK: UNWIND PLANS for {{.*}}`foo
#
# CHECK:      Asynchronous (not restricted to call-sites) UnwindPlan is 'eh_frame CFI'
# CHECK-NEXT: Synchronous (restricted to call-sites) UnwindPlan is 'eh_frame CFI'

# CHECK:      Assembly language inspection UnwindPlan:
# CHECK-NEXT: This UnwindPlan originally sourced from assembly insn profiling
# CHECK-NEXT: This UnwindPlan is sourced from the compiler: no.
# CHECK-NEXT: This UnwindPlan is valid at all instruction locations: yes.
# CHECK-NEXT: This UnwindPlan is for a trap handler function: no.
# CHECK-NEXT: Address range of this UnwindPlan: [{{.*}}.text + 6-0x0000000000000019)

# CHECK:      eh_frame UnwindPlan:
# CHECK-NEXT: This UnwindPlan originally sourced from eh_frame CFI
# CHECK-NEXT: This UnwindPlan is sourced from the compiler: yes.
# CHECK-NEXT: This UnwindPlan is valid at all instruction locations: no.
# CHECK-NEXT: This UnwindPlan is for a trap handler function: no.
# CHECK-NEXT: Address range of this UnwindPlan: [{{.*}}.text + 6-0x0000000000000019)
# CHECK-NEXT: row[0]:    0: CFA=rsp +8 => rip=[CFA-8]
# CHECK-NEXT: row[1]:    1: CFA=rsp+16 => rbp=[CFA-16] rip=[CFA-8]
# CHECK-NEXT: row[2]:    4: CFA=rbp+16 => rbp=[CFA-16] rip=[CFA-8]
# CHECK-EMPTY:

image show-unwind -n foo.__part.1
# CHECK: UNWIND PLANS for {{.*}}`foo.__part.1

## As of this writing (Oct 2024), the async unwind plan is "assembly insn
## profiling", which isn't ideal, because this "function" does not follow the
## standard ABI. We end up choosing this plan because the eh_frame unwind plan
## looks like the unwind plan for a regular function without the prologue
## information.
# CHECK: Synchronous (restricted to call-sites) UnwindPlan is 'eh_frame CFI'

# CHECK:      Assembly language inspection UnwindPlan:
# CHECK-NEXT: This UnwindPlan originally sourced from assembly insn profiling
# CHECK-NEXT: This UnwindPlan is sourced from the compiler: no.
# CHECK-NEXT: This UnwindPlan is valid at all instruction locations: yes.
# CHECK-NEXT: This UnwindPlan is for a trap handler function: no.
# CHECK-NEXT: Address range of this UnwindPlan: [{{.*}}.text + 25-0x0000000000000023)

# CHECK:      eh_frame UnwindPlan:
# CHECK-NEXT: This UnwindPlan originally sourced from eh_frame CFI
# CHECK-NEXT: This UnwindPlan is sourced from the compiler: yes.
# CHECK-NEXT: This UnwindPlan is valid at all instruction locations: no.
# CHECK-NEXT: This UnwindPlan is for a trap handler function: no.
# CHECK-NEXT: Address range of this UnwindPlan: [{{.*}}.text + 25-0x0000000000000023)
# CHECK-NEXT: row[0]:    0: CFA=rbp+16 => rbp=[CFA-16] rip=[CFA-8]
# CHECK-EMPTY:
