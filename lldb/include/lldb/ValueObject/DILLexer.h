//===-- DILLexer.h ----------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLDB_VALUEOBJECT_DILLEXER_H_
#define LLDB_VALUEOBJECT_DILLEXER_H_

#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/iterator_range.h"
#include "llvm/Support/Error.h"
#include <cstdint>
#include <limits.h>
#include <memory>
#include <string>
#include <vector>

namespace lldb_private {

namespace dil {

/// Class defining the tokens generated by the DIL lexer and used by the
/// DIL parser.
class Token {
public:
  enum Kind {
    coloncolon,
    eof,
    identifier,
    invalid,
    kw_namespace,
    l_paren,
    none,
    r_paren,
    unknown,
  };

  Token(Kind kind, std::string spelling, uint32_t start)
      : m_kind(kind), m_spelling(spelling), m_start_pos(start) {}

  Token() : m_kind(Kind::none), m_spelling(""), m_start_pos(0) {}

  void SetKind(Kind kind) { m_kind = kind; }

  Kind GetKind() const { return m_kind; }

  std::string GetSpelling() const { return m_spelling; }

  uint32_t GetLength() const { return m_spelling.size(); }

  bool Is(Kind kind) const { return m_kind == kind; }

  bool IsNot(Kind kind) const { return m_kind != kind; }

  bool IsOneOf(Kind kind1, Kind kind2) const { return Is(kind1) || Is(kind2); }

  template <typename... Ts> bool IsOneOf(Kind kind, Ts... Ks) const {
    return Is(kind) || IsOneOf(Ks...);
  }

  uint32_t GetLocation() const { return m_start_pos; }

  static llvm::StringRef GetTokenName(Kind kind);

private:
  Kind m_kind;
  std::string m_spelling;
  uint32_t m_start_pos; // within entire expression string
};

/// Class for doing the simple lexing required by DIL.
class DILLexer {
public:
  DILLexer(llvm::StringRef dil_expr) : m_expr(dil_expr) {
    m_cur_pos = m_expr.begin();
    // Use UINT_MAX to indicate invalid/uninitialized value.
    m_tokens_idx = UINT_MAX;
    m_invalid_token = Token(Token::invalid, "", 0);
  }

  llvm::Expected<bool> LexAll();

  /// Return the lexed token N+1 positions ahead of the 'current' token
  /// being handled by the DIL parser.
  const Token &LookAhead(uint32_t N);

  const Token &AcceptLookAhead(uint32_t N);

  const Token &GetNextToken();

  /// Return the index for the 'current' token being handled by the DIL parser.
  uint32_t GetCurrentTokenIdx() { return m_tokens_idx; }

  /// Return the current token to be handled by the DIL parser.
  const Token &GetCurrentToken() { return m_lexed_tokens[m_tokens_idx]; }

  uint32_t NumLexedTokens() { return m_lexed_tokens.size(); }

  /// Update the index for the 'current' token, to point to the next lexed
  /// token.
  bool IncrementTokenIdx() {
    if (m_tokens_idx >= m_lexed_tokens.size() - 1)
      return false;

    m_tokens_idx++;
    return true;
  }

  /// Set the index for the 'current' token (to be handled by the parser)
  /// to a particular position. Used for either committing 'look ahead' parsing
  /// or rolling back tentative parsing.
  bool ResetTokenIdx(uint32_t new_value) {
    if (new_value > m_lexed_tokens.size() - 1)
      return false;

    m_tokens_idx = new_value;
    return true;
  }

  uint32_t GetLocation() { return m_cur_pos - m_expr.begin(); }

private:
  llvm::Expected<Token> Lex();

  llvm::iterator_range<llvm::StringRef::iterator> IsWord();

  /// Update 'result' with the other paremeter values, create a
  /// duplicate token, and push the duplicate token onto the vector of
  /// lexed tokens.
  void UpdateLexedTokens(Token &result, Token::Kind tok_kind,
                         std::string tok_str, uint32_t tok_pos);

  // The input string we are lexing & parsing.
  llvm::StringRef m_expr;

  // The current position of the lexer within m_expr (the character position,
  // within the string, of the next item to be lexed).
  llvm::StringRef::iterator m_cur_pos;

  // Holds all of the tokens lexed so far.
  std::vector<Token> m_lexed_tokens;

  // Index into m_lexed_tokens; indicates which token the DIL parser is
  // currently trying to parse/handle.
  uint32_t m_tokens_idx;

  // "invalid" token; to be returned by lexer when 'look ahead' fails.
  Token m_invalid_token;
};

} // namespace dil

} // namespace lldb_private

#endif // LLDB_VALUEOBJECT_DILLEXER_H_
