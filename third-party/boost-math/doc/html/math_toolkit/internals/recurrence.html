<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Tools For 3-Term Recurrence Relations</title>
<link rel="stylesheet" href="../../math.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Math Toolkit 4.2.1">
<link rel="up" href="../internals.html" title="Internal tools">
<link rel="prev" href="engel_expansion.html" title="Engel Expansion">
<link rel="next" href="cohen_acceleration.html" title="Cohen Acceleration">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="engel_expansion.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../internals.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="cohen_acceleration.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="math_toolkit.internals.recurrence"></a><a class="link" href="recurrence.html" title="Tools For 3-Term Recurrence Relations">Tools For 3-Term Recurrence
      Relations</a>
</h3></div></div></div>
<h5>
<a name="math_toolkit.internals.recurrence.h0"></a>
        <span class="phrase"><a name="math_toolkit.internals.recurrence.synopsis"></a></span><a class="link" href="recurrence.html#math_toolkit.internals.recurrence.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">tools</span><span class="special">/</span><span class="identifier">recurrence</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">math</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">tools</span><span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">function_ratio_from_backwards_recurrence</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">factor</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">function_ratio_from_forwards_recurrence</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">factor</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">NextCoefs</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">apply_recurrence_relation_forward</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">NextCoefs</span><span class="special">&amp;</span> <span class="identifier">get_coefs</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">number_of_steps</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">second</span><span class="special">,</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">*</span> <span class="identifier">log_scaling</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">T</span><span class="special">*</span> <span class="identifier">previous</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">NextCoefs</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">apply_recurrence_relation_backward</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">NextCoefs</span><span class="special">&amp;</span> <span class="identifier">get_coefs</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">number_of_steps</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">second</span><span class="special">,</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">*</span> <span class="identifier">log_scaling</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">T</span><span class="special">*</span> <span class="identifier">previous</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">forward_recurrence_iterator</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">backward_recurrence_iterator</span><span class="special">;</span>

<span class="special">}}}</span> <span class="comment">// namespaces</span>
</pre>
<h5>
<a name="math_toolkit.internals.recurrence.h1"></a>
        <span class="phrase"><a name="math_toolkit.internals.recurrence.description"></a></span><a class="link" href="recurrence.html#math_toolkit.internals.recurrence.description">Description</a>
      </h5>
<p>
        All of the tools in this header require a description of the recurrence relation:
        this takes the form of a functor that returns a tuple containing the 3 coefficients,
        specifically, given a recurrence relation:
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          <span class="inlinemediaobject"><img src="../../../equations/three_term_recurrence.svg"></span>

        </p></blockquote></div>
<p>
        And a functor <code class="computeroutput"><span class="identifier">F</span></code> then the
        expression:
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          <span class="serif_italic">F(n);</span>
        </p></blockquote></div>
<p>
        Returns a tuple containing <span class="serif_italic">{ a<sub>n</sub>, b<sub>n</sub>, c<sub>n</sub> }</span>.
      </p>
<p>
        For example, the recurrence relation for the Bessel J and Y functions when
        written in this form is:
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../equations/three_term_recurrence_bessel_jy.svg" width="250" height="38"></object></span>
      </p>
<p>
        Therefore, given local variables <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>v</em></span>
        of type <code class="computeroutput"><span class="keyword">double</span></code> the recurrence
        relation for Bessel J and Y can be encoded in a lambda expression like this:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">recurrence_functor_jy</span> <span class="special">=</span> <span class="special">[&amp;](</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="number">1.0</span><span class="special">,</span> <span class="special">-</span><span class="number">2</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">v</span> <span class="special">+</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">x</span><span class="special">,</span> <span class="number">1.0</span><span class="special">);</span> <span class="special">};</span>
</pre>
<p>
        Similarly, the Bessel I and K recurrence relation differs just by the sign
        of the final term:
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../equations/three_term_recurrence_bessel_ik.svg" width="244" height="38"></object></span>
      </p>
<p>
        And this could be encoded as:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">recurrence_functor_ik</span> <span class="special">=</span> <span class="special">[&amp;](</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="number">1.0</span><span class="special">,</span> <span class="special">-</span><span class="number">2</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">v</span> <span class="special">+</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">/</span> <span class="identifier">x</span><span class="special">,</span> <span class="special">-</span><span class="number">1.0</span><span class="special">);</span> <span class="special">};</span>
</pre>
<p>
        The tools are then as follows:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">function_ratio_from_backwards_recurrence</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">factor</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>
</pre>
<p>
        Given a functor <code class="computeroutput"><span class="identifier">r</span></code> which encodes
        the recurrence relation for function <code class="computeroutput"><span class="identifier">F</span></code>
        at some location <span class="emphasis"><em>n</em></span>, then returns the ratio:
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../equations/three_term_recurrence_backwards_ratio.svg" width="63" height="20"></object></span>
      </p>
<p>
        This calculation is stable only if recurrence is stable in the backwards
        direction. Further the ratio calculated is for the dominant solution (in
        the backwards direction) of the recurrence relation, if there are multiple
        solutions, then there is no guarantee that this will find the one you want
        or expect.
      </p>
<p>
        Argument <span class="emphasis"><em>factor</em></span> is the tolerance required for convergence
        of the continued fraction associated with the recurrence relation, and should
        be no smaller than machine epsilon. Argument <span class="emphasis"><em>max_iter</em></span>
        sets the maximum number of permitted iterations in the associated continued
        fraction.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">function_ratio_from_forwards_recurrence</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">factor</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>
</pre>
<p>
        Given a functor <code class="computeroutput"><span class="identifier">r</span></code> which encodes
        the recurrence relation for function F at some location <span class="emphasis"><em>n</em></span>,
        then returns the ratio:
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../equations/three_term_recurrence_forwards_ratio.svg" width="63" height="20"></object></span>
      </p>
<p>
        This calculation is stable only if recurrence is stable in the forwards direction.
        Further the ratio calculated is for the dominant solution (in the forwards
        direction) of the recurrence relation, if there are multiple solutions, then
        there is no guarantee that this will find the one you want or expect.
      </p>
<p>
        Argument <span class="emphasis"><em>factor</em></span> is the tolerance required for convergence
        of the continued fraction associated with the recurrence relation, and should
        be no smaller than machine epsilon. Argument <span class="emphasis"><em>max_iter</em></span>
        sets the maximum number of permitted iterations in the associated continued
        fraction.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">NextCoefs</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">apply_recurrence_relation_forward</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">NextCoefs</span><span class="special">&amp;</span> <span class="identifier">get_coefs</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">number_of_steps</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">second</span><span class="special">,</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">*</span> <span class="identifier">log_scaling</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">T</span><span class="special">*</span> <span class="identifier">previous</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
</pre>
<p>
        Applies a recurrence relation in a stable forward direction, starting with
        the values F<sub>n-1</sub> and F<sub>n</sub>.
      </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">get_coefs</span></dt>
<dd><p>
              Functor that returns the coefficients of the recurrence relation. The
              coefficients should be centered on position <span class="emphasis"><em>second</em></span>.
            </p></dd>
<dt><span class="term">number_of_steps</span></dt>
<dd><p>
              The number of steps to apply the recurrence relation onwards from
              <span class="emphasis"><em>second</em></span>.
            </p></dd>
<dt><span class="term">first</span></dt>
<dd><p>
              The value of F<sub>n-1</sub>
            </p></dd>
<dt><span class="term">second</span></dt>
<dd><p>
              The value of F<sub>n</sub>
            </p></dd>
<dt><span class="term">log_scaling</span></dt>
<dd><p>
              When provided, the recurrence relations may be rescaled internally
              to avoid over/underflow issues. The result should be multiplied by
              <code class="computeroutput"><span class="identifier">exp</span><span class="special">(*</span><span class="identifier">log_scaling</span><span class="special">)</span></code>
              to get the true value of the result.
            </p></dd>
<dt><span class="term">previous</span></dt>
<dd><p>
              When provided, is set to the value of F<sub>n + number_of_steps - 1</sub>
            </p></dd>
</dl>
</div>
<p>
        Returns F<sub>n + number_of_steps</sub>.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">NextCoefs</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">apply_recurrence_relation_backward</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">NextCoefs</span><span class="special">&amp;</span> <span class="identifier">get_coefs</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">number_of_steps</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">second</span><span class="special">,</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">*</span> <span class="identifier">log_scaling</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">T</span><span class="special">*</span> <span class="identifier">previous</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
</pre>
<p>
        Applies a recurrence relation in a stable backward direction, starting with
        the values F<sub>n+1</sub> and F<sub>n</sub>.
      </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">get_coefs</span></dt>
<dd><p>
              Functor that returns the coefficients of the recurrence relation. The
              coefficients should be centered on position <span class="emphasis"><em>second</em></span>.
            </p></dd>
<dt><span class="term">number_of_steps</span></dt>
<dd><p>
              The number of steps to apply the recurrence relation backwards from
              <span class="emphasis"><em>second</em></span>.
            </p></dd>
<dt><span class="term">first</span></dt>
<dd><p>
              The value of F<sub>n+1</sub>
            </p></dd>
<dt><span class="term">second</span></dt>
<dd><p>
              The value of F<sub>n</sub>
            </p></dd>
<dt><span class="term">log_scaling</span></dt>
<dd><p>
              When provided, the recurrence relations may be rescaled internally
              to avoid over/underflow issues. The result should be multiplied by
              <code class="computeroutput"><span class="identifier">exp</span><span class="special">(*</span><span class="identifier">log_scaling</span><span class="special">)</span></code>
              to get the true value of the result.
            </p></dd>
<dt><span class="term">previous</span></dt>
<dd><p>
              When provided, is set to the value of F<sub>n - number_of_steps + 1</sub>
            </p></dd>
</dl>
</div>
<p>
        Returns F<sub>n - number_of_steps</sub>.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">forward_recurrence_iterator</span>
<span class="special">{</span>
   <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">declval</span><span class="special">&lt;</span><span class="identifier">Recurrence</span><span class="special">&amp;&gt;()(</span><span class="number">0</span><span class="special">)))&gt;::</span><span class="identifier">type</span> <span class="identifier">value_type</span><span class="special">;</span>

   <span class="identifier">forward_recurrence_iterator</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="identifier">f_n_minus_1</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="identifier">f_n</span><span class="special">);</span>
   <span class="identifier">forward_recurrence_iterator</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="identifier">f_n</span><span class="special">);</span>
   <span class="comment">/* Operators omitted for clarity */</span>
<span class="special">};</span>
</pre>
<p>
        Type <code class="computeroutput"><span class="identifier">forward_recurrence_iterator</span></code>
        defines a forward-iterator for a recurrence relation stable in the forward
        direction. The constructors take the recurrence relation, plus either one
        or two values: if only one value is provided, then the second is computed
        by using the recurrence relation to calculate the function ratio.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Recurrence</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">backward_recurrence_iterator</span>
<span class="special">{</span>
   <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">declval</span><span class="special">&lt;</span><span class="identifier">Recurrence</span><span class="special">&amp;&gt;()(</span><span class="number">0</span><span class="special">)))&gt;::</span><span class="identifier">type</span> <span class="identifier">value_type</span><span class="special">;</span>

   <span class="identifier">backward_recurrence_iterator</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="identifier">f_n_plus_1</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="identifier">f_n</span><span class="special">);</span>
   <span class="identifier">backward_recurrence_iterator</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Recurrence</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">,</span> <span class="identifier">value_type</span> <span class="identifier">f_n</span><span class="special">);</span>
   <span class="comment">/* Operators omitted for clarity */</span>
<span class="special">};</span>
</pre>
<p>
        Type <code class="computeroutput"><span class="identifier">backward_recurrence_iterator</span></code>
        defines a forward-iterator for a recurrence relation stable in the backward
        direction. The constructors take the recurrence relation, plus either one
        or two values: if only one value is provided, then the second is computed
        by using the recurrence relation to calculate the function ratio.
      </p>
<p>
        Note that <span class="emphasis"><em>incrementing</em></span> this iterator moves the value
        returned successively to F<sub>n-1</sub>, F<sub>n-2</sub> etc.
      </p>
</div>
<div class="copyright-footer">Copyright © 2006-2021 Nikhar Agrawal, Anton Bikineev, Matthew Borland,
      Paul A. Bristow, Marco Guazzone, Christopher Kormanyos, Hubert Holin, Bruno
      Lalande, John Maddock, Evan Miller, Jeremy Murphy, Matthew Pulver, Johan Råde,
      Gautam Sewani, Benjamin Sobotta, Nicholas Thompson, Thijs van den Berg, Daryle
      Walker and Xiaogang Zhang<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="engel_expansion.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../internals.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="cohen_acceleration.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
