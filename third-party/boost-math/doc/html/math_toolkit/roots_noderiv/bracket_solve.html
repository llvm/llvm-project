<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Bracket and Solve Root</title>
<link rel="stylesheet" href="../../math.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Math Toolkit 4.2.1">
<link rel="up" href="../roots_noderiv.html" title="Root Finding Without Derivatives">
<link rel="prev" href="bisect.html" title="Bisection">
<link rel="next" href="TOMS748.html" title="Algorithm TOMS 748: Alefeld, Potra and Shi: Enclosing zeros of continuous functions">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="bisect.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../roots_noderiv.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="TOMS748.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="math_toolkit.roots_noderiv.bracket_solve"></a><a class="link" href="bracket_solve.html" title="Bracket and Solve Root">Bracket and
      Solve Root</a>
</h3></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Tol</span><span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span>
   <span class="identifier">bracket_and_solve_root</span><span class="special">(</span>
      <span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span>
      <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">guess</span><span class="special">,</span>
      <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">factor</span><span class="special">,</span>
      <span class="keyword">bool</span> <span class="identifier">rising</span><span class="special">,</span>
      <span class="identifier">Tol</span> <span class="identifier">tol</span><span class="special">,</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Tol</span><span class="special">,</span> <span class="keyword">class</span> <a class="link" href="../../policy.html" title="Chapter 22. Policies: Controlling Precision, Error Handling etc">Policy</a><span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span>
   <span class="identifier">bracket_and_solve_root</span><span class="special">(</span>
      <span class="identifier">F</span> <span class="identifier">f</span><span class="special">,</span>
      <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">guess</span><span class="special">,</span>
      <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">factor</span><span class="special">,</span>
      <span class="keyword">bool</span> <span class="identifier">rising</span><span class="special">,</span>
      <span class="identifier">Tol</span> <span class="identifier">tol</span><span class="special">,</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">uintmax_t</span><span class="special">&amp;</span> <span class="identifier">max_iter</span><span class="special">,</span>
      <span class="keyword">const</span> <a class="link" href="../../policy.html" title="Chapter 22. Policies: Controlling Precision, Error Handling etc">Policy</a><span class="special">&amp;);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">bracket_and_solve_root</span></code> is
        a convenience function that calls <a class="link" href="TOMS748.html" title="Algorithm TOMS 748: Alefeld, Potra and Shi: Enclosing zeros of continuous functions">TOMS
        748 algorithm</a> internally to find the root of <span class="emphasis"><em>f(x)</em></span>.
        It is generally much easier to use this function rather than <a class="link" href="TOMS748.html" title="Algorithm TOMS 748: Alefeld, Potra and Shi: Enclosing zeros of continuous functions">TOMS
        748 algorithm</a>, since it does the hard work of bracketing the root
        for you. It's bracketing routines are quite robust and will usually be more
        foolproof than home-grown routines, unless the function can be analysed to
        yield tight brackets.
      </p>
<p>
        Note that this routine can only be used when:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <span class="emphasis"><em>f(x)</em></span> is monotonic in the half of the real axis containing
            <span class="emphasis"><em>guess</em></span>.
          </li>
<li class="listitem">
            The value of the initial guess must have the same sign as the root: the
            function will <span class="emphasis"><em>never cross the origin</em></span> when searching
            for the root.
          </li>
<li class="listitem">
            The location of the root should be known at least approximately, if the
            location of the root differs by many orders of magnitude from <span class="emphasis"><em>guess</em></span>
            then many iterations will be needed to bracket the root in spite of the
            special heuristics used to guard against this very situation. A typical
            example would be setting the initial guess to 0.1, when the root is at
            1e-300.
          </li>
</ul></div>
<p>
        The <code class="computeroutput"><span class="identifier">bracket_and_solve_root</span></code>
        parameters are:
      </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">f</span></dt>
<dd><p>
              A unary functor (or C++ lambda) that is the function whose root is
              to be solved. <span class="emphasis"><em>f(x)</em></span> must be uniformly increasing
              or decreasing on <span class="emphasis"><em>x</em></span>.
            </p></dd>
<dt><span class="term">guess</span></dt>
<dd><p>
              An initial approximation to the root.
            </p></dd>
<dt><span class="term">factor</span></dt>
<dd><p>
              A scaling factor that is used to bracket the root: the value <span class="emphasis"><em>guess</em></span>
              is multiplied (or divided as appropriate) by <span class="emphasis"><em>factor</em></span>
              until two values are found that bracket the root. A value such as 2
              is a typical choice for <span class="emphasis"><em>factor</em></span>. In addition <span class="emphasis"><em>factor</em></span>
              will be multiplied by 2 every 32 iterations: this is to guard against
              a really very bad initial guess, typically these occur when it's known
              the result is very large or small, but not the exact order of magnitude.
            </p></dd>
<dt><span class="term">rising</span></dt>
<dd><p>
              Set to <span class="emphasis"><em>true</em></span> if <span class="emphasis"><em>f(x)</em></span> is rising
              on <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>false</em></span> if <span class="emphasis"><em>f(x)</em></span>
              is falling on <span class="emphasis"><em>x</em></span>. This value is used along with
              the result of <span class="emphasis"><em>f(guess)</em></span> to determine if <span class="emphasis"><em>guess</em></span>
              is above or below the root.
            </p></dd>
<dt><span class="term">tol</span></dt>
<dd><p>
              A binary functor (or C++ lambda) that determines the termination condition
              for the search for the root. <span class="emphasis"><em>tol</em></span> is passed the
              current brackets at each step, when it returns true then the current
              brackets are returned as the pair result. See also <a class="link" href="root_termination.html" title="Termination Condition Functors">predefined
              termination functors</a>.
            </p></dd>
<dt><span class="term">max_iter</span></dt>
<dd><p>
              The maximum number of function invocations to perform in the search
              for the root. On exit is set to the actual number of invocations performed.
            </p></dd>
</dl>
</div>
<p>
        The final <a class="link" href="../../policy.html" title="Chapter 22. Policies: Controlling Precision, Error Handling etc">Policy</a> argument is optional and can
        be used to control the behaviour of the function: how it handles errors,
        what level of precision to use etc. Refer to the <a class="link" href="../../policy.html" title="Chapter 22. Policies: Controlling Precision, Error Handling etc">policy
        documentation for more details</a>.
      </p>
<p>
        <span class="bold"><strong>Returns</strong></span>: a pair of values <span class="emphasis"><em>r</em></span>
        that bracket the root so that:
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          f(r.first) * f(r.second) &lt;= 0
        </p></blockquote></div>
<p>
        and either
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          tol(r.first, r.second) == true
        </p></blockquote></div>
<p>
        or
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          max_iter &gt;= m
        </p></blockquote></div>
<p>
        where <span class="emphasis"><em>m</em></span> is the initial value of <span class="emphasis"><em>max_iter</em></span>
        passed to the function.
      </p>
<p>
        In other words, it's up to the caller to verify whether termination occurred
        as a result of exceeding <span class="emphasis"><em>max_iter</em></span> function invocations
        (easily done by checking the value of <span class="emphasis"><em>max_iter</em></span> when
        the function returns), rather than because the termination condition <span class="emphasis"><em>tol</em></span>
        was satisfied.
      </p>
</div>
<div class="copyright-footer">Copyright © 2006-2021 Nikhar Agrawal, Anton Bikineev, Matthew Borland,
      Paul A. Bristow, Marco Guazzone, Christopher Kormanyos, Hubert Holin, Bruno
      Lalande, John Maddock, Evan Miller, Jeremy Murphy, Matthew Pulver, Johan Råde,
      Gautam Sewani, Benjamin Sobotta, Nicholas Thompson, Thijs van den Berg, Daryle
      Walker and Xiaogang Zhang<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="bisect.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../roots_noderiv.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="TOMS748.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
