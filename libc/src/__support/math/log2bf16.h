//===-- Double-precision log2(x) function ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIBC_SRC___SUPPORT_MATH_LOG2BF16_H
#define LLVM_LIBC_SRC___SUPPORT_MATH_LOG2BF16_H

#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/bfloat16.h"
#include "src/__support/FPUtil/cast.h"
#include "src/__support/common.h"
#include "src/__support/macros/config.h"
#include "src/__support/macros/optimization.h"

namespace LIBC_NAMESPACE_DECL {

namespace math {

// Generated by Sollya with the following commands:
//   > display = hexadecimal;
//   > for i from 0 to 127 do print(round(log2(1 + i * 2^-7), SG, RN));
static constexpr float LOG2F_1_PLUS_M[128] = {
    0x0.0p0f,       0x1.6fe50cp-7f, 0x1.6e7968p-6f, 0x1.11cd1ep-5f,
    0x1.6bad38p-5f, 0x1.c4dfacp-5f, 0x1.0eb38ap-4f, 0x1.3aa2fep-4f,
    0x1.663f7p-4f,  0x1.918a16p-4f, 0x1.bc8424p-4f, 0x1.e72ec2p-4f,
    0x1.08c588p-3f, 0x1.1dcd1ap-3f, 0x1.32ae9ep-3f, 0x1.476aap-3f,
    0x1.5c01a4p-3f, 0x1.70742ep-3f, 0x1.84c2bep-3f, 0x1.98eddp-3f,
    0x1.acf5e2p-3f, 0x1.c0db6cp-3f, 0x1.d49ee4p-3f, 0x1.e840bep-3f,
    0x1.fbc16cp-3f, 0x1.0790aep-2f, 0x1.11307ep-2f, 0x1.1ac05cp-2f,
    0x1.24407ap-2f, 0x1.2db11p-2f,  0x1.37124cp-2f, 0x1.406464p-2f,
    0x1.49a784p-2f, 0x1.52dbep-2f,  0x1.5c01a4p-2f, 0x1.6518fep-2f,
    0x1.6e221cp-2f, 0x1.771d2cp-2f, 0x1.800a56p-2f, 0x1.88e9c8p-2f,
    0x1.91bba8p-2f, 0x1.9a8024p-2f, 0x1.a3376p-2f,  0x1.abe188p-2f,
    0x1.b47ecp-2f,  0x1.bd0f2ep-2f, 0x1.c592fap-2f, 0x1.ce0a4ap-2f,
    0x1.d6753ep-2f, 0x1.ded3fep-2f, 0x1.e726aap-2f, 0x1.ef6d68p-2f,
    0x1.f7a856p-2f, 0x1.ffd79ap-2f, 0x1.03fda8p-1f, 0x1.0809dp-1f,
    0x1.0c105p-1f,  0x1.10113cp-1f, 0x1.140cap-1f,  0x1.18028cp-1f,
    0x1.1bf312p-1f, 0x1.1fde3ep-1f, 0x1.23c41ep-1f, 0x1.27a4cp-1f,
    0x1.2b8034p-1f, 0x1.2f5688p-1f, 0x1.3327c6p-1f, 0x1.36f4p-1f,
    0x1.3abb4p-1f,  0x1.3e7d94p-1f, 0x1.423b08p-1f, 0x1.45f3aap-1f,
    0x1.49a784p-1f, 0x1.4d56a6p-1f, 0x1.510118p-1f, 0x1.54a6e8p-1f,
    0x1.584822p-1f, 0x1.5be4dp-1f,  0x1.5f7dp-1f,   0x1.6310b8p-1f,
    0x1.66a008p-1f, 0x1.6a2afap-1f, 0x1.6db196p-1f, 0x1.7133eap-1f,
    0x1.74b1fep-1f, 0x1.782bdcp-1f, 0x1.7ba19p-1f,  0x1.7f1322p-1f,
    0x1.82809ep-1f, 0x1.85ea0cp-1f, 0x1.894f74p-1f, 0x1.8cb0e4p-1f,
    0x1.900e62p-1f, 0x1.9367f6p-1f, 0x1.96bdaep-1f, 0x1.9a0f8ep-1f,
    0x1.9d5dap-1f,  0x1.a0a7eep-1f, 0x1.a3ee8p-1f,  0x1.a7315ep-1f,
    0x1.aa709p-1f,  0x1.adac1ep-1f, 0x1.b0e412p-1f, 0x1.b41874p-1f,
    0x1.b74948p-1f, 0x1.ba769cp-1f, 0x1.bda072p-1f, 0x1.c0c6d4p-1f,
    0x1.c3e9cap-1f, 0x1.c7095ap-1f, 0x1.ca258ep-1f, 0x1.cd3e6ap-1f,
    0x1.d053f6p-1f, 0x1.d3663cp-1f, 0x1.d6753ep-1f, 0x1.d98106p-1f,
    0x1.dc899ap-1f, 0x1.df8f02p-1f, 0x1.e29142p-1f, 0x1.e59064p-1f,
    0x1.e88c6cp-1f, 0x1.eb856p-1f,  0x1.ee7b48p-1f, 0x1.f16e28p-1f,
    0x1.f45e08p-1f, 0x1.f74afp-1f,  0x1.fa34e2p-1f, 0x1.fd1be4p-1f,
};

LIBC_INLINE static bfloat16 log2bf16(bfloat16 x) {
  using FPBits = fputil::FPBits<bfloat16>;
  FPBits x_bits(x);

  uint16_t x_u = x_bits.uintval();

  // If x <= 0, or x is 1, or x is +inf, or x is NaN.
  if (LIBC_UNLIKELY(x_u == 0U || x_u == 0x3f80U || x_u >= 0x7f80U)) {
    // log(NaN) = NaN
    if (x_bits.is_nan()) {
      if (x_bits.is_signaling_nan()) {
        fputil::raise_except_if_required(FE_INVALID);
        return FPBits::quiet_nan().get_val();
      }
      return x;
    }

    // log(+/-0) = âˆ’inf
    if ((x_u & 0x7fffU) == 0U) {
      fputil::raise_except_if_required(FE_DIVBYZERO);
      return FPBits::inf(Sign::NEG).get_val();
    }

    // log(1) = 0
    if (x_u == 0x3f80U)
      return FPBits::zero().get_val();

    // x < 0
    if (x_u > 0x8000U) {
      fputil::set_errno_if_required(EDOM);
      fputil::raise_except_if_required(FE_INVALID);
      return FPBits::quiet_nan().get_val();
    }

    // log(+inf) = +inf
    return FPBits::inf().get_val();
  }

  int e = -FPBits::EXP_BIAS;

  // When x is subnormal, normalize it.
  if ((x_u & FPBits::EXP_MASK) == 0U) {
    // Can't pass an integer to fputil::cast directly.
    constexpr float NORMALIZE_EXP = 1U << FPBits::FRACTION_LEN;
    x_bits = FPBits(x_bits.get_val() * fputil::cast<bfloat16>(NORMALIZE_EXP));
    x_u = x_bits.uintval();
    e -= FPBits::FRACTION_LEN;
  }

  // To compute log2(x), we do the following:
  //   x = 2^e * (1 + m),
  //   log2(x) = e + log2(1 + m).
  // for BFloat16, mantissa is at most 7 explicit bits, so we lookup
  // log2(1 + m) in LOG2F_1_PLUS_M table using `m` as key.

  // Get the 7-bit mantissa directly as the table index
  uint16_t m = x_bits.get_mantissa();

  // Get unbiased exponent
  e += x_u >> FPBits::FRACTION_LEN;

  return fputil::cast<bfloat16>(static_cast<float>(e) + LOG2F_1_PLUS_M[m]);
}

} // namespace math
} // namespace LIBC_NAMESPACE_DECL

#endif // LLVM_LIBC_SRC___SUPPORT_MATH_LOG2BF16_H
