//===-- Implementation header for cbrtf16 ----------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIBC_SRC___SUPPORT_MATH_CBRTF16_H
#define LLVM_LIBC_SRC___SUPPORT_MATH_CBRTF16_H

#include "include/llvm-libc-macros/float16-macros.h"

#ifdef LIBC_TYPES_HAS_FLOAT16

#include "src/__support/FPUtil/FEnvImpl.h"
#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/rounding_mode.h"
#include "src/__support/macros/config.h"
#include "src/__support/macros/optimization.h"

namespace LIBC_NAMESPACE_DECL {

namespace math {

LIBC_INLINE constexpr float16 cbrtf16(float16 x) {
  // look up table for 2^(i/3) for i = 0, 1, 2 in single precision
  constexpr float CBRT2[3] = {0x1p0f, 0x1.428a3p0f, 0x1.965feap0f};

  // degree-4 polynomials approximation of ((1 + x)^(1/3) - 1)/x for 0 <= x <= 1
  // generated by Sollya with:
  // > display=hexadecimal;
  // for i from 0 to 15 do {
  //   P = fpminimax(((1 + x)^(1/3) - 1)/x, 4, [|SG...|], [i/16, (i + 1)/16]);
  //   print("{", coeff(P, 0), ",", coeff(P, 1), ",", coeff(P, 2), ",",
  //         coeff(P, 3), coeff(P, 4),"},");
  // };
  // Then (1 + x)^(1/3) ~ 1 + x * P(x).
  // For example: for 0 <= x <= 1/8:
  // P(x) = 0x1.555556p-2 + x * (-0x1.c71d38p-4 + x * (0x1.f9b95ap-5 + x *
  // (-0x1.4ebe18p-5 + x * 0x1.9ca9d2p-6)))
  constexpr float COEFFS[16][5] = {
      {0x1.555556p-2f, -0x1.c71ea4p-4f, 0x1.faa5f2p-5f, -0x1.64febep-5f,
       0x1.733a46p-5f},
      {0x1.55554ep-2f, -0x1.c715f6p-4f, 0x1.f88a9ep-5f, -0x1.4456e8p-5f,
       0x1.5b5ef2p-6f},
      {0x1.555508p-2f, -0x1.c6f404p-4f, 0x1.f56b7ap-5f, -0x1.33cff8p-5f,
       0x1.18f146p-6f},
      {0x1.5553fcp-2f, -0x1.c69bacp-4f, 0x1.efed98p-5f, -0x1.204706p-5f,
       0x1.c90976p-7f},
      {0x1.55517p-2f, -0x1.c5f996p-4f, 0x1.e85932p-5f, -0x1.0c0c0ep-5f,
       0x1.77c766p-7f},
      {0x1.554c96p-2f, -0x1.c501d2p-4f, 0x1.df0fc4p-5f, -0x1.f067f2p-6f,
       0x1.380ab8p-7f},
      {0x1.55448cp-2f, -0x1.c3ab1ep-4f, 0x1.d45876p-5f, -0x1.ca3988p-6f,
       0x1.04f38ap-7f},
      {0x1.5538aap-2f, -0x1.c1f886p-4f, 0x1.c8b11p-5f, -0x1.a6a16cp-6f,
       0x1.b847c2p-8f},
      {0x1.55278ap-2f, -0x1.bfd538p-4f, 0x1.bbde6p-5f, -0x1.846a8cp-6f,
       0x1.73bfcp-8f},
      {0x1.5511dp-2f, -0x1.bd6c88p-4f, 0x1.af0a3ap-5f, -0x1.660852p-6f,
       0x1.3dbe34p-8f},
      {0x1.54f82ap-2f, -0x1.bada56p-4f, 0x1.a2aa0ep-5f, -0x1.4b8c2ap-6f,
       0x1.13379cp-8f},
      {0x1.54d512p-2f, -0x1.b7a936p-4f, 0x1.94b91ep-5f, -0x1.30792cp-6f,
       0x1.d7883cp-9f},
      {0x1.54a8d8p-2f, -0x1.b3fde2p-4f, 0x1.861aeep-5f, -0x1.169484p-6f,
       0x1.92b4cap-9f},
      {0x1.548126p-2f, -0x1.b0f4a8p-4f, 0x1.7af574p-5f, -0x1.04644ep-6f,
       0x1.662fb6p-9f},
      {0x1.544b9p-2f, -0x1.ad2124p-4f, 0x1.6dd75p-5f, -0x1.e0cbecp-7f,
       0x1.387692p-9f},
      {0x1.5422c6p-2f, -0x1.aa61bp-4f, 0x1.64f4bap-5f, -0x1.c742b2p-7f,
       0x1.1cf15ap-9f},
  };

  using FPBits = fputil::FPBits<float16>;
  using FloatBits = fputil::FPBits<float>;

  FPBits x_bits(x);

  uint16_t x_u = x_bits.uintval();
  uint16_t x_abs = x_u & 0x7fff;
  uint32_t sign_bit = static_cast<uint32_t>(x_bits.is_neg())
                      << FloatBits::EXP_LEN;

  // cbrtf16(0) = 0, cbrtf16(NaN) = NaN
  if (LIBC_UNLIKELY(x_abs == 0 || x_abs >= 0x7C00)) {
    if (x_bits.is_signaling_nan()) {
      fputil::raise_except(FE_INVALID);
      return FPBits::quiet_nan().uintval();
    }
    return x;
  }

  float xf = static_cast<float>(x);
  FloatBits xf_bits(xf);

  // for single precision float, x_e_biased = x_e + 127
  // since x_e / 3 will round to 0, we will get incorrect
  // results for x_e < 0 and x mod 3 != 0, so we take x_e_biased
  // which is always positive.
  // to calculate the correct biased exponent of the result,
  // we need to calculate the exponent as:
  // out_e = floor(x_e / 3) + 127
  // now, floor((x_e_biased-1) / 3) = floor((x_e + 127 - 1) / 3)
  //                                = floor((x_e + 126) / 3)
  //                                = floor(x_e/3 + 42)
  //                                = floor(x_e/3) + 42
  // => out_e = (floor((x_e_biased-1) / 3) - 42) + 127
  // => out_e = (x_e_biased-1) / 3 + (127 - 42);
  uint32_t x_e_biased = xf_bits.get_biased_exponent();
  uint32_t out_e = (x_e_biased - 1) / 3 + (127 - 42);
  uint32_t shift_e = (x_e_biased - 1) % 3;

  // set x_m = 2^(x_e % 3) * (1 + mantissa)
  uint32_t x_m = xf_bits.get_mantissa();

  // use the leading 4 bits for look up table
  unsigned idx = static_cast<unsigned>(x_m >> (FloatBits::FRACTION_LEN - 4));

  x_m |= static_cast<uint32_t>(FloatBits::EXP_BIAS) << FloatBits::FRACTION_LEN;

  float x_reduced = FloatBits(x_m).get_val();
  float dx = x_reduced - 1.0f;

  float dx_sq = dx * dx;

  // c0 =  1 + x * a0
  float c0 = fputil::multiply_add(dx, COEFFS[idx][0], 1.0f);
  // c1 = a1 + x * a2
  float c1 = fputil::multiply_add(dx, COEFFS[idx][2], COEFFS[idx][1]);
  // c2 = a3 + x * a4
  float c2 = fputil::multiply_add(dx, COEFFS[idx][4], COEFFS[idx][3]);
  // we save a multiply_add operation by decreasing the polynomial degree by 2
  // i.e. using a degree-4 polynomial instead of degree 6.

  float dx_4 = dx_sq * dx_sq;

  // p0 = c0 + x^2 * c1
  // p0 = (1 + x * a0) + x^2 * (a1 + x * a2)
  // p0 = 1 + x * a0 + x^2 * a1 + x^3 * a2
  float p0 = fputil::multiply_add(dx_sq, c1, c0);

  // p1 = c2
  // p1 = x * a4
  float p1 = c2;

  // r = p0 + x^4 * p1
  // r = (1 + x * a0 + x^2 * a1 + x^3 * a2) + x^4 (x * a4)
  // r = 1 + x * a0 + x^2 * a1 + x^3 * a2 + x^5 * a4
  // r = 1 + x * (a0 + a1 * x + a2 * x^2 + a3 * x^3 + a4 * x^4)
  // r = 1 + x * P(x)
  float r = fputil::multiply_add(dx_4, p1, p0) * CBRT2[shift_e];

  uint32_t r_m = FloatBits(r).get_mantissa();
  // for float, mantissa is 23 bits (instead of 52 for double)
  // check if the output is exact. To be exact, the smallest 1-bit of the
  // output has to be at least 2^-7 or higher. So we check the lowest 15 bits
  // to see if they are within 2^(-23 + 3) errors from all zeros, then the
  // result cube root is exact.
  if (LIBC_UNLIKELY(((r_m + 4) & 0x7fff) <= 8)) {
    if ((r_m & 0x7fff) <= 4)
      r_m &= 0xffff'ffe0;
    else
      r_m = (r_m & 0xffff'ffe0) + 0x20; // Round up to next multiple of 0x20
    fputil::clear_except_if_required(FE_INEXACT);
    // TODO: investigate this "hack"
  } else if (LIBC_UNLIKELY(fputil::fenv_is_round_up()) &&
             x_bits.get_mantissa() == 0x0253U) {
    r_m -= 1 + x_bits.is_neg();
  }

  uint32_t r_bits = r_m | (static_cast<uint32_t>(out_e | sign_bit)
                           << FloatBits::FRACTION_LEN);
  return static_cast<float16>(FloatBits(r_bits).get_val());
}

} // namespace math
} // namespace LIBC_NAMESPACE_DECL

#endif // LIBC_TYPES_HAS_FLOAT16

#endif // LLVM_LIBC_SRC___SUPPORT_MATH_CBRTF16_H
