//===-- Implementation header for BFloat16 log10(x) function ----*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIBC_SRC___SUPPORT_MATH_LOG10BF16_H
#define LLVM_LIBC_SRC___SUPPORT_MATH_LOG10BF16_H

#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/bfloat16.h"
#include "src/__support/FPUtil/cast.h"
#include "src/__support/FPUtil/except_value_utils.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/rounding_mode.h"
#include "src/__support/common.h"
#include "src/__support/macros/config.h"
#include "src/__support/macros/optimization.h"

namespace LIBC_NAMESPACE_DECL {

namespace math {

// Generated by Sollya with the following commands:
//   > display = hexadecimal;
//   > round(log10(2), SG, RN);
static constexpr float LOG10F_2 = 0x1.344136p-2f;

// Generated by Sollya with the following commands:
//   > display = hexadecimal;
//   > for i from 0 to 127 do print(round(log(1 + i * 2^-7), SG, RN));
static constexpr float LOG10F_1_PLUS_M[128] = {
    0x0.0p0f,       0x1.bafd48p-9f, 0x1.b9476ap-8f, 0x1.49b086p-7f,
    0x1.b5e908p-7f, 0x1.10a83ap-6f, 0x1.45f4f6p-6f, 0x1.7adc3ep-6f,
    0x1.af5f92p-6f, 0x1.e3806ap-6f, 0x1.0ba01ap-5f, 0x1.25502cp-5f,
    0x1.3ed11ap-5f, 0x1.58238ep-5f, 0x1.714834p-5f, 0x1.8a3faep-5f,
    0x1.a30a9ep-5f, 0x1.bba9ap-5f,  0x1.d41d52p-5f, 0x1.ec6648p-5f,
    0x1.02428cp-4f, 0x1.0e3d2ap-4f, 0x1.1a2344p-4f, 0x1.25f522p-4f,
    0x1.31b306p-4f, 0x1.3d5d34p-4f, 0x1.48f3eep-4f, 0x1.547774p-4f,
    0x1.5fe804p-4f, 0x1.6b45ep-4f,  0x1.76914p-4f,  0x1.81ca64p-4f,
    0x1.8cf184p-4f, 0x1.9806dap-4f, 0x1.a30a9ep-4f, 0x1.adfd08p-4f,
    0x1.b8de4ep-4f, 0x1.c3aea4p-4f, 0x1.ce6e42p-4f, 0x1.d91d58p-4f,
    0x1.e3bc1ap-4f, 0x1.ee4abap-4f, 0x1.f8c968p-4f, 0x1.019c2ap-3f,
    0x1.06cbd6p-3f, 0x1.0bf3dp-3f,  0x1.11143p-3f,  0x1.162d08p-3f,
    0x1.1b3e72p-3f, 0x1.204882p-3f, 0x1.254b4ep-3f, 0x1.2a46e8p-3f,
    0x1.2f3b6ap-3f, 0x1.3428e2p-3f, 0x1.390f68p-3f, 0x1.3def0ep-3f,
    0x1.42c7e8p-3f, 0x1.479a08p-3f, 0x1.4c658p-3f,  0x1.512a64p-3f,
    0x1.55e8c6p-3f, 0x1.5aa0b4p-3f, 0x1.5f5244p-3f, 0x1.63fd86p-3f,
    0x1.68a288p-3f, 0x1.6d415ep-3f, 0x1.71da18p-3f, 0x1.766cc4p-3f,
    0x1.7af974p-3f, 0x1.7f8036p-3f, 0x1.84011ap-3f, 0x1.887c2ep-3f,
    0x1.8cf184p-3f, 0x1.916128p-3f, 0x1.95cb28p-3f, 0x1.9a2f96p-3f,
    0x1.9e8e7cp-3f, 0x1.a2e7e8p-3f, 0x1.a73beap-3f, 0x1.ab8a9p-3f,
    0x1.afd3e4p-3f, 0x1.b417f4p-3f, 0x1.b856dp-3f,  0x1.bc908p-3f,
    0x1.c0c514p-3f, 0x1.c4f496p-3f, 0x1.c91f14p-3f, 0x1.cd4498p-3f,
    0x1.d1653p-3f,  0x1.d580e6p-3f, 0x1.d997c8p-3f, 0x1.dda9dep-3f,
    0x1.e1b734p-3f, 0x1.e5bfd6p-3f, 0x1.e9c3cep-3f, 0x1.edc328p-3f,
    0x1.f1bdeep-3f, 0x1.f5b42ap-3f, 0x1.f9a5e8p-3f, 0x1.fd933p-3f,
    0x1.00be06p-2f, 0x1.02b044p-2f, 0x1.04a054p-2f, 0x1.068e4p-2f,
    0x1.087a08p-2f, 0x1.0a63b4p-2f, 0x1.0c4b46p-2f, 0x1.0e30c4p-2f,
    0x1.101432p-2f, 0x1.11f594p-2f, 0x1.13d4fp-2f,  0x1.15b24ap-2f,
    0x1.178da6p-2f, 0x1.196706p-2f, 0x1.1b3e72p-2f, 0x1.1d13ecp-2f,
    0x1.1ee778p-2f, 0x1.20b91ap-2f, 0x1.2288d8p-2f, 0x1.2456b4p-2f,
    0x1.2622bp-2f,  0x1.27ecd4p-2f, 0x1.29b522p-2f, 0x1.2b7b9ep-2f,
    0x1.2d404cp-2f, 0x1.2f032cp-2f, 0x1.30c448p-2f, 0x1.32839ep-2f,
};

constexpr fputil::ExceptValues<bfloat16, 4> EXPBF16_EXCEPTS = {{
    // x = 0x4120 (10.0)
    {0x4120U, 0x3F80U, 0U, 0U, 0U},
    // x = 0x42C8 (100.0)
    {0x42C8U, 0x4000U, 0U, 0U, 0U},
    // x =0x447A (1000.0)
    {0x447AU, 0x4040U, 0U, 0U, 0U},
}};

LIBC_INLINE static bfloat16 log10bf16(bfloat16 x) {
  using FPBits = fputil::FPBits<bfloat16>;
  FPBits x_bits(x);

  uint16_t x_u = x_bits.uintval();

  // If x <= 0, or x is 1, or x is +inf, or x is NaN.
  if (LIBC_UNLIKELY(x_u == 0U || x_u == 0x3f80U || x_u >= 0x7f80U)) {
    // log(NaN) = NaN
    if (x_bits.is_nan()) {
      if (x_bits.is_signaling_nan()) {
        fputil::raise_except_if_required(FE_INVALID);
        return FPBits::quiet_nan().get_val();
      }

      return x;
    }

    // log(+/-0) = âˆ’inf
    if ((x_u & 0x7fffU) == 0U) {
      fputil::raise_except_if_required(FE_DIVBYZERO);
      return FPBits::inf(Sign::NEG).get_val();
    }

    // log(1) = 0
    if (x_u == 0x3f80U)
      return FPBits::zero().get_val();

    // x < 0
    if (x_u > 0x8000U) {
      fputil::set_errno_if_required(EDOM);
      fputil::raise_except_if_required(FE_INVALID);
      return FPBits::quiet_nan().get_val();
    }

    // log(+inf) = +inf
    return FPBits::inf().get_val();
  }

  if (fputil::fenv_is_round_up()) {
    if (auto r = EXPBF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
      return r.value();
  }

  int e = -FPBits::EXP_BIAS;

  // When x is subnormal, normalize it.
  if ((x_u & FPBits::EXP_MASK) == 0U) {
    // Can't pass an integer to fputil::cast directly.
    constexpr float NORMALIZE_EXP = 1U << FPBits::FRACTION_LEN;
    x_bits = FPBits(x_bits.get_val() * fputil::cast<bfloat16>(NORMALIZE_EXP));
    x_u = x_bits.uintval();
    e -= FPBits::FRACTION_LEN;
  }

  // To compute log10(x), we perform the following range reduction:
  //   x = 2^e * (1 + m),
  //   log10(x) = e * log10(2) + log10(1 + m).
  // for BFloat16, mantissa is at most 7 explicit bits, so we lookup
  // log10(1 + m) in LOG10F_1_PLUS_M table using `m` as key.

  // Get the 7-bit mantissa directly as the table index
  uint16_t m = x_bits.get_mantissa();

  // Get unbiased exponent
  e += x_u >> FPBits::FRACTION_LEN;

  return fputil::cast<bfloat16>(fputil::multiply_add(
      static_cast<float>(e), LOG10F_2, LOG10F_1_PLUS_M[m]));
}

} // namespace math

} // namespace LIBC_NAMESPACE_DECL

#endif // LLVM_LIBC_SRC___SUPPORT_MATH_LOG10BF16_H
