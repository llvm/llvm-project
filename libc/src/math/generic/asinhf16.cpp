//===-- Half-precision asinhf16(x) function --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception.
//
//
//===----------------------------------------------------------------------===//

#include "src/math/asinhf16.h"
#include "src/math/generic/explogxf.h"
#include "src/__support/FPUtil/except_value_utils.h"
#include "src/__support/FPUtil/generic/sqrt.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/common.h"
#include "src/__support/macros/config.h"
#include "src/__support/macros/properties/types.h"

namespace LIBC_NAMESPACE_DECL {

#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
static constexpr size_t N_EXCEPTS = 8;

static constexpr fputil::ExceptValues<float16, N_EXCEPTS> ASINHF16_EXCEPTS{{
    // (input, RZ output, RU offset, RD offset, RN offset)
    {0x3769, 0x372A, 1, 0, 1},
    {0x3B5B, 0x3A96, 1, 0, 0},
    {0x4B1F, 0x42B3, 1, 0, 0},
    {0x4C9B, 0x4336, 1, 0, 1},
    {0xB769, 0xB72A, 0, 1, 1},
    {0xBB5B, 0xBA96, 0, 1, 0},
    {0xCB1F, 0xC2B3, 0, 1, 0},
    {0xCC9B, 0xC336, 0, 1, 1}
}};
#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS

LLVM_LIBC_FUNCTION(float16, asinhf16, (float16 x)) {
  using FPBits = fputil::FPBits<float16>;
  FPBits xbits(x);

  float x_d = x;
  uint16_t x_u = xbits.uintval();
  uint16_t x_abs = x_u & 0x7fff;

  if (LIBC_UNLIKELY(xbits.is_inf_or_nan())) {
    if (xbits.is_signaling_nan()) {
      fputil::raise_except_if_required(FE_INVALID);
      return FPBits::quiet_nan().get_val();
    }

    return x;
  }

#ifndef LIBC_MATH_HAS_SKIP_ACCURATE_PASS
  // Handle exceptional values
  if (auto r = ASINHF16_EXCEPTS.lookup(x_u); LIBC_UNLIKELY(r.has_value()))
    return r.value();
#endif // !LIBC_MATH_HAS_SKIP_ACCURATE_PASS

  const float SIGN[2] = {1.0f, -1.0f};
  float x_sign = SIGN[x_u >> 15];

  // |x| <= 0.25
  if (LIBC_UNLIKELY(x_abs <= 0x3400)) {
    if (LIBC_UNLIKELY(x_abs == 0))
      return x;
    if (LIBC_UNLIKELY((fputil::get_round() == FE_UPWARD) &&
                      (x_u >= 0x8401) && (x_u <= 0x90E6)))
      return static_cast<float16>(x_d + 0x1p-24f);

    float x_sq = x_d * x_d;
    // Generated by Sollya with:
    // > P = fpminimax(asinh(x)/x, [|0, 2, 4, 6, 8|], [|SG...|],[0, 2^-2]);
    float p = fputil::polyeval(x_sq, 1.0f, -0x1.555556p-3f, 0x1.3334dep-4f,
                               -0x1.6f3e2p-5f, 0x1.51d012p-5f);

    return static_cast<float16>(fputil::multiply_add(x_d, p, 0.0f));
  }

  // General case: asinh(x) = ln(x + sqrt(x^2 + 1))
  float sqrt_term = fputil::sqrt<float>(fputil::multiply_add(x_d, x_d, 1.0f));
  return fputil::cast<float16>(x_sign * log_eval(
    fputil::multiply_add(x_d, x_sign, sqrt_term)));
}
}
