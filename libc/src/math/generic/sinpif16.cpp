//===-- Half-precision sinpif function ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "src/math/sinpif16.h"
#include "src/__support/FPUtil/FEnvImpl.h"
#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/PolyEval.h"
#include "src/__support/FPUtil/cast.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/nearest_integer.h"
#include "src/__support/common.h"
#include "src/__support/macros/config.h"

namespace LIBC_NAMESPACE_DECL {

// Lookup table for sin(k * pi / 32) with k = 0, ..., 63.
// Table is generated with Sollya as follows:
// > display = hexadecimmal;
// > for k from 0 to 63 do { round(sin(k * pi/32), SG, RN); };
static constexpr float SIN_K_PI_OVER_32[64] = {
    0x0.0p0,        0x1.917a6cp-4,  0x1.8f8b84p-3,  0x1.294062p-2,
    0x1.87de2ap-2,  0x1.e2b5d4p-2,  0x1.1c73b4p-1,  0x1.44cf32p-1,
    0x1.6a09e6p-1,  0x1.8bc806p-1,  0x1.a9b662p-1,  0x1.c38b3p-1,
    0x1.d906bcp-1,  0x1.e9f416p-1,  0x1.f6297cp-1,  0x1.fd88dap-1,
    0x1p0,          0x1.fd88dap-1,  0x1.f6297cp-1,  0x1.e9f416p-1,
    0x1.d906bcp-1,  0x1.c38b3p-1,   0x1.a9b662p-1,  0x1.8bc806p-1,
    0x1.6a09e6p-1,  0x1.44cf32p-1,  0x1.1c73b4p-1,  0x1.e2b5d4p-2,
    0x1.87de2ap-2,  0x1.294062p-2,  0x1.8f8b84p-3,  0x1.917a6cp-4,
    0x0.0p0,        -0x1.917a6cp-4, -0x1.8f8b84p-3, -0x1.294062p-2,
    -0x1.87de2ap-2, -0x1.e2b5d4p-2, -0x1.1c73b4p-1, -0x1.44cf32p-1,
    -0x1.6a09e6p-1, -0x1.8bc806p-1, -0x1.a9b662p-1, -0x1.c38b3p-1,
    -0x1.d906bcp-1, -0x1.e9f416p-1, -0x1.f6297ep-1, -0x1.fd88dap-1,
    -0x1p0,         -0x1.fd88dap-1, -0x1.f6297cp-1, -0x1.e9f416p-1,
    -0x1.d906bcp-1, -0x1.c38b3p-1,  -0x1.a9b662p-1, -0x1.8bc806p-1,
    -0x1.6a09e6p-1, -0x1.44cf32p-1, -0x1.1c73b4p-1, -0x1.e2b5d4p-2,
    -0x1.87de2ap-2, -0x1.294062p-2, -0x1.8f8b84p-3, -0x1.917a6cp-4};

static LIBC_INLINE int32_t range_reduction(float x, float &y) {
  float kf = fputil::nearest_integer(x * 32);
  y = fputil::multiply_add<float>(x, 32.0, -kf);

  return static_cast<int32_t>(kf);
}

LLVM_LIBC_FUNCTION(float16, sinpif16, (float16 x)) {
  using FPBits = typename fputil::FPBits<float16>;
  FPBits xbits(x);

  uint16_t x_u = xbits.uintval();
  uint16_t x_abs = x_u & 0x7fff;

  // Range reduction:
  // For |x| > 1/32, we perform range reduction as follows:
  // Find k and y such that:
  //   x = (k + y) * 1/32
  //   k is an integer
  //   |y| < 0.5
  //
  // This is done by performing:
  //   k = round(x * 32)
  //   y = x * 32 - k
  //
  // Once k and y are computed, we then deduce the answer by the sine of sum
  // formula:
  //   sin(x * pi) = sin((k + y) * pi/32)
  //           = sin(k * pi/32) * cos(y * pi/32) + sin (y * pi/32) * cos (k *
  //           pi/32)
  // The values of sin(k * pi/32) and cos (k * pi/32) for k = 0...63 are
  // precomputed and stored using a vector of 64 single precision floats. sin(y
  // * pi/32) and cos(y * pi/32) are computed using degree-9 chebyshev
  // polynomials generated by Sollya.

  // For signed zeros
  if (LIBC_UNLIKELY(x_abs == 0U))
    return x;

  // Numbers greater or equal to 2^10 are integers, or infinity, or NaN
  if (LIBC_UNLIKELY(x_abs >= 0x6400)) {
    // Check for NaN or infinity values
    if (LIBC_UNLIKELY(x_abs >= 0x7c00)) {
      // If value is equal to infinity
      if (x_abs == 0x7c00) {
        fputil::set_errno_if_required(EDOM);
        fputil::raise_except_if_required(FE_INVALID);
      }

      return x + FPBits::quiet_nan().get_val();
    }
    return FPBits::zero(xbits.sign()).get_val();
  }

  float f32 = x;
  float y;
  int32_t k = range_reduction(f32, y);

  float sin_k = SIN_K_PI_OVER_32[k & 63];
  float cos_k = SIN_K_PI_OVER_32[(k + 16) & 63];

  // Recall;
  // sin(x * pi/32) = sin((k + y) * pi/32)
  // 		    = sin(y * pi/32) * cos(k * pi/32) + cos(y * pi/32) * sin(k *
  // pi/32) Recall, after range reduction, -0.5 <= y <= 0.5. For very small
  // values of y, calculating sin(y * p/32) can be inaccurate. Generating a
  // polynomial for sin(y * p/32)/y instead significantly reduces the relative
  // errors.
  float ysq = y * y;

  // Degree-6 minimax even polynomial for sin(y*pi/32)/y generated by Sollya
  // with: > Q = fpminimax(sin(y*pi/32)/y, [|0, 2, 4, 6|], [|SG...|], [0, 0.5]);
  float sin_y = y * fputil::polyeval(ysq, 0x1.921fb6p-4f, -0x1.4aeabcp-13f,
                                     0x1.a03354p-21f, -0x1.ad02d2p-20f);

  // Note that cosm1_y = cos(y*pi/32) - 1 = cos_y - 1
  // Derivation:
  // sin(x * pi) = sin((k + y) * pi/32)
  //             = sin_y * cos_k + cos_y * sin_k
  //             = cos_k * sin_y + sin_k * (1 + cos_y - 1)
  // Degree-6 minimax even polynomial for cos(y*pi/32) generated by Sollya with:
  // > P = fpminimax(cos(y*pi/32), [|0, 2, 4, 6|],[|1, SG...|], [0, 0.5]);
  float cosm1_y = ysq * fputil::polyeval(ysq, -0x1.3bd3ccp-8f, 0x1.03a61ap-18f,
                                         0x1.a6f7a2p-29f);

  if (LIBC_UNLIKELY(sin_y == 0 && sin_k == 0))
    return FPBits::zero(xbits.sign()).get_val();

  // Since, cosm1_y = cos_y - 1, therefore:
  // 	sin(x * pi) = cos_k * sin_y + sin_k + (cosm1_y * sin_k)
  return fputil::cast<float16>(fputil::multiply_add(
      sin_y, cos_k, fputil::multiply_add(cosm1_y, sin_k, sin_k)));
}
} // namespace LIBC_NAMESPACE_DECL
