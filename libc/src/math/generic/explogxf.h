//===-- Single-precision general exp/log functions ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIBC_SRC_MATH_GENERIC_EXPLOGXF_H
#define LLVM_LIBC_SRC_MATH_GENERIC_EXPLOGXF_H

#include "math_utils.h"
#include "src/__support/FPUtil/FEnvImpl.h"
#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/PolyEval.h"
#include "src/__support/FPUtil/nearest_integer.h"
#include "src/__support/common.h"
#include <src/__support/FPUtil/NearestIntegerOperations.h>

#include <errno.h>

namespace __llvm_libc {

static constexpr int EXP_bits_p = 5;
static constexpr int EXP_num_p = 1 << EXP_bits_p;
constexpr double mlp = EXP_num_p;
constexpr double mmld = -1.0 / mlp;

// Wolfram alpha: N[Table[2^x-1,{x,-16/32,15/32,1/32}],27]
// printf("%.13a,\n", d[i]);
extern const double EXP_2_POW[EXP_num_p];

// Look up table for bit fields of 2^(i/16) for i = 0..15, generated by Sollya
// with:
// > for i from 0 to 15 do printdouble(round(2^(i/16), D, RN));
inline constexpr int64_t EXP_2_M[16] = {
    0x3ff0000000000000, 0x3ff0b5586cf9890f, 0x3ff172b83c7d517b,
    0x3ff2387a6e756238, 0x3ff306fe0a31b715, 0x3ff3dea64c123422,
    0x3ff4bfdad5362a27, 0x3ff5ab07dd485429, 0x3ff6a09e667f3bcd,
    0x3ff7a11473eb0187, 0x3ff8ace5422aa0db, 0x3ff9c49182a3f090,
    0x3ffae89f995ad3ad, 0x3ffc199bdd85529c, 0x3ffd5818dcfba487,
    0x3ffea4afa2a490da};

constexpr int LOG_P1_BITS = 6;
constexpr int LOG_P1_SIZE = 1 << LOG_P1_BITS;

// N[Table[Log[2, 1 + x], {x, 0/64, 63/64, 1/64}], 40]
extern const double LOG_P1_LOG2[LOG_P1_SIZE];

// N[Table[1/(1 + x), {x, 0/64, 63/64, 1/64}], 40]
extern const double LOG_P1_1_OVER[LOG_P1_SIZE];

// Taylor series expansion for Log[2, 1 + x] splitted to EVEN AND ODD numbers
// K_LOG2_ODD starts from x^3
extern const double K_LOG2_ODD[4];
extern const double K_LOG2_EVEN[4];

// The algorithm represents exp(x) as
//   exp(x) = 2^(ln(2) * i) * 2^(ln(2) * j / NUM_P )) * exp(dx)
// where i integer value, j integer in range [-NUM_P/2, NUM_P/2).
// 2^(ln(2) * j / NUM_P )) is a table values: 1.0 + EXP_M
// exp(dx) calculates by taylor expansion.

// Inversion of ln(2). Multiplication by EXP_num_p due to sampling by 1 /
// EXP_num_p Precise value of the constant is not needed.
static constexpr double LN2_INV = 0x1.71547652b82fep+0 * EXP_num_p;

// log2(e) * 2^4
static constexpr double LOG2_E_4 = 0x1.71547652b82fep+4;

// LN2_HIGH + LN2_LOW = ln(2) with precision higher than double(ln(2))
// Minus sign is to use FMA directly.
static constexpr double LN2_HIGH = -0x1.62e42fefa0000p-1 / EXP_num_p;
static constexpr double LN2_LOW = -0x1.cf79abc9e3b3ap-40 / EXP_num_p;

// -log(2) * 2^(-4)
static constexpr double M_LN2_4_HI = -0x1.62e42fefa0000p-5;
static constexpr double M_LN2_4_LO = -0x1.cf79abc9e3b3ap-44;

struct exe_eval_result_t {
  // exp(x) = 2^MULT_POWER2 * mult_exp * (r + 1.0)
  // where
  //   MULT_POWER2 template parameter;
  //   mult_exp = 2^e;
  //   r in range [~-0.3, ~0.41]
  double mult_exp;
  double r;
};

// The function correctly calculates exp value with at least float precision
// in range not narrow than [-log(2^-150), 90]
template <int MULT_POWER2 = 0>
inline static exe_eval_result_t exp_eval(double x) {
  double ps_dbl = fputil::nearest_integer(LN2_INV * x);
  // Negative sign due to multiply_add optimization
  double mult_e1, ml;
  {
    int ps =
        static_cast<int>(ps_dbl) + (1 << (EXP_bits_p - 1)) +
        ((fputil::FPBits<double>::EXPONENT_BIAS + MULT_POWER2) << EXP_bits_p);
    int table_index = ps & (EXP_num_p - 1);
    fputil::FPBits<double> bs;
    bs.set_unbiased_exponent(ps >> EXP_bits_p);
    ml = EXP_2_POW[table_index];
    mult_e1 = bs.get_val();
  }
  double dx = fputil::multiply_add(ps_dbl, LN2_LOW,
                                   fputil::multiply_add(ps_dbl, LN2_HIGH, x));

  // Taylor series coefficients
  double pe = dx * fputil::polyeval(dx, 1.0, 0x1.0p-1, 0x1.5555555555555p-3,
                                    0x1.5555555555555p-5, 0x1.1111111111111p-7,
                                    0x1.6c16c16c16c17p-10);

  double r = fputil::multiply_add(ml, pe, pe) + ml;
  return {mult_e1, r};
}

// The function correctly calculates sinh(x) and cosh(x) by calculating exp(x)
// and exp(-x) simultaneously.
// To compute e^x, we perform the following range
// reduction: find hi, mid, lo such that:
//   x = (hi + mid) * log(2) + lo, in which
//     hi is an integer,
//     0 <= mid * 2^4 < 16 is an integer
//     -2^(-5) <= lo * log2(e) <= 2^-5.
// In particular,
//   hi + mid = round(x * log2(e) * 2^4) * 2^(-4).
// Then,
//   e^x = 2^(hi + mid) * e^lo = 2^hi * 2^mid * e^lo.
// 2^mid is stored in the lookup table EXP_2_M of 16 elements.
// e^lo is computed using a degree-6 minimax polynomial
// generated by Sollya:
//   e^lo ~ P(lo) = 1 + lo + c2 * lo^2 + ... + c6 * lo^6
//        = (1 + c2*lo^2 + c4*lo^4 + c6*lo^6) + lo * (1 + c3*lo^2 + c5*lo^4)
//        = P_even + lo * P_odd
// We perform 2^hi * 2^mid by simply add hi to the exponent field
// of 2^mid.
// To compute e^(-x), notice that:
//   e^(-x) = 2^(-(hi + mid)) * e^(-lo)
//          ~ 2^(-(hi + mid)) * P(-lo)
//          = 2^(-(hi + mid)) * (P_even - lo * P_odd)
// So:
//   sinh(x) = (e^x - e^(-x)) / 2
//           ~ 0.5 * (2^(hi + mid) * (P_even + lo * P_odd) -
//                    2^(-(hi + mid)) * (P_even - lo * P_odd))
//           = 0.5 * (P_even * (2^(hi + mid) - 2^(-(hi + mid))) +
//                    lo * P_odd * (2^(hi + mid) + 2^(-(hi + mid))))
// And similarly:
//   cosh(x) = (e^x + e^(-x)) / 2
//           ~ 0.5 * (P_even * (2^(hi + mid) + 2^(-(hi + mid))) +
//                    lo * P_odd * (2^(hi + mid) - 2^(-(hi + mid))))
// The main point of these formulas is that the expensive part of calculating
// the polynomials approximating lower parts of e^(x) and e^(-x) are shared
// and only done once.
template <bool is_sinh> static inline double exp_pm_eval(float x) {
  double xd = static_cast<double>(x);

  // round(x * log2(e) * 2^4)
  double kd = fputil::nearest_integer(LOG2_E_4 * xd);

  // k_p = round(x * log2(e) * 2^4)
  int k_p = static_cast<int>(kd);
  // k_m = round(-x * log2(e) * 2^4)
  int k_m = -k_p;

  // hi = floor(kf * 2^(-4))
  // exp_hi = shift hi to the exponent field of double precision.
  int64_t exp_hi_p = static_cast<int64_t>((k_p >> 4))
                     << fputil::FloatProperties<double>::MANTISSA_WIDTH;
  int64_t exp_hi_m = static_cast<int64_t>((k_m >> 4))
                     << fputil::FloatProperties<double>::MANTISSA_WIDTH;
  // mh = 2^hi * 2^mid
  // mh_bits = bit field of mh
  int64_t mh_bits_p = EXP_2_M[k_p & 15] + exp_hi_p;
  int64_t mh_bits_m = EXP_2_M[k_m & 15] + exp_hi_m;
  double mh_p = fputil::FPBits<double>(uint64_t(mh_bits_p)).get_val();
  double mh_m = fputil::FPBits<double>(uint64_t(mh_bits_m)).get_val();
  // mh_sum = 2^(hi + mid) + 2^(-(hi + mid))
  double mh_sum = mh_p + mh_m;
  // mh_diff = 2^(hi + mid) - 2^(-(hi + mid))
  double mh_diff = mh_p - mh_m;

  // dx = lo = x - (hi + mid) * log(2)
  double dx = fputil::multiply_add(kd, M_LN2_4_LO,
                                   fputil::multiply_add(kd, M_LN2_4_HI, xd));
  double dx2 = dx * dx;

  // Polynomials generated by Sollya with:
  // Q = fpminimax(expm1(x)/x, 5, [|1, D...|], [-1/32*log(2), 1/32*log(2)]);
  // Then:
  //   e^lo ~ P(dx) = 1 + dx + COEFFS[0] * dx^2 + ... + COEFFS[4] * dx^6.
  constexpr double COEFFS[5] = {0x1.fffffffffffep-2, 0x1.55555554ad3f3p-3,
                                0x1.55555557179cap-5, 0x1.111228f3478c9p-7,
                                0x1.6c161beccc69dp-10};
  // c0 = 1 + COEFFS[0] * lo^2
  double c0 = fputil::multiply_add(dx2, COEFFS[0], 1.0);
  // c1 = 1 + COEFFS[0] * lo^2
  double c1 = fputil::multiply_add(dx2, COEFFS[1], 1.0);
  // c2 = COEFFS[2] + COEFFS[4] * lo^2
  double c2 = fputil::multiply_add(dx2, COEFFS[4], COEFFS[2]);
  double dx4 = dx2 * dx2;
  // P_even = c0 + c2 * lo^4
  //        = (1 + COEFFS[0] * lo^2) + lo^4 * (COEFFS[2] + COEFFS[4] * lo^2)
  //        = 1 + COEFFS[0] * lo^2 + COEFFS[2] * lo^4 + COEFFS[4] * lo^6
  double p_even = fputil::multiply_add(dx4, c2, c0);
  // P_odd = c1 + COEFFS[3] * lo^4
  //       = 1 + COEFFS[1] * lo^2 + COEFFS[3] * lo^4
  double p_odd = fputil::multiply_add(dx4, COEFFS[3], c1);

  double r;
  if constexpr (is_sinh)
    r = fputil::multiply_add(dx * mh_sum, p_odd, p_even * mh_diff);
  else
    r = fputil::multiply_add(dx * mh_diff, p_odd, p_even * mh_sum);
  return 0.5 * r;
}

// x should be positive, normal finite value
inline static double log2_eval(double x) {
  using FPB = fputil::FPBits<double>;
  FPB bs(x);

  double result = 0;
  result += bs.get_exponent();

  int p1 =
      (bs.get_mantissa() >> (FPB::FloatProp::MANTISSA_WIDTH - LOG_P1_BITS)) &
      (LOG_P1_SIZE - 1);

  bs.bits &= FPB::FloatProp::MANTISSA_MASK >> LOG_P1_BITS;
  bs.set_unbiased_exponent(FPB::FloatProp::EXPONENT_BIAS);
  double dx = (bs.get_val() - 1.0) * LOG_P1_1_OVER[p1];

  // Taylor series for log(2,1+x)
  double c1 = fputil::multiply_add(dx, K_LOG2_ODD[0], K_LOG2_EVEN[0]);
  double c2 = fputil::multiply_add(dx, K_LOG2_ODD[1], K_LOG2_EVEN[1]);
  double c3 = fputil::multiply_add(dx, K_LOG2_ODD[2], K_LOG2_EVEN[2]);
  double c4 = fputil::multiply_add(dx, K_LOG2_ODD[3], K_LOG2_EVEN[3]);

  // c0 = dx * (1.0 / ln(2)) + LOG_P1_LOG2[p1]
  double c0 = fputil::multiply_add(dx, 0x1.71547652b82fep+0, LOG_P1_LOG2[p1]);
  result += __llvm_libc::fputil::polyeval(dx * dx, c0, c1, c2, c3, c4);
  return result;
}

// x should be positive, normal finite value
inline static double log_eval(double x) {
  // ln(x) = log[2,x] * ln(2)
  return log2_eval(x) * 0x1.62e42fefa39efp-1;
}

} // namespace __llvm_libc

#endif // LLVM_LIBC_SRC_MATH_GENERIC_EXPLOGXF_H
