//===-- Single-precision 2^x function -------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "src/math/exp2f.h"
#include "src/__support/FPUtil/FEnvImpl.h"
#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/PolyEval.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/nearest_integer.h"
#include "src/__support/common.h"

#include <errno.h>

namespace __llvm_libc {

constexpr uint32_t exval1 = 0x3b42'9d37U;
constexpr uint32_t exval2 = 0xbcf3'a937U;
constexpr uint32_t exval_mask = exval1 & exval2;

// Look up table for bit fields of 2^(i/16) for i = 0..15, generated by Sollya
// with:
// > for i from 0 to 15 do printdouble(round(2^(i/16), D, RN));
constexpr int64_t EXP_2_M[16] = {
    0x3ff0000000000000, 0x3ff0b5586cf9890f, 0x3ff172b83c7d517b,
    0x3ff2387a6e756238, 0x3ff306fe0a31b715, 0x3ff3dea64c123422,
    0x3ff4bfdad5362a27, 0x3ff5ab07dd485429, 0x3ff6a09e667f3bcd,
    0x3ff7a11473eb0187, 0x3ff8ace5422aa0db, 0x3ff9c49182a3f090,
    0x3ffae89f995ad3ad, 0x3ffc199bdd85529c, 0x3ffd5818dcfba487,
    0x3ffea4afa2a490da};

LLVM_LIBC_FUNCTION(float, exp2f, (float x)) {
  using FPBits = typename fputil::FPBits<float>;
  FPBits xbits(x);

  uint32_t x_u = xbits.uintval();
  uint32_t x_abs = x_u & 0x7fff'ffffU;

  // |x| < 2^-25
  if (unlikely(x_abs <= 0x3280'0000U)) {
    return 1.0f + x;
  }

  // // When |x| >= 128, or x is nan
  if (unlikely(x_abs >= 0x4300'0000U)) {

    // x >= 128
    if (!xbits.get_sign()) {
      // x is finite
      if (x_u < 0x7f80'0000U) {
        int rounding = fputil::get_round();
        if (rounding == FE_DOWNWARD || rounding == FE_TOWARDZERO)
          return static_cast<float>(FPBits(FPBits::MAX_NORMAL));

        errno = ERANGE;
      }
      // x is +inf or nan
      return x + FPBits::inf().get_val();
    }
    // x <= -150
    if (x_u >= 0xc316'0000U) {
      // exp(-Inf) = 0
      if (xbits.is_inf())
        return 0.0f;
      // exp(nan) = nan
      if (xbits.is_nan())
        return x;
      if (fputil::get_round() == FE_UPWARD)
        return FPBits(FPBits::MIN_SUBNORMAL).get_val();
      if (x != 0.0f)
        errno = ERANGE;
      return 0.0f;
    }
  }

  // Check exceptional values.
  if (unlikely(x_u & exval_mask) == exval_mask) {
    if (unlikely(x_u == exval1)) { // x = 0x1.853a6ep-9f
      if (fputil::get_round() == FE_TONEAREST)
        return 0x1.00870ap+0f;
    } else if (unlikely(x_u == exval2)) { // x = -0x1.e7526ep-6f
      if (fputil::get_round() == FE_TONEAREST)
        return 0x1.f58d62p-1f;
    }
  }

  // For -150 < x < 128, to compute 2^x, we perform the following range
  // reduction: find hi, mid, lo such that:
  //   x = hi + mid + lo, in which
  //     hi is an integer,
  //     0 <= mid * 2^4 < 16 is an integer
  //     -2^(-5) <= lo <= 2^-5.
  // In particular,
  //   hi + mid = round(x * 2^4) * 2^(-4).
  // Then,
  //   2^x = 2^(hi + mid + lo) = 2^hi * 2^mid * 2^lo.
  // 2^mid is stored in the lookup table EXP_2_M of 16 elements.
  // 2^lo is computed using a degree-6 minimax polynomial
  // generated by Sollya.
  // We perform 2^hi * 2^lo by simply add hi to the exponent field
  // of 2^mid.

  // kf = (hi + mid) * 2^4 = round(x * 2^4)
  float kf = fputil::nearest_integer(x * 16.0f);
  // dx = lo = x - (hi + mid) = x - kf * 2^(-4)
  double dx = fputil::multiply_add(-0x1.0p-4f, kf, x);

  int k = static_cast<int>(kf);
  // hi = floor(kf * 2^(-4))
  // exp_hi = shift hi to the exponent field of double precision.
  int64_t exp_hi = static_cast<int64_t>(k >> 4)
                   << fputil::FloatProperties<double>::MANTISSA_WIDTH;
  // mh = 2^hi * 2^mid
  // mh_bits = bit field of mh
  int64_t mh_bits = EXP_2_M[k & 15] + exp_hi;
  double mh = fputil::FPBits<double>(uint64_t(mh_bits)).get_val();

  // Degree-5 polynomial approximating (2^x - 1)/x generating by Sollya with:
  // > P = fpminimax((2^x - 1)/x, 5, [|D...|], [-1/32. 1/32]);
  constexpr double COEFFS[6] = {0x1.62e42fefa39f3p-1,  0x1.ebfbdff82c57bp-3,
                                0x1.c6b08d6f2d7aap-5,  0x1.3b2ab6fc92f5dp-7,
                                0x1.5d897cfe27125p-10, 0x1.43090e61e6af1p-13};
  double dx_sq = dx * dx;
  double c1 = fputil::multiply_add(dx, COEFFS[1], COEFFS[0]);
  double c2 = fputil::multiply_add(dx, COEFFS[3], COEFFS[2]);
  double c3 = fputil::multiply_add(dx, COEFFS[5], COEFFS[4]);
  double p = fputil::polyeval(dx_sq, c1, c2, c3);
  // 2^x = 2^(hi + mid + lo)
  //     = 2^(hi + mid) * 2^lo
  //     ~ mh * (1 + lo * P(lo))
  //     = mh + (mh*lo) * P(lo)
  return fputil::multiply_add(p, dx * mh, mh);
}

} // namespace __llvm_libc
