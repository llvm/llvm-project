<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `toy.add` (toy::AddOp)

_Element-wise addition operation_

The "add" operation performs element-wise addition between two tensors.
The shapes of the tensor operands are expected to match.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 64-bit float values |
| `rhs` | tensor of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 64-bit float values |


### `toy.constant` (toy::ConstantOp)

_Constant_

Constant operation turns a literal into an SSA value. The data is attached
to the operation as an attribute. For example:

```mlir
  %0 = toy.constant dense<[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]>
                    : tensor<2x3xf64>
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::DenseElementsAttr</td><td>64-bit float elements attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 64-bit float values |


### `toy.func` (toy::FuncOp)

_User defined function operation_

The "toy.func" operation represents a user defined function. These are
callable SSA-region operations that contain toy computations.

Example:

```mlir
toy.func @main() {
  %0 = toy.constant dense<5.500000e+00> : tensor<f64>
  %1 = toy.reshape(%0 : tensor<f64>) to tensor<2x2xf64>
  toy.print %1 : tensor<2x2xf64>
  toy.return
}
```

Traits: `IsolatedFromAbove`

Interfaces: `ArgAndResultAttrsOpInterface`, `CallableOpInterface`, `FunctionOpInterface`, `Symbol`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr>
<tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr>
<tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr>
</table>


### `toy.generic_call` (toy::GenericCallOp)

_Generic call operation_

Syntax:

```
operation ::= `toy.generic_call` $callee `(` $inputs `)` attr-dict `:` functional-type($inputs, results)
```

Generic calls represent calls to a user defined function that needs to
be specialized for the shape of its arguments. The callee name is attached
as a symbol reference via an attribute. The arguments list must match the
arguments expected by the callee. For example:

```mlir
 %4 = toy.generic_call @my_func(%1, %3)
       : (tensor<2x3xf64>, tensor<2x3xf64>) -> tensor<*xf64>
```

This is only valid if a function named "my_func" exists and takes two
arguments.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inputs` | variadic of tensor of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 64-bit float values |


### `toy.mul` (toy::MulOp)

_Element-wise multiplication operation_

The "mul" operation performs element-wise multiplication between two
tensors. The shapes of the tensor operands are expected to match.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of 64-bit float values |
| `rhs` | tensor of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 64-bit float values |


### `toy.print` (toy::PrintOp)

_Print operation_

Syntax:

```
operation ::= `toy.print` $input attr-dict `:` type($input)
```

The "print" builtin operation prints a given input tensor, and produces
no results.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `input` | tensor of 64-bit float values |


### `toy.reshape` (toy::ReshapeOp)

_Tensor reshape operation_

Syntax:

```
operation ::= `toy.reshape` `(` $input `:` type($input) `)` attr-dict `to` type(results)
```

Reshape operation is transforming its input tensor into a new tensor with
the same number of elements but different shapes. For example:

```mlir
   %0 = toy.reshape (%arg1 : tensor<10xf64>) to tensor<5x2xf64>
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `input` | tensor of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | statically shaped tensor of 64-bit float values |


### `toy.return` (toy::ReturnOp)

_Return operation_

Syntax:

```
operation ::= `toy.return` ($input^ `:` type($input))? attr-dict
```

The "return" operation represents a return operation within a function.
The operation takes an optional tensor operand and produces no results.
The operand type must match the signature of the function that contains
the operation. For example:

```mlir
  toy.func @foo() -> tensor<2xf64> {
    ...
    toy.return %0 : tensor<2xf64>
  }
```

Traits: `AlwaysSpeculatableImplTrait`, `HasParent<FuncOp>`, `Terminator`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `input` | variadic of tensor of 64-bit float values |


### `toy.transpose` (toy::TransposeOp)

_Transpose operation_

Syntax:

```
operation ::= `toy.transpose` `(` $input `:` type($input) `)` attr-dict `to` type(results)
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `input` | tensor of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of 64-bit float values |

