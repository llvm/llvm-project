#!/usr/bin/env python3

# This tool helps matching dwarf dumps
# (= the output from running llvm-objdump --dwarf=frames),
# by address to function names (which are parsed from a normal objdump).
# The script is used for checking if .cfi_negate_ra_state CFIs
# are generated by BOLT the same way they are generated by LLVM.
# The script is called twice in unittests: once with the objdumps of
# the BOLT input binary, and once with the output binary from BOLT.
# We output the offsets of .cfi_negate_ra_state instructions from the
# function's start address to see that BOLT can generate them to the same
# locations.
# Because we check the location, this is only useful for testing without
# optimization flags, so `llvm-bolt input.exe -o output.exe`


import argparse
import subprocess
import sys
import re


class NameDwarfPair(object):
    def __init__(self, name, body):
        self.name = name
        self.body = body
        self.finalized = False

    def append(self, body_line):
        # only store elements into the body until the first whitespace line is encountered.
        if body_line.isspace():
            self.finalized = True
        if not self.finalized:
            self.body += body_line

    def print(self):
        print(self.name)
        print(self.body)

    def parse_negate_offsets(self):
        """
        Create a list of locations/offsets of the negate_ra_state CFIs in the
        dwarf entry. To find offsets for each, we match the DW_CFA_advance_loc
        entries, and sum up their values.
        """
        negate_offsets = []
        loc = 0
        # TODO: make sure this is not printed in hex
        re_advloc = r"DW_CFA_advance_loc: (\d+)"

        for line in self.body.splitlines():
            # if line matches advance_loc int
            match = re.search(re_advloc, line)
            if match:
                loc += int(match.group(1))
            if "DW_CFA_AARCH64_negate_ra_state" in line:
                negate_offsets.append(loc)

        self.negate_offsets = negate_offsets

    def __eq__(self, other):
        return self.name == other.name and self.negate_offsets == other.negate_offsets


def extract_function_addresses(objdump):
    """
    Parse and return address-to-name dictionary from objdump file.
    Function names in the objdump look like this:
        000123abc <foo>:
    We create a dict from the addr (000123abc), to the name (foo).
    """
    addr_name_dict = dict()
    re_function = re.compile(r"^([0-9a-fA-F]+)\s<(.*)>:$")
    with open(objdump, "r") as f:
        for line in f.readlines():
            match = re_function.match(line)
            if not match:
                continue
            m_addr = match.groups()[0]
            m_name = match.groups()[1]
            addr_name_dict[int(m_addr, 16)] = m_name

    return addr_name_dict


def match_dwarf_to_name(dwarfdump, addr_name_dict):
    """
    Parse dwarf dump, and match names to blocks using the dict from the objdump.
    Return a list of NameDwarfPairs.
    The matched lines look like this:
    000123 000456 000789 FDE cie=000000  pc=0123abc...0456def
    We do not have the function name for this, only the PC range it applies to.
    We match the pc=0123abc (the start address), and find the matching name from
    the addr_name_dict.
    The resultint NameDwarfPair will hold the lines this header applied to, and
    instead of the header with the addresses, it will just have the function name.
    """
    re_address_line = re.compile(r".*pc=([0-9a-fA-F]+)\.\.\.([0-9a-fA-F]+)")
    with open(dwarfdump, "r") as dw:
        functions = []
        for line in dw.readlines():
            match = re_address_line.match(line)
            if not match:
                if len(functions) > 0:
                    functions[-1].append(line)
                continue
            pc_start_address = match.groups()[0]
            name = addr_name_dict.get(int(pc_start_address, 16))
            functions.append(NameDwarfPair(name, ""))

        return functions


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("objdump", help="Objdump file")
    parser.add_argument(
        "dwarfdump", help="dwarf dump file created with 'llvm-objdump --dwarf=frames'"
    )
    parser.add_argument("function", help="Function to search CFIs in.")

    args = parser.parse_args()

    addr_name_dict = extract_function_addresses(args.objdump)
    functions = match_dwarf_to_name(args.dwarfdump, addr_name_dict)

    for f in functions:
        if f.name == args.function:
            f.parse_negate_offsets()
            print(f.negate_offsets)
            break
    else:
        print(f"{args.function} not found")
        exit(-1)


main()
