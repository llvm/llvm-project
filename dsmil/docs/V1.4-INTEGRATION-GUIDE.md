# DSLLVM v1.4 Security Depth Integration Guide

**Version**: 1.4.0
**Phase**: Security Depth (Phase 2)
**Date**: 2025-11-25
**Status**: Complete

---

## Executive Summary

DSLLVM v1.4 delivers **three integrated security features** for war-grade AI systems:

1. **Operational Stealth** (Feature 2.1): Low-signature execution in hostile environments
2. **Blue vs Red Simulation** (Feature 2.3): Compiler-level adversarial testing
3. **Threat Signatures** (Feature 2.2): Forensics-ready binaries

Together, these features provide defense-in-depth: **passive defense** (stealth), **active testing** (blue/red), and **forensics preparation** (signatures).

---

## Feature Integration Matrix

| Feature | Purpose | Deploy to Prod | Layer Integration | Output |
|---------|---------|----------------|-------------------|--------|
| **Stealth** | Reduce detectability | ✅ Yes (covert ops) | L5/L8 detectability | Binary |
| **Blue/Red** | Adversarial testing | ❌ NEVER (red only) | L5/L8/L9 blast radius | Analysis JSON |
| **Threat Sig** | Forensics prep | ✅ Yes (all builds) | L62 forensics/SIEM | Signature JSON |

---

## Integration Scenario 1: Covert Operations

**Mission**: Deploy sensor in hostile network, minimal detectability

### Step 1: Enable Stealth + Threat Signatures

```bash
dsmil-clang -fdsmil-mission-profile=covert_ops \
            -dsmil-threat-signature \
            -dsmil-threat-signature-output=sensor.sig.json \
            -O3 -o sensor_covert.bin sensor.c
```

**Result**:
- ✅ Stealth transformations applied (aggressive mode)
- ✅ Threat signature generated
- ✅ Ready for hostile deployment

### Step 2: Store Signature Securely

```bash
# Encrypt signature
ml-kem-encrypt --key=siem_pubkey sensor.sig.json > sensor.sig.enc

# Upload to Layer 62 SIEM
siem-upload --layer=62 --binary=sensor_covert.bin sensor.sig.enc
```

### Step 3: Deploy

```bash
# Deploy to hostile network
deploy-covert sensor_covert.bin --network=FIELD_OPS

# Characteristics:
# - Minimal telemetry (safety-critical only)
# - Constant-rate execution (100ms heartbeat)
# - Network I/O batched/delayed
# - Threat signature embedded for future forensics
```

### Step 4: Post-Mission Forensics

If binary found during incident:

```bash
# Extract signature from recovered binary
dsmil-extract-signature recovered.bin > recovered.sig.json

# Compare with known-good
siem-query --layer=62 --compare sensor.sig.json recovered.sig.json

# Result: "Match 98% - legitimate sensor"
```

---

## Integration Scenario 2: Development & Testing Cycle

**Mission**: Develop secure binary with continuous adversarial testing

### Step 1: Blue Build (Production)

```bash
dsmil-clang -fdsmil-role=blue \
            -fdsmil-mission-profile=blue_production \
            -dsmil-threat-signature \
            -dsmil-threat-signature-output=prod.sig.json \
            -O3 -o production.bin source.c
```

**Characteristics**:
- Full security enforcement
- CNSA 2.0 provenance
- Threat signature embedded
- Deploy: YES

### Step 2: Red Build (Testing)

```bash
dsmil-clang -fdsmil-role=red \
            -fdsmil-mission-profile=red_stress_test \
            -dsmil-red-output=red-analysis.json \
            -O3 -o test.bin source.c
```

**Characteristics**:
- Attack surface mapping
- Vulnerability injection points
- Blast radius tracking
- Deploy: NEVER

### Step 3: Run Red Team Scenarios

```bash
# Test validation bypass
DSMIL_RED_SCENARIOS="bypass_validation" ./test.bin

# Test buffer overflow
DSMIL_RED_SCENARIOS="trigger_overflow" ./test.bin

# Test all scenarios
DSMIL_RED_SCENARIOS="all" ./test.bin
```

### Step 4: Analyze Results

```bash
# Review attack surfaces
jq '.attack_surfaces[] | select(.blast_radius_score > 70)' red-analysis.json

# Output:
# {
#   "function": "process_user_input",
#   "layer": 7,
#   "blast_radius_score": 87,
#   "has_untrusted_input": true
# }
```

### Step 5: Fix Vulnerabilities

```c
// Before (high blast radius)
void process_user_input(const char *input) {
    execute_command(input);  // No validation!
}

// After (reduced blast radius)
DSMIL_ATTACK_SURFACE
void process_user_input(const char *input) {
    if (!validate_input(input)) {
        reject_input();
        return;
    }
    execute_command(sanitize(input));
}
```

### Step 6: Re-Test

```bash
# Rebuild red
dsmil-clang -fdsmil-role=red ... -o test_v2.bin source.c

# Re-run scenarios
DSMIL_RED_SCENARIOS="all" ./test_v2.bin

# Check blast radius reduction
jq '.attack_surfaces[] | select(.function=="process_user_input") | .blast_radius_score' \
   red-analysis-v2.json

# Output: 42 (reduced from 87)
```

### Step 7: Deploy Blue

```bash
# Blue build passes, deploy
deploy-to-production production.bin
```

---

## Integration Scenario 3: Border Operations with Fallback

**Mission**: Border surveillance with stealth fallback option

### Step 1: Build Both Variants

```bash
# Standard border ops
dsmil-clang -fdsmil-mission-profile=border_ops \
            -dsmil-threat-signature \
            -O3 -o border_standard.bin sensor.c

# Stealth variant (if threat escalates)
dsmil-clang -fdsmil-mission-profile=border_ops_stealth \
            -dsmil-threat-signature \
            -O3 -o border_stealth.bin sensor.c
```

### Step 2: Deploy Standard Initially

```bash
deploy-border border_standard.bin

# Characteristics:
# - Full telemetry
# - Normal operation
# - Observable for debugging
```

### Step 3: Escalate to Stealth if Needed

```bash
# Threat detected, switch to stealth
deploy-border border_stealth.bin --replace

# Characteristics:
# - Minimal telemetry
# - Reduced detectability
# - Harder to debug (acceptable trade-off)
```

### Step 4: Both Have Threat Signatures

```bash
# If either binary compromised, forensics can identify
siem-query --layer=62 --binary-hash=$(sha384sum suspicious.bin)

# Result: "Match: border_stealth.bin v1.2.3 - tampered"
```

---

## Integration Scenario 4: Supply Chain Verification

**Mission**: Verify vendor-provided "updated" binaries

### Step 1: Original Binary (Our Build)

```bash
dsmil-clang -dsmil-threat-signature \
            -dsmil-threat-signature-output=official_v1.0.sig.json \
            -O3 -o official_v1.0.bin source.c

# Store signature
siem-upload --layer=62 official_v1.0.sig.json
```

### Step 2: Vendor Provides "Update"

```
Vendor: "Here's your v1.1 with security patches"
File: vendor_v1.1.bin
```

### Step 3: Extract & Compare

```bash
# Extract signature from vendor binary
dsmil-extract-signature vendor_v1.1.bin > vendor.sig.json

# Compare with our v1.0
siem-query --layer=62 --compare official_v1.0.sig.json vendor.sig.json

# Result:
{
  "similarity_score": 0.73,
  "verdict": "SUSPICIOUS",
  "differences": [
    "CFG hash: 73% match (functions added/removed)",
    "Crypto patterns: ML-KEM-1024 missing",
    "Protocol schemas: Unknown protocol 'custom_telemetry' added"
  ],
  "recommendation": "REJECT - Significant deviation from known-good"
}
```

### Step 4: Decision

```
❌ REJECT vendor binary
✅ Rebuild from source with our toolchain
✅ Generate new threat signature
```

---

## Integration Scenario 5: Post-Incident Response

**Mission**: Investigate breach, identify compromised binaries

### Incident Timeline

**Day 0**: Breach detected
**Day 1**: Forensics investigation begins
**Day 2**: Multiple suspicious binaries found

### Forensics Workflow

```bash
# 1. Collect all binaries from compromised systems
collect-binaries --output=/forensics/binaries/

# 2. Extract signatures from each
for bin in /forensics/binaries/*; do
    dsmil-extract-signature $bin > $bin.sig.json
done

# 3. Batch query Layer 62 SIEM
for sig in /forensics/binaries/*.sig.json; do
    siem-query --layer=62 --match $sig
done

# Results:
# sensor_daemon.bin: MATCH (legitimate, v1.2.3)
# logger.bin: NO MATCH (attacker implant!)
# network_gateway.bin: PARTIAL MATCH 67% (tampered!)
# crypto_worker.bin: MATCH (legitimate, v2.1.0)
# monitor.bin: NO MATCH (attacker tool!)
```

### Analysis

```
Compromised Systems: 12
Total Binaries Found: 47

Legitimate (matched): 31
Tampered (partial match): 4  ← INVESTIGATE
Attacker Implants (no match): 12  ← ANALYZE

Action Items:
1. Quarantine systems with tampered binaries
2. Reverse-engineer attacker implants
3. Compare tampered binaries with known-good
4. Determine attack timeline from tampering patterns
```

---

## Feature Interaction Patterns

### Pattern 1: Stealth + Threat Signatures

**Use Case**: Covert operations with forensics backup

```bash
# Build covert binary with signature
dsmil-clang -fdsmil-mission-profile=covert_ops \
            -dsmil-threat-signature \
            -O3 -o covert.bin

# Result:
# - Low detectability (stealth)
# - Forensics-ready (signature)
# - If captured and modified, we can detect tampering
```

**Benefits**:
- ✅ Hard to detect while operational
- ✅ Easy to identify if compromised
- ✅ Best of both worlds

### Pattern 2: Blue/Red + Threat Signatures

**Use Case**: Development with supply chain verification

```bash
# Blue build with signature
dsmil-clang -fdsmil-role=blue \
            -dsmil-threat-signature \
            -O3 -o blue.bin

# Red build for testing (no signature needed)
dsmil-clang -fdsmil-role=red \
            -O3 -o red.bin

# Result:
# - Blue: Production + forensics-ready
# - Red: Testing only
# - Blue signature stored for future verification
```

**Benefits**:
- ✅ Production binaries verifiable
- ✅ Red builds help find vulnerabilities
- ✅ Supply chain protected

### Pattern 3: All Three Features

**Use Case**: Critical system development

```bash
# 1. Blue (production with stealth + signature)
dsmil-clang -fdsmil-role=blue \
            -fdsmil-mission-profile=border_ops_stealth \
            -dsmil-threat-signature \
            -O3 -o blue_stealth.bin

# 2. Red (testing)
dsmil-clang -fdsmil-role=red \
            -O3 -o red_test.bin

# Result:
# - Blue: Low-signature, forensics-ready, production
# - Red: Adversarial testing, never production
# - Comprehensive security coverage
```

**Benefits**:
- ✅ Passive defense (stealth)
- ✅ Active testing (red team)
- ✅ Forensics preparation (signatures)
- ✅ Complete security lifecycle

---

## CI/CD Integration

### Complete Pipeline

```yaml
# .github/workflows/v1.4-pipeline.yml
name: DSLLVM v1.4 Security Pipeline

jobs:
  # Job 1: Blue Build (Production)
  blue-build:
    runs-on: meteor-lake
    steps:
      - name: Build Blue with Threat Signature
        run: |
          dsmil-clang -fdsmil-role=blue \
                      -fdsmil-mission-profile=blue_production \
                      -dsmil-threat-signature \
                      -dsmil-threat-signature-output=prod.sig.json \
                      -O3 -o production.bin src/*.c

      - name: Store Signature in SIEM
        run: |
          ml-kem-encrypt prod.sig.json > prod.sig.enc
          siem-upload --layer=62 prod.sig.enc

      - name: Test Blue
        run: |
          ./production.bin --selftest

      - name: Deploy Blue
        run: |
          deploy-to-production production.bin

  # Job 2: Red Build (Testing)
  red-build:
    runs-on: test-cluster
    steps:
      - name: Build Red
        run: |
          dsmil-clang -fdsmil-role=red \
                      -fdsmil-mission-profile=red_stress_test \
                      -dsmil-red-output=red-analysis.json \
                      -O3 -o red.bin src/*.c

      - name: Run Red Scenarios
        run: |
          DSMIL_RED_SCENARIOS="all" ./red.bin

      - name: Analyze Attack Surface
        run: |
          jq '.attack_surfaces[] | select(.blast_radius_score > 70)' \
             red-analysis.json > high-risk.json

      - name: Fail if High-Risk Issues Found
        run: |
          if [ -s high-risk.json ]; then
            echo "High-risk attack surfaces found!"
            cat high-risk.json
            exit 1
          fi

  # Job 3: Stealth Build (Optional)
  stealth-build:
    runs-on: meteor-lake
    if: ${{ github.ref == 'refs/heads/covert-ops' }}
    steps:
      - name: Build Stealth with Threat Signature
        run: |
          dsmil-clang -fdsmil-mission-profile=covert_ops \
                      -dsmil-threat-signature \
                      -dsmil-threat-signature-output=covert.sig.json \
                      -O3 -o covert.bin src/*.c

      - name: Store Signature
        run: |
          ml-kem-encrypt covert.sig.json > covert.sig.enc
          siem-upload --layer=62 covert.sig.enc

      - name: Deploy to Covert Ops
        run: |
          deploy-covert covert.bin
```

---

## Best Practices

### 1. Always Enable Threat Signatures

```bash
# Production
-dsmil-threat-signature ✅

# Even stealth builds
-fdsmil-mission-profile=covert_ops -dsmil-threat-signature ✅
```

**Rationale**: Forensics capability is always valuable

### 2. Run Red Tests Before Blue Deployment

```bash
# 1. Build red
dsmil-clang -fdsmil-role=red ...

# 2. Run scenarios
DSMIL_RED_SCENARIOS="all" ./red.bin

# 3. Fix issues

# 4. THEN build and deploy blue
dsmil-clang -fdsmil-role=blue ...
```

### 3. Use Stealth Selectively

```bash
# Normal operations: standard build
-fdsmil-mission-profile=border_ops

# Hostile environment: stealth build
-fdsmil-mission-profile=covert_ops
```

### 4. Store Signatures Securely

```bash
# Always encrypt
ml-kem-encrypt signature.json

# Access control
chmod 600 signature.enc
chown siem:siem signature.enc
```

### 5. Periodic Signature Validation

```bash
# Weekly: Extract from production
extract-prod-signatures

# Compare with stored
siem-validate-all-signatures

# Alert on mismatches
```

---

## Troubleshooting

### Issue 1: Red Build in Production

**Error**: `Runtime rejected red build in production`

**Cause**: Red build accidentally deployed

**Solution**:
```bash
# Verify provenance
dsmil-verify --check-build-role production.bin

# Should show: build_role=blue
# If shows: build_role=red → REJECT immediately
```

### Issue 2: Stealth Mode Too Aggressive

**Symptom**: Can't debug production issues

**Solution**:
```bash
# Build companion test build
dsmil-clang -fdsmil-mission-profile=cyber_defence \
            -O3 -o test.bin

# Deploy test build to isolated environment
# Reproduce issue with full telemetry
```

### Issue 3: Signature Mismatch

**Symptom**: Known-good binary shows 65% match

**Cause**: Legitimate update or tampering?

**Solution**:
```bash
# Check version history
siem-query --layer=62 --history binary_name

# If version matches: likely legitimate
# If version mismatch: investigate tampering
```

---

## Summary

DSLLVM v1.4 provides **integrated security-in-depth**:

| Feature | When to Use | Deploy | Output |
|---------|-------------|--------|--------|
| **Stealth** | Hostile environments | ✅ Prod | Binary |
| **Blue/Red** | Development/testing | ❌ Test only | JSON |
| **Threat Sig** | Always | ✅ All builds | JSON |

**Integration Patterns**:
- Stealth + Signatures = Covert ops
- Blue/Red + Signatures = Secure development
- All three = Complete security lifecycle

**Key Principle**: Use all three together for maximum security coverage.

---

**Document Version**: 1.0
**Date**: 2025-11-25
**Next Review**: After first integrated deployment
