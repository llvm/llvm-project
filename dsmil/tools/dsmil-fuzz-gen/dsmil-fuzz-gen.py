#!/usr/bin/env python3
"""
DSLLVM Fuzz Harness Generator (L7 LLM Integration)

This tool reads .dsmilfuzz.json files and generates fuzzing harnesses
using Layer 7 LLM assistance for:
- libFuzzer harnesses
- AFL++ harnesses
- Honggfuzz harnesses

Version: 1.3.0
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
"""

import argparse
import json
import os
import sys
from typing import Dict, List, Optional
import textwrap

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False


class FuzzHarnessGenerator:
    """Generates fuzz harnesses from .dsmilfuzz.json specifications"""

    def __init__(self, schema_path: str, fuzzer: str = "libFuzzer",
                 l7_llm_url: Optional[str] = None, offline: bool = False):
        self.schema_path = schema_path
        self.fuzzer = fuzzer
        self.l7_llm_url = l7_llm_url or os.getenv("DSMIL_L7_LLM_URL")
        self.offline = offline or not REQUESTS_AVAILABLE
        self.schema = None
        self.load_schema()

    def load_schema(self):
        """Load and validate .dsmilfuzz.json schema"""
        try:
            with open(self.schema_path, 'r') as f:
                self.schema = json.load(f)

            if self.schema.get("schema") != "dsmil-fuzz-v1":
                print(f"[ERROR] Invalid schema version: {self.schema.get('schema')}")
                sys.exit(1)

            print(f"[dsmil-fuzz-gen] Loaded schema: {self.schema_path}")
            print(f"  Binary: {self.schema.get('binary')}")
            print(f"  Fuzz Targets: {len(self.schema.get('fuzz_targets', []))}")

        except FileNotFoundError:
            print(f"[ERROR] Schema file not found: {self.schema_path}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"[ERROR] Invalid JSON in schema: {e}")
            sys.exit(1)

    def query_l7_llm(self, prompt: str) -> Optional[str]:
        """Query Layer 7 LLM service for harness generation"""
        if self.offline:
            print("[INFO] Offline mode: Skipping L7 LLM query")
            return None

        if not self.l7_llm_url:
            print("[WARNING] No L7 LLM URL configured, using templates")
            return None

        try:
            payload = {
                "prompt": prompt,
                "model": "dsmil-l7-llm-v1",
                "temperature": 0.2,
                "max_tokens": 2048
            }
            response = requests.post(
                f"{self.l7_llm_url}/generate",
                json=payload,
                timeout=30
            )
            response.raise_for_status()
            return response.json().get("generated_code")

        except Exception as e:
            print(f"[WARNING] L7 LLM query failed: {e}")
            return None

    def generate_libfuzzer_harness(self, target: Dict) -> str:
        """Generate libFuzzer harness for a fuzz target"""
        function = target["function"]
        params = target["parameter_domains"]
        untrusted_params = target["untrusted_params"]

        # Build parameter list
        param_decls = []
        param_names = []
        for param_name, param_info in params.items():
            param_type = param_info["type"]

            # Map parameter types to C++ types
            if param_type == "bytes":
                param_decls.append(f"const uint8_t *{param_name}")
                param_names.append(param_name)
            elif param_type in ["int8_t", "int16_t", "int32_t", "int64_t",
                               "uint8_t", "uint16_t", "uint32_t", "uint64_t"]:
                param_decls.append(f"{param_type} {param_name}")
                param_names.append(param_name)
            elif param_type == "float":
                param_decls.append(f"float {param_name}")
                param_names.append(param_name)
            elif param_type == "double":
                param_decls.append(f"double {param_name}")
                param_names.append(param_name)
            else:
                param_decls.append(f"void *{param_name}")
                param_names.append(param_name)

        # Generate harness code
        harness = textwrap.dedent(f'''\
        /**
         * libFuzzer harness for: {function}
         *
         * Auto-generated by dsmil-fuzz-gen v1.3.0
         * L8 Risk Score: {target.get("l8_risk_score", 0.0):.2f} ({target.get("priority", "unknown")})
         * Source: {self.schema_path}
         */

        #include <cstdint>
        #include <cstddef>
        #include <cstring>

        // Forward declaration of fuzz target
        extern "C" void {function}({", ".join(param_decls)});

        // libFuzzer entry point
        extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {{
        ''')

        # Add size constraints
        has_length_param = False
        for param_name, param_info in params.items():
            if "max" in param_info:
                max_val = param_info["max"]
                harness += f"    if (size > {max_val}) return 0;  // Enforce max constraint\n"
            if "min" in param_info:
                min_val = param_info["min"]
                harness += f"    if (size < {min_val}) return 0;  // Enforce min constraint\n"

            # Track if we have a length parameter
            if "length_ref" in param_info:
                has_length_param = True

        harness += "\n"

        # Build parameter passing logic
        harness += "    // Extract parameters from fuzz input\n"

        # Simple case: single buffer parameter
        if len(untrusted_params) == 1 and params[untrusted_params[0]]["type"] == "bytes":
            buffer_param = untrusted_params[0]
            if "length_ref" in params[buffer_param]:
                length_param = params[buffer_param]["length_ref"]
                harness += f"    size_t {length_param} = size;\n"
                harness += f"    const uint8_t *{buffer_param} = data;\n\n"
                harness += f"    // Call fuzz target\n"
                harness += f"    {function}({buffer_param}, {length_param});\n"
            else:
                harness += f"    // Call fuzz target\n"
                harness += f"    {function}(data, size);\n"
        else:
            # Complex case: multiple parameters
            harness += "    // TODO: Multi-parameter fuzzing requires custom logic\n"
            harness += f"    // Parameters: {', '.join(untrusted_params)}\n"
            harness += "    // For now, treat as single buffer\n"
            harness += f"    {function}(data, size);\n"

        harness += textwrap.dedent('''\

            return 0;
        }

        /**
         * Compilation:
         *   clang++ -fsanitize=fuzzer,address,undefined \\
         *     -g -O1 {harness_file} -o fuzz_harness
         *
         * Execution:
         *   ./fuzz_harness -max_total_time=3600 \\
         *     -print_final_stats=1
         */
        ''')

        return harness

    def generate_afl_harness(self, target: Dict) -> str:
        """Generate AFL++ harness for a fuzz target"""
        function = target["function"]
        params = target["parameter_domains"]

        harness = textwrap.dedent(f'''\
        /**
         * AFL++ harness for: {function}
         *
         * Auto-generated by dsmil-fuzz-gen v1.3.0
         * L8 Risk Score: {target.get("l8_risk_score", 0.0):.2f}
         */

        #include <cstdint>
        #include <cstddef>
        #include <cstdio>
        #include <cstdlib>
        #include <unistd.h>

        // Forward declaration
        extern "C" void {function}();

        int main(int argc, char **argv) {{
            // Read input from stdin (AFL++ default)
            uint8_t buffer[65536];
            size_t size = fread(buffer, 1, sizeof(buffer), stdin);

            if (size == 0) return 0;

            // Call fuzz target
            {function}(buffer, size);

            return 0;
        }}

        /**
         * Compilation:
         *   afl-clang-fast++ -fsanitize=address \\
         *     {function}_afl.cpp -o {function}_afl
         *
         * Execution:
         *   afl-fuzz -i seeds -o findings -- ./{function}_afl @@
         */
        ''')

        return harness

    def generate_harness(self, target: Dict) -> str:
        """Generate harness code for a fuzz target"""
        if self.fuzzer == "libFuzzer":
            return self.generate_libfuzzer_harness(target)
        elif self.fuzzer == "AFL++":
            return self.generate_afl_harness(target)
        else:
            print(f"[ERROR] Unsupported fuzzer: {self.fuzzer}")
            sys.exit(1)

    def generate_all_harnesses(self, output_dir: str = "."):
        """Generate harnesses for all fuzz targets in schema"""
        targets = self.schema.get("fuzz_targets", [])
        if not targets:
            print("[WARNING] No fuzz targets found in schema")
            return

        os.makedirs(output_dir, exist_ok=True)

        for i, target in enumerate(targets):
            function = target["function"]
            priority = target.get("priority", "unknown")
            risk_score = target.get("l8_risk_score", 0.0)

            print(f"\n[{i+1}/{len(targets)}] Generating harness for: {function}")
            print(f"  Priority: {priority} (risk: {risk_score:.2f})")

            # Generate harness
            harness_code = self.generate_harness(target)

            # Write to file
            if self.fuzzer == "libFuzzer":
                output_file = os.path.join(output_dir, f"{function}_fuzz.cpp")
            elif self.fuzzer == "AFL++":
                output_file = os.path.join(output_dir, f"{function}_afl.cpp")
            else:
                output_file = os.path.join(output_dir, f"{function}_harness.cpp")

            with open(output_file, 'w') as f:
                f.write(harness_code)

            print(f"  âœ“ Wrote: {output_file}")

        print(f"\n[dsmil-fuzz-gen] Generated {len(targets)} harness(es)")


def main():
    parser = argparse.ArgumentParser(
        description="DSLLVM Fuzz Harness Generator (L7 LLM Integration)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent('''\
        Examples:
          # Generate libFuzzer harness
          dsmil-fuzz-gen network_daemon.dsmilfuzz.json

          # Generate AFL++ harness
          dsmil-fuzz-gen network_daemon.dsmilfuzz.json --fuzzer=AFL++

          # Use L7 LLM service
          export DSMIL_L7_LLM_URL=http://layer7-llm.local:8080/api/v1
          dsmil-fuzz-gen network_daemon.dsmilfuzz.json

          # Offline mode (template-based generation)
          dsmil-fuzz-gen network_daemon.dsmilfuzz.json --offline
        ''')
    )

    parser.add_argument("schema",
                       help="Path to .dsmilfuzz.json schema file")
    parser.add_argument("--fuzzer", "-f",
                       choices=["libFuzzer", "AFL++", "Honggfuzz"],
                       default="libFuzzer",
                       help="Target fuzzing engine (default: libFuzzer)")
    parser.add_argument("--output", "-o",
                       default=".",
                       help="Output directory for harness files (default: .)")
    parser.add_argument("--l7-llm-url",
                       help="Layer 7 LLM service URL (default: $DSMIL_L7_LLM_URL)")
    parser.add_argument("--offline",
                       action="store_true",
                       help="Offline mode (no L7 LLM queries)")
    parser.add_argument("--version", "-v",
                       action="version",
                       version="dsmil-fuzz-gen 1.3.0")

    args = parser.parse_args()

    # Create generator
    generator = FuzzHarnessGenerator(
        schema_path=args.schema,
        fuzzer=args.fuzzer,
        l7_llm_url=args.l7_llm_url,
        offline=args.offline
    )

    # Generate harnesses
    generator.generate_all_harnesses(output_dir=args.output)

    print("\n[dsmil-fuzz-gen] Done!")
    print(f"\nNext steps:")
    print(f"  1. Review generated harness files in: {args.output}/")
    print(f"  2. Compile with fuzzing instrumentation")
    print(f"  3. Run fuzzer with appropriate seeds")


if __name__ == "__main__":
    main()
