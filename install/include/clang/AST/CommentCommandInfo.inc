/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* A list of commands useable in documentation comments                       *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: CommentCommands.td                                                   *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace {
const CommandInfo Commands[] = {
  { "a", "", 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "abstract", "", 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "addindex", "", 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "addtogroup", "", 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "anchor", "", 4, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "arg", "", 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "attention", "", 6, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "author", "", 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "authors", "", 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "b", "", 9, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "brief", "", 10, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "bug", "", 11, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "c", "", 12, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "callgraph", "", 13, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "callback", "", 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "callergraph", "", 15, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "category", "", 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "cite", "", 17, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "class", "", 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "classdesign", "", 19, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "coclass", "", 20, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "code", "endcode", 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endcode", "", 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "concept", "", 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "cond", "", 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "const", "", 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "constant", "", 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "copybrief", "", 27, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "copydetails", "", 28, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "copydoc", "", 29, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "copyright", "", 30, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "date", "", 31, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "def", "", 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "defgroup", "", 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "dependency", "", 34, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "deprecated", "", 35, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "details", "", 36, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "diafile", "", 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "dir", "", 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "discussion", "", 39, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "docbookinclude", "", 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "docbookonly", "enddocbookonly", 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "enddocbookonly", "", 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "dontinclude", "", 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "dot", "enddot", 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "enddot", "", 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "dotfile", "", 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "e", "", 47, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "else", "", 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "elseif", "", 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "em", "", 50, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "emoji", "", 51, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "endcond", "", 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "endif", "", 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "enum", "", 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "example", "", 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "exception", "", 56, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "extends", "", 57, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "f{", "f}", 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "f}", "", 59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "f[", "f]", 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "f]", "", 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "f$", "f$", 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "f(", "f)", 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "f)", "", 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "file", "", 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "fn", "", 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "function", "", 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "functiongroup", "", 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "headerfile", "", 69, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "helper", "", 70, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "helperclass", "", 71, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "helps", "", 72, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "hidecallgraph", "", 73, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "hidecallergraph", "", 74, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "hideinitializer", "", 75, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "hiderefby", "", 76, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "hiderefs", "", 77, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "htmlinclude", "", 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "htmlonly", "endhtmlonly", 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endhtmlonly", "", 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "idlexcept", "", 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "if", "", 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "ifnot", "", 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "image", "", 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "implements", "", 85, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "include", "", 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "ingroup", "", 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "instancesize", "", 88, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "interface", "", 89, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "internal", "endinternal", 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endinternal", "", 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "invariant", "", 92, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "latexinclude", "", 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "latexonly", "endlatexonly", 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endlatexonly", "", 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "li", "", 96, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "line", "", 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "link", "/link", 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "/link", "", 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "mainpage", "", 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "maninclude", "", 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "manonly", "endmanonly", 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endmanonly", "", 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "memberof", "", 104, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "method", "", 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "methodgroup", "", 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0 },
  { "msc", "endmsc", 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endmsc", "", 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "mscfile", "", 109, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "n", "", 110, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "name", "", 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "namespace", "", 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "noop", "", 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "nosubgrouping", "", 114, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "note", "", 115, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "overload", "", 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "ownership", "", 117, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "p", "", 118, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "page", "", 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "par", "", 120, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "parblock", "endparblock", 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endparblock", "", 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "paragraph", "", 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "param", "", 124, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "performance", "", 125, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "post", "", 126, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "pre", "", 127, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "private", "", 128, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "privatesection", "", 129, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "property", "", 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "protected", "", 131, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "protectedsection", "", 132, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "protocol", "", 133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "public", "", 134, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "publicsection", "", 135, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "pure", "", 136, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "ref", "", 137, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "refitem", "", 138, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "related", "", 139, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "relatedalso", "", 140, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "relates", "", 141, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "relatesalso", "", 142, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "remark", "", 143, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "remarks", "", 144, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "result", "", 145, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "return", "", 146, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "returns", "", 147, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "retval", "", 148, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "rtfinclude", "", 149, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "rtfonly", "endrtfonly", 150, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endrtfonly", "", 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "sa", "", 152, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "secreflist", "endsecreflist", 153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endsecreflist", "", 154, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "section", "", 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "security", "", 156, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "see", "", 157, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "seealso", "", 158, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "short", "", 159, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "showinitializer", "", 160, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "showrefby", "", 161, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "showrefs", "", 162, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "since", "", 163, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "skip", "", 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "skipline", "", 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "snippet", "", 166, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "static", "", 167, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "struct", "", 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "subpage", "", 169, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "subsection", "", 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "subsubsection", "", 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "superclass", "", 172, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
  { "tableofcontents", "", 173, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "template", "", 174, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "templatefield", "", 175, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "test", "", 176, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "textblock", "/textblock", 177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "/textblock", "", 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "throw", "", 179, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "throws", "", 180, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "todo", "", 181, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "tparam", "", 182, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "typedef", "", 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "startuml", "enduml", 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "enduml", "", 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "union", "", 186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
  { "until", "", 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "var", "", 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
  { "verbinclude", "", 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "verbatim", "endverbatim", 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endverbatim", "", 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
  { "version", "", 192, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "warning", "", 193, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "weakgroup", "", 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "xrefitem", "", 195, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { "xmlinclude", "", 196, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
  { "xmlonly", "endxmlonly", 197, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
  { "endxmlonly", "", 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }
};
} // unnamed namespace

const CommandInfo *CommandTraits::getBuiltinCommandInfo(
                                         StringRef Name) {
  switch (Name.size()) {
  default: break;
  case 1:	 // 6 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      return &Commands[0];	 // "a"
    case 'b':	 // 1 string to match.
      return &Commands[9];	 // "b"
    case 'c':	 // 1 string to match.
      return &Commands[12];	 // "c"
    case 'e':	 // 1 string to match.
      return &Commands[47];	 // "e"
    case 'n':	 // 1 string to match.
      return &Commands[110];	 // "n"
    case 'p':	 // 1 string to match.
      return &Commands[118];	 // "p"
    }
    break;
  case 2:	 // 12 strings to match.
    switch (Name[0]) {
    default: break;
    case 'e':	 // 1 string to match.
      if (Name[1] != 'm')
        break;
      return &Commands[50];	 // "em"
    case 'f':	 // 8 strings to match.
      switch (Name[1]) {
      default: break;
      case '$':	 // 1 string to match.
        return &Commands[62];	 // "f$"
      case '(':	 // 1 string to match.
        return &Commands[63];	 // "f("
      case ')':	 // 1 string to match.
        return &Commands[64];	 // "f)"
      case '[':	 // 1 string to match.
        return &Commands[60];	 // "f["
      case ']':	 // 1 string to match.
        return &Commands[61];	 // "f]"
      case 'n':	 // 1 string to match.
        return &Commands[66];	 // "fn"
      case '{':	 // 1 string to match.
        return &Commands[58];	 // "f{"
      case '}':	 // 1 string to match.
        return &Commands[59];	 // "f}"
      }
      break;
    case 'i':	 // 1 string to match.
      if (Name[1] != 'f')
        break;
      return &Commands[82];	 // "if"
    case 'l':	 // 1 string to match.
      if (Name[1] != 'i')
        break;
      return &Commands[96];	 // "li"
    case 's':	 // 1 string to match.
      if (Name[1] != 'a')
        break;
      return &Commands[152];	 // "sa"
    }
    break;
  case 3:	 // 11 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rg", 2) != 0)
        break;
      return &Commands[5];	 // "arg"
    case 'b':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ug", 2) != 0)
        break;
      return &Commands[11];	 // "bug"
    case 'd':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (Name[2] != 'f')
          break;
        return &Commands[32];	 // "def"
      case 'i':	 // 1 string to match.
        if (Name[2] != 'r')
          break;
        return &Commands[38];	 // "dir"
      case 'o':	 // 1 string to match.
        if (Name[2] != 't')
          break;
        return &Commands[44];	 // "dot"
      }
      break;
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "sc", 2) != 0)
        break;
      return &Commands[107];	 // "msc"
    case 'p':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (Name[2] != 'r')
          break;
        return &Commands[120];	 // "par"
      case 'r':	 // 1 string to match.
        if (Name[2] != 'e')
          break;
        return &Commands[127];	 // "pre"
      }
      break;
    case 'r':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ef", 2) != 0)
        break;
      return &Commands[137];	 // "ref"
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ee", 2) != 0)
        break;
      return &Commands[157];	 // "see"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ar", 2) != 0)
        break;
      return &Commands[188];	 // "var"
    }
    break;
  case 4:	 // 18 strings to match.
    switch (Name[0]) {
    default: break;
    case 'c':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "te", 2) != 0)
          break;
        return &Commands[17];	 // "cite"
      case 'o':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'd':	 // 1 string to match.
          if (Name[3] != 'e')
            break;
          return &Commands[21];	 // "code"
        case 'n':	 // 1 string to match.
          if (Name[3] != 'd')
            break;
          return &Commands[24];	 // "cond"
        }
        break;
      }
      break;
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ate", 3) != 0)
        break;
      return &Commands[31];	 // "date"
    case 'e':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'l':	 // 1 string to match.
        if (memcmp(Name.data()+2, "se", 2) != 0)
          break;
        return &Commands[48];	 // "else"
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+2, "um", 2) != 0)
          break;
        return &Commands[54];	 // "enum"
      }
      break;
    case 'f':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ile", 3) != 0)
        break;
      return &Commands[65];	 // "file"
    case 'l':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "in", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'e':	 // 1 string to match.
        return &Commands[97];	 // "line"
      case 'k':	 // 1 string to match.
        return &Commands[98];	 // "link"
      }
      break;
    case 'n':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "me", 2) != 0)
          break;
        return &Commands[111];	 // "name"
      case 'o':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'o':	 // 1 string to match.
          if (Name[3] != 'p')
            break;
          return &Commands[113];	 // "noop"
        case 't':	 // 1 string to match.
          if (Name[3] != 'e')
            break;
          return &Commands[115];	 // "note"
        }
        break;
      }
      break;
    case 'p':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ge", 2) != 0)
          break;
        return &Commands[119];	 // "page"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "st", 2) != 0)
          break;
        return &Commands[126];	 // "post"
      case 'u':	 // 1 string to match.
        if (memcmp(Name.data()+2, "re", 2) != 0)
          break;
        return &Commands[136];	 // "pure"
      }
      break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "kip", 3) != 0)
        break;
      return &Commands[164];	 // "skip"
    case 't':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "st", 2) != 0)
          break;
        return &Commands[176];	 // "test"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "do", 2) != 0)
          break;
        return &Commands[181];	 // "todo"
      }
      break;
    }
    break;
  case 5:	 // 15 strings to match.
    switch (Name[0]) {
    default: break;
    case '/':	 // 1 string to match.
      if (memcmp(Name.data()+1, "link", 4) != 0)
        break;
      return &Commands[99];	 // "/link"
    case 'b':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rief", 4) != 0)
        break;
      return &Commands[10];	 // "brief"
    case 'c':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'l':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ass", 3) != 0)
          break;
        return &Commands[18];	 // "class"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nst", 3) != 0)
          break;
        return &Commands[25];	 // "const"
      }
      break;
    case 'e':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+2, "oji", 3) != 0)
          break;
        return &Commands[51];	 // "emoji"
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+2, "dif", 3) != 0)
          break;
        return &Commands[53];	 // "endif"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "elps", 4) != 0)
        break;
      return &Commands[72];	 // "helps"
    case 'i':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'f':	 // 1 string to match.
        if (memcmp(Name.data()+2, "not", 3) != 0)
          break;
        return &Commands[83];	 // "ifnot"
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+2, "age", 3) != 0)
          break;
        return &Commands[84];	 // "image"
      }
      break;
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "aram", 4) != 0)
        break;
      return &Commands[124];	 // "param"
    case 's':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ort", 3) != 0)
          break;
        return &Commands[159];	 // "short"
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nce", 3) != 0)
          break;
        return &Commands[163];	 // "since"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "hrow", 4) != 0)
        break;
      return &Commands[179];	 // "throw"
    case 'u':	 // 2 strings to match.
      if (Name[1] != 'n')
        break;
      switch (Name[2]) {
      default: break;
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+3, "on", 2) != 0)
          break;
        return &Commands[186];	 // "union"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+3, "il", 2) != 0)
          break;
        return &Commands[187];	 // "until"
      }
      break;
    }
    break;
  case 6:	 // 17 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+2, "chor", 4) != 0)
          break;
        return &Commands[4];	 // "anchor"
      case 'u':	 // 1 string to match.
        if (memcmp(Name.data()+2, "thor", 4) != 0)
          break;
        return &Commands[7];	 // "author"
      }
      break;
    case 'e':	 // 4 strings to match.
      switch (Name[1]) {
      default: break;
      case 'l':	 // 1 string to match.
        if (memcmp(Name.data()+2, "seif", 4) != 0)
          break;
        return &Commands[49];	 // "elseif"
      case 'n':	 // 3 strings to match.
        if (Name[2] != 'd')
          break;
        switch (Name[3]) {
        default: break;
        case 'd':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ot", 2) != 0)
            break;
          return &Commands[45];	 // "enddot"
        case 'm':	 // 1 string to match.
          if (memcmp(Name.data()+4, "sc", 2) != 0)
            break;
          return &Commands[108];	 // "endmsc"
        case 'u':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ml", 2) != 0)
            break;
          return &Commands[185];	 // "enduml"
        }
        break;
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "elper", 5) != 0)
        break;
      return &Commands[70];	 // "helper"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ethod", 5) != 0)
        break;
      return &Commands[105];	 // "method"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ublic", 5) != 0)
        break;
      return &Commands[134];	 // "public"
    case 'r':	 // 4 strings to match.
      if (Name[1] != 'e')
        break;
      switch (Name[2]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ark", 3) != 0)
          break;
        return &Commands[143];	 // "remark"
      case 's':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ult", 3) != 0)
          break;
        return &Commands[145];	 // "result"
      case 't':	 // 2 strings to match.
        switch (Name[3]) {
        default: break;
        case 'u':	 // 1 string to match.
          if (memcmp(Name.data()+4, "rn", 2) != 0)
            break;
          return &Commands[146];	 // "return"
        case 'v':	 // 1 string to match.
          if (memcmp(Name.data()+4, "al", 2) != 0)
            break;
          return &Commands[148];	 // "retval"
        }
        break;
      }
      break;
    case 's':	 // 2 strings to match.
      if (Name[1] != 't')
        break;
      switch (Name[2]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+3, "tic", 3) != 0)
          break;
        return &Commands[167];	 // "static"
      case 'r':	 // 1 string to match.
        if (memcmp(Name.data()+3, "uct", 3) != 0)
          break;
        return &Commands[168];	 // "struct"
      }
      break;
    case 't':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+2, "rows", 4) != 0)
          break;
        return &Commands[180];	 // "throws"
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+2, "aram", 4) != 0)
          break;
        return &Commands[182];	 // "tparam"
      }
      break;
    }
    break;
  case 7:	 // 30 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "uthors", 6) != 0)
        break;
      return &Commands[8];	 // "authors"
    case 'c':	 // 3 strings to match.
      if (Name[1] != 'o')
        break;
      switch (Name[2]) {
      default: break;
      case 'c':	 // 1 string to match.
        if (memcmp(Name.data()+3, "lass", 4) != 0)
          break;
        return &Commands[20];	 // "coclass"
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+3, "cept", 4) != 0)
          break;
        return &Commands[23];	 // "concept"
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+3, "ydoc", 4) != 0)
          break;
        return &Commands[29];	 // "copydoc"
      }
      break;
    case 'd':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "tails", 5) != 0)
          break;
        return &Commands[36];	 // "details"
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "afile", 5) != 0)
          break;
        return &Commands[37];	 // "diafile"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "tfile", 5) != 0)
          break;
        return &Commands[46];	 // "dotfile"
      }
      break;
    case 'e':	 // 4 strings to match.
      switch (Name[1]) {
      default: break;
      case 'n':	 // 2 strings to match.
        if (memcmp(Name.data()+2, "dco", 3) != 0)
          break;
        switch (Name[5]) {
        default: break;
        case 'd':	 // 1 string to match.
          if (Name[6] != 'e')
            break;
          return &Commands[22];	 // "endcode"
        case 'n':	 // 1 string to match.
          if (Name[6] != 'd')
            break;
          return &Commands[52];	 // "endcond"
        }
        break;
      case 'x':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'a':	 // 1 string to match.
          if (memcmp(Name.data()+3, "mple", 4) != 0)
            break;
          return &Commands[55];	 // "example"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "ends", 4) != 0)
            break;
          return &Commands[57];	 // "extends"
        }
        break;
      }
      break;
    case 'i':	 // 2 strings to match.
      if (Name[1] != 'n')
        break;
      switch (Name[2]) {
      default: break;
      case 'c':	 // 1 string to match.
        if (memcmp(Name.data()+3, "lude", 4) != 0)
          break;
        return &Commands[86];	 // "include"
      case 'g':	 // 1 string to match.
        if (memcmp(Name.data()+3, "roup", 4) != 0)
          break;
        return &Commands[87];	 // "ingroup"
      }
      break;
    case 'm':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nonly", 5) != 0)
          break;
        return &Commands[102];	 // "manonly"
      case 's':	 // 1 string to match.
        if (memcmp(Name.data()+2, "cfile", 5) != 0)
          break;
        return &Commands[109];	 // "mscfile"
      }
      break;
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rivate", 6) != 0)
        break;
      return &Commands[128];	 // "private"
    case 'r':	 // 6 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 5 strings to match.
        switch (Name[2]) {
        default: break;
        case 'f':	 // 1 string to match.
          if (memcmp(Name.data()+3, "item", 4) != 0)
            break;
          return &Commands[138];	 // "refitem"
        case 'l':	 // 2 strings to match.
          if (memcmp(Name.data()+3, "ate", 3) != 0)
            break;
          switch (Name[6]) {
          default: break;
          case 'd':	 // 1 string to match.
            return &Commands[139];	 // "related"
          case 's':	 // 1 string to match.
            return &Commands[141];	 // "relates"
          }
          break;
        case 'm':	 // 1 string to match.
          if (memcmp(Name.data()+3, "arks", 4) != 0)
            break;
          return &Commands[144];	 // "remarks"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "urns", 4) != 0)
            break;
          return &Commands[147];	 // "returns"
        }
        break;
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+2, "fonly", 5) != 0)
          break;
        return &Commands[150];	 // "rtfonly"
      }
      break;
    case 's':	 // 4 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'c':	 // 1 string to match.
          if (memcmp(Name.data()+3, "tion", 4) != 0)
            break;
          return &Commands[155];	 // "section"
        case 'e':	 // 1 string to match.
          if (memcmp(Name.data()+3, "also", 4) != 0)
            break;
          return &Commands[158];	 // "seealso"
        }
        break;
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ippet", 5) != 0)
          break;
        return &Commands[166];	 // "snippet"
      case 'u':	 // 1 string to match.
        if (memcmp(Name.data()+2, "bpage", 5) != 0)
          break;
        return &Commands[169];	 // "subpage"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ypedef", 6) != 0)
        break;
      return &Commands[183];	 // "typedef"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ersion", 6) != 0)
        break;
      return &Commands[192];	 // "version"
    case 'w':	 // 1 string to match.
      if (memcmp(Name.data()+1, "arning", 6) != 0)
        break;
      return &Commands[193];	 // "warning"
    case 'x':	 // 1 string to match.
      if (memcmp(Name.data()+1, "mlonly", 6) != 0)
        break;
      return &Commands[197];	 // "xmlonly"
    }
    break;
  case 8:	 // 23 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'b':	 // 1 string to match.
        if (memcmp(Name.data()+2, "stract", 6) != 0)
          break;
        return &Commands[1];	 // "abstract"
      case 'd':	 // 1 string to match.
        if (memcmp(Name.data()+2, "dindex", 6) != 0)
          break;
        return &Commands[2];	 // "addindex"
      }
      break;
    case 'c':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'l':	 // 1 string to match.
          if (memcmp(Name.data()+3, "lback", 5) != 0)
            break;
          return &Commands[14];	 // "callback"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "egory", 5) != 0)
            break;
          return &Commands[16];	 // "category"
        }
        break;
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "nstant", 6) != 0)
          break;
        return &Commands[26];	 // "constant"
      }
      break;
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "efgroup", 7) != 0)
        break;
      return &Commands[33];	 // "defgroup"
    case 'f':	 // 1 string to match.
      if (memcmp(Name.data()+1, "unction", 7) != 0)
        break;
      return &Commands[67];	 // "function"
    case 'h':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "derefs", 6) != 0)
          break;
        return &Commands[77];	 // "hiderefs"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+2, "mlonly", 6) != 0)
          break;
        return &Commands[79];	 // "htmlonly"
      }
      break;
    case 'i':	 // 1 string to match.
      if (memcmp(Name.data()+1, "nternal", 7) != 0)
        break;
      return &Commands[90];	 // "internal"
    case 'm':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "inpage", 6) != 0)
          break;
        return &Commands[100];	 // "mainpage"
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "mberof", 6) != 0)
          break;
        return &Commands[104];	 // "memberof"
      }
      break;
    case 'o':	 // 1 string to match.
      if (memcmp(Name.data()+1, "verload", 7) != 0)
        break;
      return &Commands[116];	 // "overload"
    case 'p':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "rblock", 6) != 0)
          break;
        return &Commands[121];	 // "parblock"
      case 'r':	 // 2 strings to match.
        if (Name[2] != 'o')
          break;
        switch (Name[3]) {
        default: break;
        case 'p':	 // 1 string to match.
          if (memcmp(Name.data()+4, "erty", 4) != 0)
            break;
          return &Commands[130];	 // "property"
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ocol", 4) != 0)
            break;
          return &Commands[133];	 // "protocol"
        }
        break;
      }
      break;
    case 's':	 // 4 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "curity", 6) != 0)
          break;
        return &Commands[156];	 // "security"
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+2, "owrefs", 6) != 0)
          break;
        return &Commands[162];	 // "showrefs"
      case 'k':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ipline", 6) != 0)
          break;
        return &Commands[165];	 // "skipline"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+2, "artuml", 6) != 0)
          break;
        return &Commands[184];	 // "startuml"
      }
      break;
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "emplate", 7) != 0)
        break;
      return &Commands[174];	 // "template"
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "erbatim", 7) != 0)
        break;
      return &Commands[190];	 // "verbatim"
    case 'x':	 // 1 string to match.
      if (memcmp(Name.data()+1, "refitem", 7) != 0)
        break;
      return &Commands[195];	 // "xrefitem"
    }
    break;
  case 9:	 // 17 strings to match.
    switch (Name[0]) {
    default: break;
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ttention", 8) != 0)
        break;
      return &Commands[6];	 // "attention"
    case 'c':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "llgraph", 7) != 0)
          break;
        return &Commands[13];	 // "callgraph"
      case 'o':	 // 2 strings to match.
        if (memcmp(Name.data()+2, "py", 2) != 0)
          break;
        switch (Name[4]) {
        default: break;
        case 'b':	 // 1 string to match.
          if (memcmp(Name.data()+5, "rief", 4) != 0)
            break;
          return &Commands[27];	 // "copybrief"
        case 'r':	 // 1 string to match.
          if (memcmp(Name.data()+5, "ight", 4) != 0)
            break;
          return &Commands[30];	 // "copyright"
        }
        break;
      }
      break;
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "xception", 8) != 0)
        break;
      return &Commands[56];	 // "exception"
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "iderefby", 8) != 0)
        break;
      return &Commands[76];	 // "hiderefby"
    case 'i':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'd':	 // 1 string to match.
        if (memcmp(Name.data()+2, "lexcept", 7) != 0)
          break;
        return &Commands[81];	 // "idlexcept"
      case 'n':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 't':	 // 1 string to match.
          if (memcmp(Name.data()+3, "erface", 6) != 0)
            break;
          return &Commands[89];	 // "interface"
        case 'v':	 // 1 string to match.
          if (memcmp(Name.data()+3, "ariant", 6) != 0)
            break;
          return &Commands[92];	 // "invariant"
        }
        break;
      }
      break;
    case 'l':	 // 1 string to match.
      if (memcmp(Name.data()+1, "atexonly", 8) != 0)
        break;
      return &Commands[94];	 // "latexonly"
    case 'n':	 // 1 string to match.
      if (memcmp(Name.data()+1, "amespace", 8) != 0)
        break;
      return &Commands[112];	 // "namespace"
    case 'o':	 // 1 string to match.
      if (memcmp(Name.data()+1, "wnership", 8) != 0)
        break;
      return &Commands[117];	 // "ownership"
    case 'p':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "ragraph", 7) != 0)
          break;
        return &Commands[123];	 // "paragraph"
      case 'r':	 // 1 string to match.
        if (memcmp(Name.data()+2, "otected", 7) != 0)
          break;
        return &Commands[131];	 // "protected"
      }
      break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "howrefby", 8) != 0)
        break;
      return &Commands[161];	 // "showrefby"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "extblock", 8) != 0)
        break;
      return &Commands[177];	 // "textblock"
    case 'w':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eakgroup", 8) != 0)
        break;
      return &Commands[194];	 // "weakgroup"
    }
    break;
  case 10:	 // 16 strings to match.
    switch (Name[0]) {
    default: break;
    case '/':	 // 1 string to match.
      if (memcmp(Name.data()+1, "textblock", 9) != 0)
        break;
      return &Commands[178];	 // "/textblock"
    case 'a':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ddtogroup", 9) != 0)
        break;
      return &Commands[3];	 // "addtogroup"
    case 'd':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 2 strings to match.
        if (Name[2] != 'p')
          break;
        switch (Name[3]) {
        default: break;
        case 'e':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ndency", 6) != 0)
            break;
          return &Commands[34];	 // "dependency"
        case 'r':	 // 1 string to match.
          if (memcmp(Name.data()+4, "ecated", 6) != 0)
            break;
          return &Commands[35];	 // "deprecated"
        }
        break;
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+2, "scussion", 8) != 0)
          break;
        return &Commands[39];	 // "discussion"
      }
      break;
    case 'e':	 // 3 strings to match.
      if (memcmp(Name.data()+1, "nd", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'm':	 // 1 string to match.
        if (memcmp(Name.data()+4, "anonly", 6) != 0)
          break;
        return &Commands[103];	 // "endmanonly"
      case 'r':	 // 1 string to match.
        if (memcmp(Name.data()+4, "tfonly", 6) != 0)
          break;
        return &Commands[151];	 // "endrtfonly"
      case 'x':	 // 1 string to match.
        if (memcmp(Name.data()+4, "mlonly", 6) != 0)
          break;
        return &Commands[198];	 // "endxmlonly"
      }
      break;
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "eaderfile", 9) != 0)
        break;
      return &Commands[69];	 // "headerfile"
    case 'i':	 // 1 string to match.
      if (memcmp(Name.data()+1, "mplements", 9) != 0)
        break;
      return &Commands[85];	 // "implements"
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "aninclude", 9) != 0)
        break;
      return &Commands[101];	 // "maninclude"
    case 'r':	 // 1 string to match.
      if (memcmp(Name.data()+1, "tfinclude", 9) != 0)
        break;
      return &Commands[149];	 // "rtfinclude"
    case 's':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "creflist", 8) != 0)
          break;
        return &Commands[153];	 // "secreflist"
      case 'u':	 // 2 strings to match.
        switch (Name[2]) {
        default: break;
        case 'b':	 // 1 string to match.
          if (memcmp(Name.data()+3, "section", 7) != 0)
            break;
          return &Commands[170];	 // "subsection"
        case 'p':	 // 1 string to match.
          if (memcmp(Name.data()+3, "erclass", 7) != 0)
            break;
          return &Commands[172];	 // "superclass"
        }
        break;
      }
      break;
    case 'x':	 // 1 string to match.
      if (memcmp(Name.data()+1, "mlinclude", 9) != 0)
        break;
      return &Commands[196];	 // "xmlinclude"
    }
    break;
  case 11:	 // 16 strings to match.
    switch (Name[0]) {
    default: break;
    case 'c':	 // 3 strings to match.
      switch (Name[1]) {
      default: break;
      case 'a':	 // 1 string to match.
        if (memcmp(Name.data()+2, "llergraph", 9) != 0)
          break;
        return &Commands[15];	 // "callergraph"
      case 'l':	 // 1 string to match.
        if (memcmp(Name.data()+2, "assdesign", 9) != 0)
          break;
        return &Commands[19];	 // "classdesign"
      case 'o':	 // 1 string to match.
        if (memcmp(Name.data()+2, "pydetails", 9) != 0)
          break;
        return &Commands[28];	 // "copydetails"
      }
      break;
    case 'd':	 // 2 strings to match.
      if (Name[1] != 'o')
        break;
      switch (Name[2]) {
      default: break;
      case 'c':	 // 1 string to match.
        if (memcmp(Name.data()+3, "bookonly", 8) != 0)
          break;
        return &Commands[41];	 // "docbookonly"
      case 'n':	 // 1 string to match.
        if (memcmp(Name.data()+3, "tinclude", 8) != 0)
          break;
        return &Commands[43];	 // "dontinclude"
      }
      break;
    case 'e':	 // 4 strings to match.
      if (memcmp(Name.data()+1, "nd", 2) != 0)
        break;
      switch (Name[3]) {
      default: break;
      case 'h':	 // 1 string to match.
        if (memcmp(Name.data()+4, "tmlonly", 7) != 0)
          break;
        return &Commands[80];	 // "endhtmlonly"
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+4, "nternal", 7) != 0)
          break;
        return &Commands[91];	 // "endinternal"
      case 'p':	 // 1 string to match.
        if (memcmp(Name.data()+4, "arblock", 7) != 0)
          break;
        return &Commands[122];	 // "endparblock"
      case 'v':	 // 1 string to match.
        if (memcmp(Name.data()+4, "erbatim", 7) != 0)
          break;
        return &Commands[191];	 // "endverbatim"
      }
      break;
    case 'h':	 // 2 strings to match.
      switch (Name[1]) {
      default: break;
      case 'e':	 // 1 string to match.
        if (memcmp(Name.data()+2, "lperclass", 9) != 0)
          break;
        return &Commands[71];	 // "helperclass"
      case 't':	 // 1 string to match.
        if (memcmp(Name.data()+2, "mlinclude", 9) != 0)
          break;
        return &Commands[78];	 // "htmlinclude"
      }
      break;
    case 'm':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ethodgroup", 10) != 0)
        break;
      return &Commands[106];	 // "methodgroup"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "erformance", 10) != 0)
        break;
      return &Commands[125];	 // "performance"
    case 'r':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "elate", 5) != 0)
        break;
      switch (Name[6]) {
      default: break;
      case 'd':	 // 1 string to match.
        if (memcmp(Name.data()+7, "also", 4) != 0)
          break;
        return &Commands[140];	 // "relatedalso"
      case 's':	 // 1 string to match.
        if (memcmp(Name.data()+7, "also", 4) != 0)
          break;
        return &Commands[142];	 // "relatesalso"
      }
      break;
    case 'v':	 // 1 string to match.
      if (memcmp(Name.data()+1, "erbinclude", 10) != 0)
        break;
      return &Commands[189];	 // "verbinclude"
    }
    break;
  case 12:	 // 3 strings to match.
    switch (Name[0]) {
    default: break;
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ndlatexonly", 11) != 0)
        break;
      return &Commands[95];	 // "endlatexonly"
    case 'i':	 // 1 string to match.
      if (memcmp(Name.data()+1, "nstancesize", 11) != 0)
        break;
      return &Commands[88];	 // "instancesize"
    case 'l':	 // 1 string to match.
      if (memcmp(Name.data()+1, "atexinclude", 11) != 0)
        break;
      return &Commands[93];	 // "latexinclude"
    }
    break;
  case 13:	 // 7 strings to match.
    switch (Name[0]) {
    default: break;
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ndsecreflist", 12) != 0)
        break;
      return &Commands[154];	 // "endsecreflist"
    case 'f':	 // 1 string to match.
      if (memcmp(Name.data()+1, "unctiongroup", 12) != 0)
        break;
      return &Commands[68];	 // "functiongroup"
    case 'h':	 // 1 string to match.
      if (memcmp(Name.data()+1, "idecallgraph", 12) != 0)
        break;
      return &Commands[73];	 // "hidecallgraph"
    case 'n':	 // 1 string to match.
      if (memcmp(Name.data()+1, "osubgrouping", 12) != 0)
        break;
      return &Commands[114];	 // "nosubgrouping"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ublicsection", 12) != 0)
        break;
      return &Commands[135];	 // "publicsection"
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ubsubsection", 12) != 0)
        break;
      return &Commands[171];	 // "subsubsection"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "emplatefield", 12) != 0)
        break;
      return &Commands[175];	 // "templatefield"
    }
    break;
  case 14:	 // 3 strings to match.
    switch (Name[0]) {
    default: break;
    case 'd':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ocbookinclude", 13) != 0)
        break;
      return &Commands[40];	 // "docbookinclude"
    case 'e':	 // 1 string to match.
      if (memcmp(Name.data()+1, "nddocbookonly", 13) != 0)
        break;
      return &Commands[42];	 // "enddocbookonly"
    case 'p':	 // 1 string to match.
      if (memcmp(Name.data()+1, "rivatesection", 13) != 0)
        break;
      return &Commands[129];	 // "privatesection"
    }
    break;
  case 15:	 // 4 strings to match.
    switch (Name[0]) {
    default: break;
    case 'h':	 // 2 strings to match.
      if (memcmp(Name.data()+1, "ide", 3) != 0)
        break;
      switch (Name[4]) {
      default: break;
      case 'c':	 // 1 string to match.
        if (memcmp(Name.data()+5, "allergraph", 10) != 0)
          break;
        return &Commands[74];	 // "hidecallergraph"
      case 'i':	 // 1 string to match.
        if (memcmp(Name.data()+5, "nitializer", 10) != 0)
          break;
        return &Commands[75];	 // "hideinitializer"
      }
      break;
    case 's':	 // 1 string to match.
      if (memcmp(Name.data()+1, "howinitializer", 14) != 0)
        break;
      return &Commands[160];	 // "showinitializer"
    case 't':	 // 1 string to match.
      if (memcmp(Name.data()+1, "ableofcontents", 14) != 0)
        break;
      return &Commands[173];	 // "tableofcontents"
    }
    break;
  case 16:	 // 1 string to match.
    if (memcmp(Name.data()+0, "protectedsection", 16) != 0)
      break;
    return &Commands[132];	 // "protectedsection"
  }
  return nullptr;
}

